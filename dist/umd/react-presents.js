!function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory(require("react"), require("react-dom")) : "function" == typeof define && define.amd ? define([ "react", "react-dom" ], factory) : "object" == typeof exports ? exports.ReactPresents = factory(require("react"), require("react-dom")) : root.ReactPresents = factory(root.React, root.ReactDOM);
}(this, function(__WEBPACK_EXTERNAL_MODULE_109__, __WEBPACK_EXTERNAL_MODULE_198__) {
    /******/
    return function(modules) {
        /******/
        /******/
        // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
            return installedModules[moduleId].exports;
            /******/
            /******/
            // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                exports: {},
                /******/
                id: moduleId,
                /******/
                loaded: !1
            };
            /******/
            /******/
            // Return the exports of the module
            /******/
            /******/
            /******/
            // Execute the module function
            /******/
            /******/
            /******/
            // Flag the module as loaded
            /******/
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
        var installedModules = {};
        /******/
        /******/
        // Load entry module and return exports
        /******/
        /******/
        /******/
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        /******/
        /******/
        // expose the module cache
        /******/
        /******/
        /******/
        // __webpack_public_path__
        /******/
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ /* 0 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.TitleSlide = exports.Step = exports.Slide = exports.PropTypes = exports.PresenterModePlugin = exports.Presentation = exports.IconButton = exports.DropDownNav = exports.ContentSlide = exports.Code = void 0;
        var _Code = __webpack_require__(1), _Code2 = _interopRequireDefault(_Code), _ContentSlide = __webpack_require__(191), _ContentSlide2 = _interopRequireDefault(_ContentSlide), _DropDownNav = __webpack_require__(193), _DropDownNav2 = _interopRequireDefault(_DropDownNav), _IconButton = __webpack_require__(229), _IconButton2 = _interopRequireDefault(_IconButton), _Presentation = __webpack_require__(234), _Presentation2 = _interopRequireDefault(_Presentation), _PresenterModePlugin = __webpack_require__(278), _PresenterModePlugin2 = _interopRequireDefault(_PresenterModePlugin), _PropTypes = __webpack_require__(232), _PropTypes2 = _interopRequireDefault(_PropTypes), _Slide = __webpack_require__(285), _Slide2 = _interopRequireDefault(_Slide), _Step = __webpack_require__(286), _Step2 = _interopRequireDefault(_Step), _TitleSlide = __webpack_require__(287), _TitleSlide2 = _interopRequireDefault(_TitleSlide);
        exports.Code = _Code2.default, exports.ContentSlide = _ContentSlide2.default, exports.DropDownNav = _DropDownNav2.default, 
        exports.IconButton = _IconButton2.default, exports.Presentation = _Presentation2.default, 
        exports.PresenterModePlugin = _PresenterModePlugin2.default, exports.PropTypes = _PropTypes2.default, 
        exports.Slide = _Slide2.default, exports.Step = _Step2.default, exports.TitleSlide = _TitleSlide2.default;
    }, /* 1 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _slicedToArray2 = __webpack_require__(42), _slicedToArray3 = _interopRequireDefault(_slicedToArray2), _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(101), _inherits3 = _interopRequireDefault(_inherits2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n.cm-s-reactpresents.CodeMirror {\n  height: auto;\n  border-radius: 0.5rem;\n  padding: 1rem;\n  background-color: #222 !important;\n  color: #f8f8f2 !important;\n  font-size: 12px;\n  border: none;\n}\n\n.cm-s-reactpresents.CodeMirror-focused div.CodeMirror-selected {\n  background: rgba(255, 255, 255, 0.10);\n}\n\n.cm-s-reactpresents {\n  .CodeMirror-sizer {\n    min-height: auto !important;\n  }\n\n  .CodeMirror-gutters {\n    background-color: #222 !important;\n    color: #f8f8f2 !important;\n    font-size: 12px;\n    border: none;\n  }\n  .CodeMirror-gutters { color: #222; }\n  .CodeMirror-cursor { border-left: solid thin #ddd; }\n  .CodeMirror-linenumber { cololibr: #75715e; }\n  .CodeMirror-line::selection,\n  .CodeMirror-line > span::selection,\n  .CodeMirror-line > span > span::selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  .CodeMirror-line::-moz-selection,\n  .CodeMirror-line > span::-moz-selection,\n  .CodeMirror-line > span > span::-moz-selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  span.cm-comment { color: #75715e; }\n  span.cm-string,\n  span.cm-string-2 { color: #f1fa8c; }\n  span.cm-number { color: #bd93f9; }\n  span.cm-variable { color: #ddd; }\n  span.cm-variable-2 { color: white; }\n  span.cm-def { color: #a6e22e; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-operator { color: #f92672; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-atom { color: #bd93f9; }\n  span.cm-meta { color: #f8f8f2; }\n  span.cm-tag { color: #f92672; }\n  span.cm-attribute { color: #ddd; }\n  span.cm-qualifier { color: #a6e22e; }\n  span.cm-property { color: #66d9ef; }\n  span.cm-builtin { color: #a6e22e; }\n  span.cm-variable-3 { color: #a6e22e; }\n\n  .CodeMirror-activeline-background { background: rgba(255,255,255,0.1); }\n  .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\n\n  span.cm-bracket { color: #900; }\n\n  span.dim {\n    opacity: 0.5;\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n  }\n\n  span.highlight {\n    background-color: rgba(189,147,249, .2);\n  }\n}\n" ], [ "\n.cm-s-reactpresents.CodeMirror {\n  height: auto;\n  border-radius: 0.5rem;\n  padding: 1rem;\n  background-color: #222 !important;\n  color: #f8f8f2 !important;\n  font-size: 12px;\n  border: none;\n}\n\n.cm-s-reactpresents.CodeMirror-focused div.CodeMirror-selected {\n  background: rgba(255, 255, 255, 0.10);\n}\n\n.cm-s-reactpresents {\n  .CodeMirror-sizer {\n    min-height: auto !important;\n  }\n\n  .CodeMirror-gutters {\n    background-color: #222 !important;\n    color: #f8f8f2 !important;\n    font-size: 12px;\n    border: none;\n  }\n  .CodeMirror-gutters { color: #222; }\n  .CodeMirror-cursor { border-left: solid thin #ddd; }\n  .CodeMirror-linenumber { cololibr: #75715e; }\n  .CodeMirror-line::selection,\n  .CodeMirror-line > span::selection,\n  .CodeMirror-line > span > span::selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  .CodeMirror-line::-moz-selection,\n  .CodeMirror-line > span::-moz-selection,\n  .CodeMirror-line > span > span::-moz-selection {\n    background: rgba(255, 255, 255, 0.10);\n  }\n  span.cm-comment { color: #75715e; }\n  span.cm-string,\n  span.cm-string-2 { color: #f1fa8c; }\n  span.cm-number { color: #bd93f9; }\n  span.cm-variable { color: #ddd; }\n  span.cm-variable-2 { color: white; }\n  span.cm-def { color: #a6e22e; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-operator { color: #f92672; }\n  span.cm-keyword { color: #f92672; }\n  span.cm-atom { color: #bd93f9; }\n  span.cm-meta { color: #f8f8f2; }\n  span.cm-tag { color: #f92672; }\n  span.cm-attribute { color: #ddd; }\n  span.cm-qualifier { color: #a6e22e; }\n  span.cm-property { color: #66d9ef; }\n  span.cm-builtin { color: #a6e22e; }\n  span.cm-variable-3 { color: #a6e22e; }\n\n  .CodeMirror-activeline-background { background: rgba(255,255,255,0.1); }\n  .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\n\n  span.cm-bracket { color: #900; }\n\n  span.dim {\n    opacity: 0.5;\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n  }\n\n  span.highlight {\n    background-color: rgba(189,147,249, .2);\n  }\n}\n" ]), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _reactCodemirror = __webpack_require__(110), _reactCodemirror2 = _interopRequireDefault(_reactCodemirror), _styledComponents = __webpack_require__(114), _styledComponents2 = _interopRequireDefault(_styledComponents);
        __webpack_require__(188);
        var DEFAULT_CODE_MIRROR_OPTIONS = {
            lineNumbers: !1,
            mode: "jsx",
            readOnly: !0,
            theme: "reactpresents"
        }, Code = function(_Component) {
            function Code() {
                return (0, _classCallCheck3.default)(this, Code), (0, _possibleConstructorReturn3.default)(this, (Code.__proto__ || (0, 
                _getPrototypeOf2.default)(Code)).apply(this, arguments));
            }
            return (0, _inherits3.default)(Code, _Component), (0, _createClass3.default)(Code, [ {
                key: "componentDidMount",
                value: function() {
                    var _props = this.props, dimLines = _props.dimLines, highlightLines = _props.highlightLines;
                    this._textMarks = [], this._addClassNameToLines(dimLines, "dim"), this._addClassNameToLines(highlightLines, "highlight");
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState) {
                    var _props2 = this.props, dimLines = _props2.dimLines, highlightLines = _props2.highlightLines;
                    dimLines === nextProps.dimLines && highlightLines === nextProps.highlightLines || (this._textMarks.forEach(function(textMark) {
                        textMark.clear();
                    }), this._textMarks = [], this._addClassNameToLines(nextProps.dimLines, "dim"), 
                    this._addClassNameToLines(nextProps.highlightLines, "highlight"));
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this, _props3 = this.props, codeMirrorOptions = _props3.codeMirrorOptions, value = _props3.value, className = _props3.className, options = (0, 
                    _extends3.default)({}, DEFAULT_CODE_MIRROR_OPTIONS, codeMirrorOptions);
                    return _react2.default.createElement(CodeMirrorTheme, {
                        className: className
                    }, _react2.default.createElement(_reactCodemirror2.default, {
                        options: options,
                        ref: function(_ref) {
                            _this2._codeMirror = _ref;
                        },
                        value: value
                    }));
                }
            }, {
                key: "_addClassNameToLines",
                value: function(lineNumbers, className) {
                    var _this3 = this;
                    lineNumbers.forEach(function(_ref2) {
                        var _ref3 = (0, _slicedToArray3.default)(_ref2, 2), start = _ref3[0], stop = _ref3[1];
                        _this3._textMarks.push(_this3._codeMirror.codeMirror.doc.markText({
                            line: start,
                            ch: 0
                        }, {
                            line: stop + 1,
                            ch: 0
                        }, {
                            className: className
                        }));
                    });
                }
            } ]), Code;
        }(_react.Component);
        Code.defaultProps = {
            codeMirrorOptions: {},
            dimLines: [],
            highlightLines: []
        }, exports.default = Code;
        var CodeMirrorTheme = _styledComponents2.default.div(_templateObject);
    }, /* 2 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _defineProperties = __webpack_require__(3), _defineProperties2 = _interopRequireDefault(_defineProperties), _freeze = __webpack_require__(37), _freeze2 = _interopRequireDefault(_freeze);
        exports.default = function(strings, raw) {
            return (0, _freeze2.default)((0, _defineProperties2.default)(strings, {
                raw: {
                    value: (0, _freeze2.default)(raw)
                }
            }));
        };
    }, /* 3 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(4),
            __esModule: !0
        };
    }, /* 4 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(5);
        var $Object = __webpack_require__(8).Object;
        module.exports = function(T, D) {
            return $Object.defineProperties(T, D);
        };
    }, /* 5 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(6);
        // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
        $export($export.S + $export.F * !__webpack_require__(16), "Object", {
            defineProperties: __webpack_require__(21)
        });
    }, /* 6 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(7), core = __webpack_require__(8), ctx = __webpack_require__(9), hide = __webpack_require__(11), PROTOTYPE = "prototype", $export = function(type, name, source) {
            var key, own, out, IS_FORCED = type & $export.F, IS_GLOBAL = type & $export.G, IS_STATIC = type & $export.S, IS_PROTO = type & $export.P, IS_BIND = type & $export.B, IS_WRAP = type & $export.W, exports = IS_GLOBAL ? core : core[name] || (core[name] = {}), expProto = exports[PROTOTYPE], target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
            IS_GLOBAL && (source = name);
            for (key in source) // contains in native
            own = !IS_FORCED && target && void 0 !== target[key], own && key in exports || (// export native or passed
            out = own ? target[key] : source[key], // prevent global pollution for namespaces
            exports[key] = IS_GLOBAL && "function" != typeof target[key] ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(C) {
                var F = function(a, b, c) {
                    if (this instanceof C) {
                        switch (arguments.length) {
                          case 0:
                            return new C();

                          case 1:
                            return new C(a);

                          case 2:
                            return new C(a, b);
                        }
                        return new C(a, b, c);
                    }
                    return C.apply(this, arguments);
                };
                return F[PROTOTYPE] = C[PROTOTYPE], F;
            }(out) : IS_PROTO && "function" == typeof out ? ctx(Function.call, out) : out, // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
            IS_PROTO && ((exports.virtual || (exports.virtual = {}))[key] = out, // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
            type & $export.R && expProto && !expProto[key] && hide(expProto, key, out)));
        };
        // type bitmap
        $export.F = 1, // forced
        $export.G = 2, // global
        $export.S = 4, // static
        $export.P = 8, // proto
        $export.B = 16, // bind
        $export.W = 32, // wrap
        $export.U = 64, // safe
        $export.R = 128, // real proto method for `library` 
        module.exports = $export;
    }, /* 7 */
    /***/
    function(module, exports) {
        // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = global);
    }, /* 8 */
    /***/
    function(module, exports) {
        var core = module.exports = {
            version: "2.4.0"
        };
        "number" == typeof __e && (__e = core);
    }, /* 9 */
    /***/
    function(module, exports, __webpack_require__) {
        // optional / simple context binding
        var aFunction = __webpack_require__(10);
        module.exports = function(fn, that, length) {
            if (aFunction(fn), void 0 === that) return fn;
            switch (length) {
              case 1:
                return function(a) {
                    return fn.call(that, a);
                };

              case 2:
                return function(a, b) {
                    return fn.call(that, a, b);
                };

              case 3:
                return function(a, b, c) {
                    return fn.call(that, a, b, c);
                };
            }
            return function() {
                return fn.apply(that, arguments);
            };
        };
    }, /* 10 */
    /***/
    function(module, exports) {
        module.exports = function(it) {
            if ("function" != typeof it) throw TypeError(it + " is not a function!");
            return it;
        };
    }, /* 11 */
    /***/
    function(module, exports, __webpack_require__) {
        var dP = __webpack_require__(12), createDesc = __webpack_require__(20);
        module.exports = __webpack_require__(16) ? function(object, key, value) {
            return dP.f(object, key, createDesc(1, value));
        } : function(object, key, value) {
            return object[key] = value, object;
        };
    }, /* 12 */
    /***/
    function(module, exports, __webpack_require__) {
        var anObject = __webpack_require__(13), IE8_DOM_DEFINE = __webpack_require__(15), toPrimitive = __webpack_require__(19), dP = Object.defineProperty;
        exports.f = __webpack_require__(16) ? Object.defineProperty : function(O, P, Attributes) {
            if (anObject(O), P = toPrimitive(P, !0), anObject(Attributes), IE8_DOM_DEFINE) try {
                return dP(O, P, Attributes);
            } catch (e) {}
            if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
            return "value" in Attributes && (O[P] = Attributes.value), O;
        };
    }, /* 13 */
    /***/
    function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(14);
        module.exports = function(it) {
            if (!isObject(it)) throw TypeError(it + " is not an object!");
            return it;
        };
    }, /* 14 */
    /***/
    function(module, exports) {
        module.exports = function(it) {
            return "object" == typeof it ? null !== it : "function" == typeof it;
        };
    }, /* 15 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = !__webpack_require__(16) && !__webpack_require__(17)(function() {
            return 7 != Object.defineProperty(__webpack_require__(18)("div"), "a", {
                get: function() {
                    return 7;
                }
            }).a;
        });
    }, /* 16 */
    /***/
    function(module, exports, __webpack_require__) {
        // Thank's IE8 for his funny defineProperty
        module.exports = !__webpack_require__(17)(function() {
            return 7 != Object.defineProperty({}, "a", {
                get: function() {
                    return 7;
                }
            }).a;
        });
    }, /* 17 */
    /***/
    function(module, exports) {
        module.exports = function(exec) {
            try {
                return !!exec();
            } catch (e) {
                return !0;
            }
        };
    }, /* 18 */
    /***/
    function(module, exports, __webpack_require__) {
        var isObject = __webpack_require__(14), document = __webpack_require__(7).document, is = isObject(document) && isObject(document.createElement);
        module.exports = function(it) {
            return is ? document.createElement(it) : {};
        };
    }, /* 19 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = __webpack_require__(14);
        // instead of the ES6 spec version, we didn't implement @@toPrimitive case
        // and the second argument - flag - preferred type is a string
        module.exports = function(it, S) {
            if (!isObject(it)) return it;
            var fn, val;
            if (S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it))) return val;
            if ("function" == typeof (fn = it.valueOf) && !isObject(val = fn.call(it))) return val;
            if (!S && "function" == typeof (fn = it.toString) && !isObject(val = fn.call(it))) return val;
            throw TypeError("Can't convert object to primitive value");
        };
    }, /* 20 */
    /***/
    function(module, exports) {
        module.exports = function(bitmap, value) {
            return {
                enumerable: !(1 & bitmap),
                configurable: !(2 & bitmap),
                writable: !(4 & bitmap),
                value: value
            };
        };
    }, /* 21 */
    /***/
    function(module, exports, __webpack_require__) {
        var dP = __webpack_require__(12), anObject = __webpack_require__(13), getKeys = __webpack_require__(22);
        module.exports = __webpack_require__(16) ? Object.defineProperties : function(O, Properties) {
            anObject(O);
            for (var P, keys = getKeys(Properties), length = keys.length, i = 0; length > i; ) dP.f(O, P = keys[i++], Properties[P]);
            return O;
        };
    }, /* 22 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys = __webpack_require__(23), enumBugKeys = __webpack_require__(36);
        module.exports = Object.keys || function(O) {
            return $keys(O, enumBugKeys);
        };
    }, /* 23 */
    /***/
    function(module, exports, __webpack_require__) {
        var has = __webpack_require__(24), toIObject = __webpack_require__(25), arrayIndexOf = __webpack_require__(29)(!1), IE_PROTO = __webpack_require__(33)("IE_PROTO");
        module.exports = function(object, names) {
            var key, O = toIObject(object), i = 0, result = [];
            for (key in O) key != IE_PROTO && has(O, key) && result.push(key);
            // Don't enum bug & hidden keys
            for (;names.length > i; ) has(O, key = names[i++]) && (~arrayIndexOf(result, key) || result.push(key));
            return result;
        };
    }, /* 24 */
    /***/
    function(module, exports) {
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function(it, key) {
            return hasOwnProperty.call(it, key);
        };
    }, /* 25 */
    /***/
    function(module, exports, __webpack_require__) {
        // to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = __webpack_require__(26), defined = __webpack_require__(28);
        module.exports = function(it) {
            return IObject(defined(it));
        };
    }, /* 26 */
    /***/
    function(module, exports, __webpack_require__) {
        // fallback for non-array-like ES3 and non-enumerable old V8 strings
        var cof = __webpack_require__(27);
        module.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
            return "String" == cof(it) ? it.split("") : Object(it);
        };
    }, /* 27 */
    /***/
    function(module, exports) {
        var toString = {}.toString;
        module.exports = function(it) {
            return toString.call(it).slice(8, -1);
        };
    }, /* 28 */
    /***/
    function(module, exports) {
        // 7.2.1 RequireObjectCoercible(argument)
        module.exports = function(it) {
            if (void 0 == it) throw TypeError("Can't call method on  " + it);
            return it;
        };
    }, /* 29 */
    /***/
    function(module, exports, __webpack_require__) {
        // false -> Array#indexOf
        // true  -> Array#includes
        var toIObject = __webpack_require__(25), toLength = __webpack_require__(30), toIndex = __webpack_require__(32);
        module.exports = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
                var value, O = toIObject($this), length = toLength(O.length), index = toIndex(fromIndex, length);
                // Array#includes uses SameValueZero equality algorithm
                if (IS_INCLUDES && el != el) {
                    for (;length > index; ) if (value = O[index++], value != value) return !0;
                } else for (;length > index; index++) if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
                return !IS_INCLUDES && -1;
            };
        };
    }, /* 30 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.15 ToLength
        var toInteger = __webpack_require__(31), min = Math.min;
        module.exports = function(it) {
            return it > 0 ? min(toInteger(it), 9007199254740991) : 0;
        };
    }, /* 31 */
    /***/
    function(module, exports) {
        // 7.1.4 ToInteger
        var ceil = Math.ceil, floor = Math.floor;
        module.exports = function(it) {
            return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };
    }, /* 32 */
    /***/
    function(module, exports, __webpack_require__) {
        var toInteger = __webpack_require__(31), max = Math.max, min = Math.min;
        module.exports = function(index, length) {
            return index = toInteger(index), index < 0 ? max(index + length, 0) : min(index, length);
        };
    }, /* 33 */
    /***/
    function(module, exports, __webpack_require__) {
        var shared = __webpack_require__(34)("keys"), uid = __webpack_require__(35);
        module.exports = function(key) {
            return shared[key] || (shared[key] = uid(key));
        };
    }, /* 34 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(7), SHARED = "__core-js_shared__", store = global[SHARED] || (global[SHARED] = {});
        module.exports = function(key) {
            return store[key] || (store[key] = {});
        };
    }, /* 35 */
    /***/
    function(module, exports) {
        var id = 0, px = Math.random();
        module.exports = function(key) {
            return "Symbol(".concat(void 0 === key ? "" : key, ")_", (++id + px).toString(36));
        };
    }, /* 36 */
    /***/
    function(module, exports) {
        // IE 8- don't enum bug keys
        module.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    }, /* 37 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(38),
            __esModule: !0
        };
    }, /* 38 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(39), module.exports = __webpack_require__(8).Object.freeze;
    }, /* 39 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.5 Object.freeze(O)
        var isObject = __webpack_require__(14), meta = __webpack_require__(40).onFreeze;
        __webpack_require__(41)("freeze", function($freeze) {
            return function(it) {
                return $freeze && isObject(it) ? $freeze(meta(it)) : it;
            };
        });
    }, /* 40 */
    /***/
    function(module, exports, __webpack_require__) {
        var META = __webpack_require__(35)("meta"), isObject = __webpack_require__(14), has = __webpack_require__(24), setDesc = __webpack_require__(12).f, id = 0, isExtensible = Object.isExtensible || function() {
            return !0;
        }, FREEZE = !__webpack_require__(17)(function() {
            return isExtensible(Object.preventExtensions({}));
        }), setMeta = function(it) {
            setDesc(it, META, {
                value: {
                    i: "O" + ++id,
                    // object ID
                    w: {}
                }
            });
        }, fastKey = function(it, create) {
            // return primitive with prefix
            if (!isObject(it)) return "symbol" == typeof it ? it : ("string" == typeof it ? "S" : "P") + it;
            if (!has(it, META)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return "F";
                // not necessary to add metadata
                if (!create) return "E";
                // add missing metadata
                setMeta(it);
            }
            return it[META].i;
        }, getWeak = function(it, create) {
            if (!has(it, META)) {
                // can't set metadata to uncaught frozen object
                if (!isExtensible(it)) return !0;
                // not necessary to add metadata
                if (!create) return !1;
                // add missing metadata
                setMeta(it);
            }
            return it[META].w;
        }, onFreeze = function(it) {
            return FREEZE && meta.NEED && isExtensible(it) && !has(it, META) && setMeta(it), 
            it;
        }, meta = module.exports = {
            KEY: META,
            NEED: !1,
            fastKey: fastKey,
            getWeak: getWeak,
            onFreeze: onFreeze
        };
    }, /* 41 */
    /***/
    function(module, exports, __webpack_require__) {
        // most Object methods by ES6 should accept primitives
        var $export = __webpack_require__(6), core = __webpack_require__(8), fails = __webpack_require__(17);
        module.exports = function(KEY, exec) {
            var fn = (core.Object || {})[KEY] || Object[KEY], exp = {};
            exp[KEY] = exec(fn), $export($export.S + $export.F * fails(function() {
                fn(1);
            }), "Object", exp);
        };
    }, /* 42 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _isIterable2 = __webpack_require__(43), _isIterable3 = _interopRequireDefault(_isIterable2), _getIterator2 = __webpack_require__(64), _getIterator3 = _interopRequireDefault(_getIterator2);
        exports.default = function() {
            function sliceIterator(arr, i) {
                var _arr = [], _n = !0, _d = !1, _e = void 0;
                try {
                    for (var _s, _i = (0, _getIterator3.default)(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
                    !i || _arr.length !== i); _n = !0) ;
                } catch (err) {
                    _d = !0, _e = err;
                } finally {
                    try {
                        !_n && _i.return && _i.return();
                    } finally {
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
            return function(arr, i) {
                if (Array.isArray(arr)) return arr;
                if ((0, _isIterable3.default)(Object(arr))) return sliceIterator(arr, i);
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            };
        }();
    }, /* 43 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(44),
            __esModule: !0
        };
    }, /* 44 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(45), __webpack_require__(60), module.exports = __webpack_require__(62);
    }, /* 45 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(46);
        for (var global = __webpack_require__(7), hide = __webpack_require__(11), Iterators = __webpack_require__(49), TO_STRING_TAG = __webpack_require__(57)("toStringTag"), collections = [ "NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList" ], i = 0; i < 5; i++) {
            var NAME = collections[i], Collection = global[NAME], proto = Collection && Collection.prototype;
            proto && !proto[TO_STRING_TAG] && hide(proto, TO_STRING_TAG, NAME), Iterators[NAME] = Iterators.Array;
        }
    }, /* 46 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var addToUnscopables = __webpack_require__(47), step = __webpack_require__(48), Iterators = __webpack_require__(49), toIObject = __webpack_require__(25);
        // 22.1.3.4 Array.prototype.entries()
        // 22.1.3.13 Array.prototype.keys()
        // 22.1.3.29 Array.prototype.values()
        // 22.1.3.30 Array.prototype[@@iterator]()
        module.exports = __webpack_require__(50)(Array, "Array", function(iterated, kind) {
            this._t = toIObject(iterated), // target
            this._i = 0, // next index
            this._k = kind;
        }, function() {
            var O = this._t, kind = this._k, index = this._i++;
            return !O || index >= O.length ? (this._t = void 0, step(1)) : "keys" == kind ? step(0, index) : "values" == kind ? step(0, O[index]) : step(0, [ index, O[index] ]);
        }, "values"), // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
        Iterators.Arguments = Iterators.Array, addToUnscopables("keys"), addToUnscopables("values"), 
        addToUnscopables("entries");
    }, /* 47 */
    /***/
    function(module, exports) {
        module.exports = function() {};
    }, /* 48 */
    /***/
    function(module, exports) {
        module.exports = function(done, value) {
            return {
                value: value,
                done: !!done
            };
        };
    }, /* 49 */
    /***/
    function(module, exports) {
        module.exports = {};
    }, /* 50 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var LIBRARY = __webpack_require__(51), $export = __webpack_require__(6), redefine = __webpack_require__(52), hide = __webpack_require__(11), has = __webpack_require__(24), Iterators = __webpack_require__(49), $iterCreate = __webpack_require__(53), setToStringTag = __webpack_require__(56), getPrototypeOf = __webpack_require__(58), ITERATOR = __webpack_require__(57)("iterator"), BUGGY = !([].keys && "next" in [].keys()), FF_ITERATOR = "@@iterator", KEYS = "keys", VALUES = "values", returnThis = function() {
            return this;
        };
        module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
            $iterCreate(Constructor, NAME, next);
            var methods, key, IteratorPrototype, getMethod = function(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                  case KEYS:
                    return function() {
                        return new Constructor(this, kind);
                    };

                  case VALUES:
                    return function() {
                        return new Constructor(this, kind);
                    };
                }
                return function() {
                    return new Constructor(this, kind);
                };
            }, TAG = NAME + " Iterator", DEF_VALUES = DEFAULT == VALUES, VALUES_BUG = !1, proto = Base.prototype, $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT], $default = $native || getMethod(DEFAULT), $entries = DEFAULT ? DEF_VALUES ? getMethod("entries") : $default : void 0, $anyNative = "Array" == NAME ? proto.entries || $native : $native;
            if (// Fix native
            $anyNative && (IteratorPrototype = getPrototypeOf($anyNative.call(new Base())), 
            IteratorPrototype !== Object.prototype && (// Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, !0), // fix for some old engines
            LIBRARY || has(IteratorPrototype, ITERATOR) || hide(IteratorPrototype, ITERATOR, returnThis))), 
            // fix Array#{values, @@iterator}.name in V8 / FF
            DEF_VALUES && $native && $native.name !== VALUES && (VALUES_BUG = !0, $default = function() {
                return $native.call(this);
            }), // Define iterator
            LIBRARY && !FORCED || !BUGGY && !VALUES_BUG && proto[ITERATOR] || hide(proto, ITERATOR, $default), 
            // Plug for library
            Iterators[NAME] = $default, Iterators[TAG] = returnThis, DEFAULT) if (methods = {
                values: DEF_VALUES ? $default : getMethod(VALUES),
                keys: IS_SET ? $default : getMethod(KEYS),
                entries: $entries
            }, FORCED) for (key in methods) key in proto || redefine(proto, key, methods[key]); else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
            return methods;
        };
    }, /* 51 */
    /***/
    function(module, exports) {
        module.exports = !0;
    }, /* 52 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(11);
    }, /* 53 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var create = __webpack_require__(54), descriptor = __webpack_require__(20), setToStringTag = __webpack_require__(56), IteratorPrototype = {};
        // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
        __webpack_require__(11)(IteratorPrototype, __webpack_require__(57)("iterator"), function() {
            return this;
        }), module.exports = function(Constructor, NAME, next) {
            Constructor.prototype = create(IteratorPrototype, {
                next: descriptor(1, next)
            }), setToStringTag(Constructor, NAME + " Iterator");
        };
    }, /* 54 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject = __webpack_require__(13), dPs = __webpack_require__(21), enumBugKeys = __webpack_require__(36), IE_PROTO = __webpack_require__(33)("IE_PROTO"), Empty = function() {}, PROTOTYPE = "prototype", createDict = function() {
            // Thrash, waste and sodomy: IE GC bug
            var iframeDocument, iframe = __webpack_require__(18)("iframe"), i = enumBugKeys.length, lt = "<", gt = ">";
            for (iframe.style.display = "none", __webpack_require__(55).appendChild(iframe), 
            iframe.src = "javascript:", // eslint-disable-line no-script-url
            // createDict = iframe.contentWindow.Object;
            // html.removeChild(iframe);
            iframeDocument = iframe.contentWindow.document, iframeDocument.open(), iframeDocument.write(lt + "script" + gt + "document.F=Object" + lt + "/script" + gt), 
            iframeDocument.close(), createDict = iframeDocument.F; i--; ) delete createDict[PROTOTYPE][enumBugKeys[i]];
            return createDict();
        };
        module.exports = Object.create || function(O, Properties) {
            var result;
            // add "__proto__" for Object.getPrototypeOf polyfill
            return null !== O ? (Empty[PROTOTYPE] = anObject(O), result = new Empty(), Empty[PROTOTYPE] = null, 
            result[IE_PROTO] = O) : result = createDict(), void 0 === Properties ? result : dPs(result, Properties);
        };
    }, /* 55 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(7).document && document.documentElement;
    }, /* 56 */
    /***/
    function(module, exports, __webpack_require__) {
        var def = __webpack_require__(12).f, has = __webpack_require__(24), TAG = __webpack_require__(57)("toStringTag");
        module.exports = function(it, tag, stat) {
            it && !has(it = stat ? it : it.prototype, TAG) && def(it, TAG, {
                configurable: !0,
                value: tag
            });
        };
    }, /* 57 */
    /***/
    function(module, exports, __webpack_require__) {
        var store = __webpack_require__(34)("wks"), uid = __webpack_require__(35), Symbol = __webpack_require__(7).Symbol, USE_SYMBOL = "function" == typeof Symbol, $exports = module.exports = function(name) {
            return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)("Symbol." + name));
        };
        $exports.store = store;
    }, /* 58 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has = __webpack_require__(24), toObject = __webpack_require__(59), IE_PROTO = __webpack_require__(33)("IE_PROTO"), ObjectProto = Object.prototype;
        module.exports = Object.getPrototypeOf || function(O) {
            return O = toObject(O), has(O, IE_PROTO) ? O[IE_PROTO] : "function" == typeof O.constructor && O instanceof O.constructor ? O.constructor.prototype : O instanceof Object ? ObjectProto : null;
        };
    }, /* 59 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.1.13 ToObject(argument)
        var defined = __webpack_require__(28);
        module.exports = function(it) {
            return Object(defined(it));
        };
    }, /* 60 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var $at = __webpack_require__(61)(!0);
        // 21.1.3.27 String.prototype[@@iterator]()
        __webpack_require__(50)(String, "String", function(iterated) {
            this._t = String(iterated), // target
            this._i = 0;
        }, function() {
            var point, O = this._t, index = this._i;
            return index >= O.length ? {
                value: void 0,
                done: !0
            } : (point = $at(O, index), this._i += point.length, {
                value: point,
                done: !1
            });
        });
    }, /* 61 */
    /***/
    function(module, exports, __webpack_require__) {
        var toInteger = __webpack_require__(31), defined = __webpack_require__(28);
        // true  -> String#at
        // false -> String#codePointAt
        module.exports = function(TO_STRING) {
            return function(that, pos) {
                var a, b, s = String(defined(that)), i = toInteger(pos), l = s.length;
                return i < 0 || i >= l ? TO_STRING ? "" : void 0 : (a = s.charCodeAt(i), a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536);
            };
        };
    }, /* 62 */
    /***/
    function(module, exports, __webpack_require__) {
        var classof = __webpack_require__(63), ITERATOR = __webpack_require__(57)("iterator"), Iterators = __webpack_require__(49);
        module.exports = __webpack_require__(8).isIterable = function(it) {
            var O = Object(it);
            return void 0 !== O[ITERATOR] || "@@iterator" in O || Iterators.hasOwnProperty(classof(O));
        };
    }, /* 63 */
    /***/
    function(module, exports, __webpack_require__) {
        // getting tag from 19.1.3.6 Object.prototype.toString()
        var cof = __webpack_require__(27), TAG = __webpack_require__(57)("toStringTag"), ARG = "Arguments" == cof(function() {
            return arguments;
        }()), tryGet = function(it, key) {
            try {
                return it[key];
            } catch (e) {}
        };
        module.exports = function(it) {
            var O, T, B;
            return void 0 === it ? "Undefined" : null === it ? "Null" : "string" == typeof (T = tryGet(O = Object(it), TAG)) ? T : ARG ? cof(O) : "Object" == (B = cof(O)) && "function" == typeof O.callee ? "Arguments" : B;
        };
    }, /* 64 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(65),
            __esModule: !0
        };
    }, /* 65 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(45), __webpack_require__(60), module.exports = __webpack_require__(66);
    }, /* 66 */
    /***/
    function(module, exports, __webpack_require__) {
        var anObject = __webpack_require__(13), get = __webpack_require__(67);
        module.exports = __webpack_require__(8).getIterator = function(it) {
            var iterFn = get(it);
            if ("function" != typeof iterFn) throw TypeError(it + " is not iterable!");
            return anObject(iterFn.call(it));
        };
    }, /* 67 */
    /***/
    function(module, exports, __webpack_require__) {
        var classof = __webpack_require__(63), ITERATOR = __webpack_require__(57)("iterator"), Iterators = __webpack_require__(49);
        module.exports = __webpack_require__(8).getIteratorMethod = function(it) {
            if (void 0 != it) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
        };
    }, /* 68 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _assign = __webpack_require__(69), _assign2 = _interopRequireDefault(_assign);
        exports.default = _assign2.default || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        };
    }, /* 69 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(70),
            __esModule: !0
        };
    }, /* 70 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(71), module.exports = __webpack_require__(8).Object.assign;
    }, /* 71 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.3.1 Object.assign(target, source)
        var $export = __webpack_require__(6);
        $export($export.S + $export.F, "Object", {
            assign: __webpack_require__(72)
        });
    }, /* 72 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // 19.1.2.1 Object.assign(target, source, ...)
        var getKeys = __webpack_require__(22), gOPS = __webpack_require__(73), pIE = __webpack_require__(74), toObject = __webpack_require__(59), IObject = __webpack_require__(26), $assign = Object.assign;
        // should work with symbols and should have deterministic property order (V8 bug)
        module.exports = !$assign || __webpack_require__(17)(function() {
            var A = {}, B = {}, S = Symbol(), K = "abcdefghijklmnopqrst";
            return A[S] = 7, K.split("").forEach(function(k) {
                B[k] = k;
            }), 7 != $assign({}, A)[S] || Object.keys($assign({}, B)).join("") != K;
        }) ? function(target, source) {
            for (// eslint-disable-line no-unused-vars
            var T = toObject(target), aLen = arguments.length, index = 1, getSymbols = gOPS.f, isEnum = pIE.f; aLen > index; ) for (var key, S = IObject(arguments[index++]), keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S), length = keys.length, j = 0; length > j; ) isEnum.call(S, key = keys[j++]) && (T[key] = S[key]);
            return T;
        } : $assign;
    }, /* 73 */
    /***/
    function(module, exports) {
        exports.f = Object.getOwnPropertySymbols;
    }, /* 74 */
    /***/
    function(module, exports) {
        exports.f = {}.propertyIsEnumerable;
    }, /* 75 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(76),
            __esModule: !0
        };
    }, /* 76 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(77), module.exports = __webpack_require__(8).Object.getPrototypeOf;
    }, /* 77 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.9 Object.getPrototypeOf(O)
        var toObject = __webpack_require__(59), $getPrototypeOf = __webpack_require__(58);
        __webpack_require__(41)("getPrototypeOf", function() {
            return function(it) {
                return $getPrototypeOf(toObject(it));
            };
        });
    }, /* 78 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0, exports.default = function(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        };
    }, /* 79 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _defineProperty = __webpack_require__(80), _defineProperty2 = _interopRequireDefault(_defineProperty);
        exports.default = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), (0, _defineProperty2.default)(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
    }, /* 80 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(81),
            __esModule: !0
        };
    }, /* 81 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(82);
        var $Object = __webpack_require__(8).Object;
        module.exports = function(it, key, desc) {
            return $Object.defineProperty(it, key, desc);
        };
    }, /* 82 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(6);
        // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
        $export($export.S + $export.F * !__webpack_require__(16), "Object", {
            defineProperty: __webpack_require__(12).f
        });
    }, /* 83 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _typeof2 = __webpack_require__(84), _typeof3 = _interopRequireDefault(_typeof2);
        exports.default = function(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" !== ("undefined" == typeof call ? "undefined" : (0, _typeof3.default)(call)) && "function" != typeof call ? self : call;
        };
    }, /* 84 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _iterator = __webpack_require__(85), _iterator2 = _interopRequireDefault(_iterator), _symbol = __webpack_require__(88), _symbol2 = _interopRequireDefault(_symbol), _typeof = "function" == typeof _symbol2.default && "symbol" == typeof _iterator2.default ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj;
        };
        exports.default = "function" == typeof _symbol2.default && "symbol" === _typeof(_iterator2.default) ? function(obj) {
            return "undefined" == typeof obj ? "undefined" : _typeof(obj);
        } : function(obj) {
            return obj && "function" == typeof _symbol2.default && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : "undefined" == typeof obj ? "undefined" : _typeof(obj);
        };
    }, /* 85 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(86),
            __esModule: !0
        };
    }, /* 86 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(60), __webpack_require__(45), module.exports = __webpack_require__(87).f("iterator");
    }, /* 87 */
    /***/
    function(module, exports, __webpack_require__) {
        exports.f = __webpack_require__(57);
    }, /* 88 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(89),
            __esModule: !0
        };
    }, /* 89 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(90), __webpack_require__(98), __webpack_require__(99), __webpack_require__(100), 
        module.exports = __webpack_require__(8).Symbol;
    }, /* 90 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        // ECMAScript 6 symbols shim
        var global = __webpack_require__(7), has = __webpack_require__(24), DESCRIPTORS = __webpack_require__(16), $export = __webpack_require__(6), redefine = __webpack_require__(52), META = __webpack_require__(40).KEY, $fails = __webpack_require__(17), shared = __webpack_require__(34), setToStringTag = __webpack_require__(56), uid = __webpack_require__(35), wks = __webpack_require__(57), wksExt = __webpack_require__(87), wksDefine = __webpack_require__(91), keyOf = __webpack_require__(92), enumKeys = __webpack_require__(93), isArray = __webpack_require__(94), anObject = __webpack_require__(13), toIObject = __webpack_require__(25), toPrimitive = __webpack_require__(19), createDesc = __webpack_require__(20), _create = __webpack_require__(54), gOPNExt = __webpack_require__(95), $GOPD = __webpack_require__(97), $DP = __webpack_require__(12), $keys = __webpack_require__(22), gOPD = $GOPD.f, dP = $DP.f, gOPN = gOPNExt.f, $Symbol = global.Symbol, $JSON = global.JSON, _stringify = $JSON && $JSON.stringify, PROTOTYPE = "prototype", HIDDEN = wks("_hidden"), TO_PRIMITIVE = wks("toPrimitive"), isEnum = {}.propertyIsEnumerable, SymbolRegistry = shared("symbol-registry"), AllSymbols = shared("symbols"), OPSymbols = shared("op-symbols"), ObjectProto = Object[PROTOTYPE], USE_NATIVE = "function" == typeof $Symbol, QObject = global.QObject, setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild, setSymbolDesc = DESCRIPTORS && $fails(function() {
            return 7 != _create(dP({}, "a", {
                get: function() {
                    return dP(this, "a", {
                        value: 7
                    }).a;
                }
            })).a;
        }) ? function(it, key, D) {
            var protoDesc = gOPD(ObjectProto, key);
            protoDesc && delete ObjectProto[key], dP(it, key, D), protoDesc && it !== ObjectProto && dP(ObjectProto, key, protoDesc);
        } : dP, wrap = function(tag) {
            var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
            return sym._k = tag, sym;
        }, isSymbol = USE_NATIVE && "symbol" == typeof $Symbol.iterator ? function(it) {
            return "symbol" == typeof it;
        } : function(it) {
            return it instanceof $Symbol;
        }, $defineProperty = function(it, key, D) {
            return it === ObjectProto && $defineProperty(OPSymbols, key, D), anObject(it), key = toPrimitive(key, !0), 
            anObject(D), has(AllSymbols, key) ? (D.enumerable ? (has(it, HIDDEN) && it[HIDDEN][key] && (it[HIDDEN][key] = !1), 
            D = _create(D, {
                enumerable: createDesc(0, !1)
            })) : (has(it, HIDDEN) || dP(it, HIDDEN, createDesc(1, {})), it[HIDDEN][key] = !0), 
            setSymbolDesc(it, key, D)) : dP(it, key, D);
        }, $defineProperties = function(it, P) {
            anObject(it);
            for (var key, keys = enumKeys(P = toIObject(P)), i = 0, l = keys.length; l > i; ) $defineProperty(it, key = keys[i++], P[key]);
            return it;
        }, $create = function(it, P) {
            return void 0 === P ? _create(it) : $defineProperties(_create(it), P);
        }, $propertyIsEnumerable = function(key) {
            var E = isEnum.call(this, key = toPrimitive(key, !0));
            return !(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) && (!(E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]) || E);
        }, $getOwnPropertyDescriptor = function(it, key) {
            if (it = toIObject(it), key = toPrimitive(key, !0), it !== ObjectProto || !has(AllSymbols, key) || has(OPSymbols, key)) {
                var D = gOPD(it, key);
                return !D || !has(AllSymbols, key) || has(it, HIDDEN) && it[HIDDEN][key] || (D.enumerable = !0), 
                D;
            }
        }, $getOwnPropertyNames = function(it) {
            for (var key, names = gOPN(toIObject(it)), result = [], i = 0; names.length > i; ) has(AllSymbols, key = names[i++]) || key == HIDDEN || key == META || result.push(key);
            return result;
        }, $getOwnPropertySymbols = function(it) {
            for (var key, IS_OP = it === ObjectProto, names = gOPN(IS_OP ? OPSymbols : toIObject(it)), result = [], i = 0; names.length > i; ) !has(AllSymbols, key = names[i++]) || IS_OP && !has(ObjectProto, key) || result.push(AllSymbols[key]);
            return result;
        };
        // 19.4.1.1 Symbol([description])
        USE_NATIVE || ($Symbol = function() {
            if (this instanceof $Symbol) throw TypeError("Symbol is not a constructor!");
            var tag = uid(arguments.length > 0 ? arguments[0] : void 0), $set = function(value) {
                this === ObjectProto && $set.call(OPSymbols, value), has(this, HIDDEN) && has(this[HIDDEN], tag) && (this[HIDDEN][tag] = !1), 
                setSymbolDesc(this, tag, createDesc(1, value));
            };
            return DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
                configurable: !0,
                set: $set
            }), wrap(tag);
        }, redefine($Symbol[PROTOTYPE], "toString", function() {
            return this._k;
        }), $GOPD.f = $getOwnPropertyDescriptor, $DP.f = $defineProperty, __webpack_require__(96).f = gOPNExt.f = $getOwnPropertyNames, 
        __webpack_require__(74).f = $propertyIsEnumerable, __webpack_require__(73).f = $getOwnPropertySymbols, 
        DESCRIPTORS && !__webpack_require__(51) && redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, !0), 
        wksExt.f = function(name) {
            return wrap(wks(name));
        }), $export($export.G + $export.W + $export.F * !USE_NATIVE, {
            Symbol: $Symbol
        });
        for (var symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), i = 0; symbols.length > i; ) wks(symbols[i++]);
        for (var symbols = $keys(wks.store), i = 0; symbols.length > i; ) wksDefine(symbols[i++]);
        $export($export.S + $export.F * !USE_NATIVE, "Symbol", {
            // 19.4.2.1 Symbol.for(key)
            for: function(key) {
                return has(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
            },
            // 19.4.2.5 Symbol.keyFor(sym)
            keyFor: function(key) {
                if (isSymbol(key)) return keyOf(SymbolRegistry, key);
                throw TypeError(key + " is not a symbol!");
            },
            useSetter: function() {
                setter = !0;
            },
            useSimple: function() {
                setter = !1;
            }
        }), $export($export.S + $export.F * !USE_NATIVE, "Object", {
            // 19.1.2.2 Object.create(O [, Properties])
            create: $create,
            // 19.1.2.4 Object.defineProperty(O, P, Attributes)
            defineProperty: $defineProperty,
            // 19.1.2.3 Object.defineProperties(O, Properties)
            defineProperties: $defineProperties,
            // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
            // 19.1.2.7 Object.getOwnPropertyNames(O)
            getOwnPropertyNames: $getOwnPropertyNames,
            // 19.1.2.8 Object.getOwnPropertySymbols(O)
            getOwnPropertySymbols: $getOwnPropertySymbols
        }), // 24.3.2 JSON.stringify(value [, replacer [, space]])
        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {
            var S = $Symbol();
            // MS Edge converts symbol values to JSON as {}
            // WebKit converts symbol values to JSON as null
            // V8 throws on boxed symbols
            return "[null]" != _stringify([ S ]) || "{}" != _stringify({
                a: S
            }) || "{}" != _stringify(Object(S));
        })), "JSON", {
            stringify: function(it) {
                if (void 0 !== it && !isSymbol(it)) {
                    for (// IE8 returns string on undefined
                    var replacer, $replacer, args = [ it ], i = 1; arguments.length > i; ) args.push(arguments[i++]);
                    return replacer = args[1], "function" == typeof replacer && ($replacer = replacer), 
                    !$replacer && isArray(replacer) || (replacer = function(key, value) {
                        if ($replacer && (value = $replacer.call(this, key, value)), !isSymbol(value)) return value;
                    }), args[1] = replacer, _stringify.apply($JSON, args);
                }
            }
        }), // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
        $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf), 
        // 19.4.3.5 Symbol.prototype[@@toStringTag]
        setToStringTag($Symbol, "Symbol"), // 20.2.1.9 Math[@@toStringTag]
        setToStringTag(Math, "Math", !0), // 24.3.3 JSON[@@toStringTag]
        setToStringTag(global.JSON, "JSON", !0);
    }, /* 91 */
    /***/
    function(module, exports, __webpack_require__) {
        var global = __webpack_require__(7), core = __webpack_require__(8), LIBRARY = __webpack_require__(51), wksExt = __webpack_require__(87), defineProperty = __webpack_require__(12).f;
        module.exports = function(name) {
            var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
            "_" == name.charAt(0) || name in $Symbol || defineProperty($Symbol, name, {
                value: wksExt.f(name)
            });
        };
    }, /* 92 */
    /***/
    function(module, exports, __webpack_require__) {
        var getKeys = __webpack_require__(22), toIObject = __webpack_require__(25);
        module.exports = function(object, el) {
            for (var key, O = toIObject(object), keys = getKeys(O), length = keys.length, index = 0; length > index; ) if (O[key = keys[index++]] === el) return key;
        };
    }, /* 93 */
    /***/
    function(module, exports, __webpack_require__) {
        // all enumerable object keys, includes symbols
        var getKeys = __webpack_require__(22), gOPS = __webpack_require__(73), pIE = __webpack_require__(74);
        module.exports = function(it) {
            var result = getKeys(it), getSymbols = gOPS.f;
            if (getSymbols) for (var key, symbols = getSymbols(it), isEnum = pIE.f, i = 0; symbols.length > i; ) isEnum.call(it, key = symbols[i++]) && result.push(key);
            return result;
        };
    }, /* 94 */
    /***/
    function(module, exports, __webpack_require__) {
        // 7.2.2 IsArray(argument)
        var cof = __webpack_require__(27);
        module.exports = Array.isArray || function(arg) {
            return "Array" == cof(arg);
        };
    }, /* 95 */
    /***/
    function(module, exports, __webpack_require__) {
        // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
        var toIObject = __webpack_require__(25), gOPN = __webpack_require__(96).f, toString = {}.toString, windowNames = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], getWindowNames = function(it) {
            try {
                return gOPN(it);
            } catch (e) {
                return windowNames.slice();
            }
        };
        module.exports.f = function(it) {
            return windowNames && "[object Window]" == toString.call(it) ? getWindowNames(it) : gOPN(toIObject(it));
        };
    }, /* 96 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
        var $keys = __webpack_require__(23), hiddenKeys = __webpack_require__(36).concat("length", "prototype");
        exports.f = Object.getOwnPropertyNames || function(O) {
            return $keys(O, hiddenKeys);
        };
    }, /* 97 */
    /***/
    function(module, exports, __webpack_require__) {
        var pIE = __webpack_require__(74), createDesc = __webpack_require__(20), toIObject = __webpack_require__(25), toPrimitive = __webpack_require__(19), has = __webpack_require__(24), IE8_DOM_DEFINE = __webpack_require__(15), gOPD = Object.getOwnPropertyDescriptor;
        exports.f = __webpack_require__(16) ? gOPD : function(O, P) {
            if (O = toIObject(O), P = toPrimitive(P, !0), IE8_DOM_DEFINE) try {
                return gOPD(O, P);
            } catch (e) {}
            if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
        };
    }, /* 98 */
    /***/
    function(module, exports) {}, /* 99 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(91)("asyncIterator");
    }, /* 100 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(91)("observable");
    }, /* 101 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _setPrototypeOf = __webpack_require__(102), _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf), _create = __webpack_require__(106), _create2 = _interopRequireDefault(_create), _typeof2 = __webpack_require__(84), _typeof3 = _interopRequireDefault(_typeof2);
        exports.default = function(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + ("undefined" == typeof superClass ? "undefined" : (0, 
            _typeof3.default)(superClass)));
            subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (_setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass);
        };
    }, /* 102 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(103),
            __esModule: !0
        };
    }, /* 103 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(104), module.exports = __webpack_require__(8).Object.setPrototypeOf;
    }, /* 104 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.3.19 Object.setPrototypeOf(O, proto)
        var $export = __webpack_require__(6);
        $export($export.S, "Object", {
            setPrototypeOf: __webpack_require__(105).set
        });
    }, /* 105 */
    /***/
    function(module, exports, __webpack_require__) {
        // Works with __proto__ only. Old v8 can't work with null proto objects.
        /* eslint-disable no-proto */
        var isObject = __webpack_require__(14), anObject = __webpack_require__(13), check = function(O, proto) {
            if (anObject(O), !isObject(proto) && null !== proto) throw TypeError(proto + ": can't set as prototype!");
        };
        module.exports = {
            set: Object.setPrototypeOf || ("__proto__" in {} ? // eslint-disable-line
            function(test, buggy, set) {
                try {
                    set = __webpack_require__(9)(Function.call, __webpack_require__(97).f(Object.prototype, "__proto__").set, 2), 
                    set(test, []), buggy = !(test instanceof Array);
                } catch (e) {
                    buggy = !0;
                }
                return function(O, proto) {
                    return check(O, proto), buggy ? O.__proto__ = proto : set(O, proto), O;
                };
            }({}, !1) : void 0),
            check: check
        };
    }, /* 106 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(107),
            __esModule: !0
        };
    }, /* 107 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(108);
        var $Object = __webpack_require__(8).Object;
        module.exports = function(P, D) {
            return $Object.create(P, D);
        };
    }, /* 108 */
    /***/
    function(module, exports, __webpack_require__) {
        var $export = __webpack_require__(6);
        // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        $export($export.S, "Object", {
            create: __webpack_require__(54)
        });
    }, /* 109 */
    /***/
    function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_109__;
    }, /* 110 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var React = __webpack_require__(109), className = __webpack_require__(111), debounce = __webpack_require__(112), CodeMirror = React.createClass({
            displayName: "CodeMirror",
            propTypes: {
                onChange: React.PropTypes.func,
                onFocusChange: React.PropTypes.func,
                options: React.PropTypes.object,
                path: React.PropTypes.string,
                value: React.PropTypes.string,
                className: React.PropTypes.any,
                codeMirrorInstance: React.PropTypes.object
            },
            getCodeMirrorInstance: function() {
                return this.props.codeMirrorInstance || __webpack_require__(113);
            },
            getInitialState: function() {
                return {
                    isFocused: !1
                };
            },
            componentDidMount: function() {
                var textareaNode = this.refs.textarea, codeMirrorInstance = this.getCodeMirrorInstance();
                this.codeMirror = codeMirrorInstance.fromTextArea(textareaNode, this.props.options), 
                this.codeMirror.on("change", this.codemirrorValueChanged), this.codeMirror.on("focus", this.focusChanged.bind(this, !0)), 
                this.codeMirror.on("blur", this.focusChanged.bind(this, !1)), this.codeMirror.setValue(this.props.defaultValue || this.props.value || "");
            },
            componentWillUnmount: function() {
                // is there a lighter-weight way to remove the cm instance?
                this.codeMirror && this.codeMirror.toTextArea();
            },
            componentWillReceiveProps: debounce(function(nextProps) {
                if (this.codeMirror && void 0 !== nextProps.value && this.codeMirror.getValue() != nextProps.value && this.codeMirror.setValue(nextProps.value), 
                "object" == typeof nextProps.options) for (var optionName in nextProps.options) nextProps.options.hasOwnProperty(optionName) && this.codeMirror.setOption(optionName, nextProps.options[optionName]);
            }, 0),
            getCodeMirror: function() {
                return this.codeMirror;
            },
            focus: function() {
                this.codeMirror && this.codeMirror.focus();
            },
            focusChanged: function(focused) {
                this.setState({
                    isFocused: focused
                }), this.props.onFocusChange && this.props.onFocusChange(focused);
            },
            codemirrorValueChanged: function(doc, change) {
                this.props.onChange && "setValue" != change.origin && this.props.onChange(doc.getValue());
            },
            render: function() {
                var editorClassName = className("ReactCodeMirror", this.state.isFocused ? "ReactCodeMirror--focused" : null, this.props.className);
                return React.createElement("div", {
                    className: editorClassName
                }, React.createElement("textarea", {
                    ref: "textarea",
                    name: this.props.path,
                    defaultValue: this.props.value,
                    autoComplete: "off"
                }));
            }
        });
        module.exports = CodeMirror;
    }, /* 111 */
    /***/
    function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
        /* global define */
        !function() {
            "use strict";
            function classNames() {
                for (var classes = [], i = 0; i < arguments.length; i++) {
                    var arg = arguments[i];
                    if (arg) {
                        var argType = typeof arg;
                        if ("string" === argType || "number" === argType) classes.push(arg); else if (Array.isArray(arg)) classes.push(classNames.apply(null, arg)); else if ("object" === argType) for (var key in arg) hasOwn.call(arg, key) && arg[key] && classes.push(key);
                    }
                }
                return classes.join(" ");
            }
            var hasOwn = {}.hasOwnProperty;
            "undefined" != typeof module && module.exports ? module.exports = classNames : (__WEBPACK_AMD_DEFINE_ARRAY__ = [], 
            __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return classNames;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), // register as 'classnames', consistent with npm package name
            !(void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)));
        }();
    }, /* 112 */
    /***/
    function(module, exports) {
        /* WEBPACK VAR INJECTION */
        (function(global) {
            /**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
            function debounce(func, wait, options) {
                function invokeFunc(time) {
                    var args = lastArgs, thisArg = lastThis;
                    return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args);
                }
                function leadingEdge(time) {
                    // Invoke the leading edge.
                    // Reset any `maxWait` timer.
                    // Start the timer for the trailing edge.
                    return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
                }
                function remainingWait(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
                    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
                }
                function shouldInvoke(time) {
                    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                    // Either this is the first call, activity has stopped and we're at the
                    // trailing edge, the system time has gone backwards and we're treating
                    // it as the trailing edge, or we've hit the `maxWait` limit.
                    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                    var time = now();
                    // Restart the timer.
                    return shouldInvoke(time) ? trailingEdge(time) : void (timerId = setTimeout(timerExpired, remainingWait(time)));
                }
                function trailingEdge(time) {
                    // Only invoke if we have `lastArgs` which means `func` has been
                    // debounced at least once.
                    // Only invoke if we have `lastArgs` which means `func` has been
                    // debounced at least once.
                    return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, 
                    result);
                }
                function cancel() {
                    void 0 !== timerId && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
                }
                function flush() {
                    return void 0 === timerId ? result : trailingEdge(now());
                }
                function debounced() {
                    var time = now(), isInvoking = shouldInvoke(time);
                    if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                        if (void 0 === timerId) return leadingEdge(lastCallTime);
                        if (maxing) // Handle invocations in a tight loop.
                        return timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime);
                    }
                    return void 0 === timerId && (timerId = setTimeout(timerExpired, wait)), result;
                }
                var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, 
                maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, 
                trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, 
                debounced.flush = flush, debounced;
            }
            /**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
            function isObject(value) {
                var type = typeof value;
                return !!value && ("object" == type || "function" == type);
            }
            /**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
            function isObjectLike(value) {
                return !!value && "object" == typeof value;
            }
            /**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
            function isSymbol(value) {
                return "symbol" == typeof value || isObjectLike(value) && objectToString.call(value) == symbolTag;
            }
            /**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
            function toNumber(value) {
                if ("number" == typeof value) return value;
                if (isSymbol(value)) return NAN;
                if (isObject(value)) {
                    var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                    value = isObject(other) ? other + "" : other;
                }
                if ("string" != typeof value) return 0 === value ? value : +value;
                value = value.replace(reTrim, "");
                var isBinary = reIsBinary.test(value);
                return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
            }
            /**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
            /** Used as the `TypeError` message for "Functions" methods. */
            var FUNC_ERROR_TEXT = "Expected a function", NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, freeGlobal = "object" == typeof global && global && global.Object === Object && global, freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), objectProto = Object.prototype, objectToString = objectProto.toString, nativeMax = Math.max, nativeMin = Math.min, now = function() {
                return root.Date.now();
            };
            module.exports = debounce;
        }).call(exports, function() {
            return this;
        }());
    }, /* 113 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: http://codemirror.net/LICENSE
        // This is CodeMirror (http://codemirror.net), a code editor
        // implemented in JavaScript on top of the browser's DOM.
        //
        // You can find some technical background for some of the code below
        // at http://marijnhaverbeke.nl/blog/#cm-internals .
        !function(global, factory) {
            module.exports = factory();
        }(this, function() {
            "use strict";
            function classTest(cls) {
                return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
            }
            function removeChildren(e) {
                for (var count = e.childNodes.length; count > 0; --count) e.removeChild(e.firstChild);
                return e;
            }
            function removeChildrenAndAdd(parent, e) {
                return removeChildren(parent).appendChild(e);
            }
            function elt(tag, content, className, style) {
                var e = document.createElement(tag);
                if (className && (e.className = className), style && (e.style.cssText = style), 
                "string" == typeof content) e.appendChild(document.createTextNode(content)); else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
                return e;
            }
            function contains(parent, child) {
                if (3 == child.nodeType && (child = child.parentNode), parent.contains) return parent.contains(child);
                do if (11 == child.nodeType && (child = child.host), child == parent) return !0; while (child = child.parentNode);
            }
            function activeElt() {
                // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
                // IE < 10 will throw when accessed while the page is loading or in an iframe.
                // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
                var activeElement;
                try {
                    activeElement = document.activeElement;
                } catch (e) {
                    activeElement = document.body || null;
                }
                for (;activeElement && activeElement.root && activeElement.root.activeElement; ) activeElement = activeElement.root.activeElement;
                return activeElement;
            }
            function addClass(node, cls) {
                var current = node.className;
                classTest(cls).test(current) || (node.className += (current ? " " : "") + cls);
            }
            function joinClasses(a, b) {
                for (var as = a.split(" "), i = 0; i < as.length; i++) as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
                return b;
            }
            function bind(f) {
                var args = Array.prototype.slice.call(arguments, 1);
                return function() {
                    return f.apply(null, args);
                };
            }
            function copyObj(obj, target, overwrite) {
                target || (target = {});
                for (var prop in obj) !obj.hasOwnProperty(prop) || overwrite === !1 && target.hasOwnProperty(prop) || (target[prop] = obj[prop]);
                return target;
            }
            // Counts the column offset in a string, taking tabs into account.
            // Used mostly to find indentation.
            function countColumn(string, end, tabSize, startIndex, startValue) {
                null == end && (end = string.search(/[^\s\u00a0]/), end == -1 && (end = string.length));
                for (var i = startIndex || 0, n = startValue || 0; ;) {
                    var nextTab = string.indexOf("\t", i);
                    if (nextTab < 0 || nextTab >= end) return n + (end - i);
                    n += nextTab - i, n += tabSize - n % tabSize, i = nextTab + 1;
                }
            }
            function indexOf(array, elt) {
                for (var i = 0; i < array.length; ++i) if (array[i] == elt) return i;
                return -1;
            }
            // The inverse of countColumn -- find the offset that corresponds to
            // a particular column.
            function findColumn(string, goal, tabSize) {
                for (var pos = 0, col = 0; ;) {
                    var nextTab = string.indexOf("\t", pos);
                    nextTab == -1 && (nextTab = string.length);
                    var skipped = nextTab - pos;
                    if (nextTab == string.length || col + skipped >= goal) return pos + Math.min(skipped, goal - col);
                    if (col += nextTab - pos, col += tabSize - col % tabSize, pos = nextTab + 1, col >= goal) return pos;
                }
            }
            function spaceStr(n) {
                for (;spaceStrs.length <= n; ) spaceStrs.push(lst(spaceStrs) + " ");
                return spaceStrs[n];
            }
            function lst(arr) {
                return arr[arr.length - 1];
            }
            function map(array, f) {
                for (var out = [], i = 0; i < array.length; i++) out[i] = f(array[i], i);
                return out;
            }
            function insertSorted(array, value, score) {
                for (var pos = 0, priority = score(value); pos < array.length && score(array[pos]) <= priority; ) pos++;
                array.splice(pos, 0, value);
            }
            function nothing() {}
            function createObj(base, props) {
                var inst;
                return Object.create ? inst = Object.create(base) : (nothing.prototype = base, inst = new nothing()), 
                props && copyObj(props, inst), inst;
            }
            function isWordCharBasic(ch) {
                return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
            }
            function isWordChar(ch, helper) {
                return helper ? !!(helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) || helper.test(ch) : isWordCharBasic(ch);
            }
            function isEmpty(obj) {
                for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return !1;
                return !0;
            }
            function isExtendingChar(ch) {
                return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
            }
            // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
            function skipExtendingChars(str, pos, dir) {
                for (;(dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos)); ) pos += dir;
                return pos;
            }
            // Returns the value from the range [`from`; `to`] that satisfies
            // `pred` and is closest to `from`. Assumes that at least `to` satisfies `pred`.
            function findFirst(pred, from, to) {
                for (;;) {
                    if (Math.abs(from - to) <= 1) return pred(from) ? from : to;
                    var mid = Math.floor((from + to) / 2);
                    pred(mid) ? to = mid : from = mid;
                }
            }
            // The display handles the DOM integration, both for input reading
            // and content drawing. It holds references to DOM nodes and
            // display-related state.
            function Display(place, doc, input) {
                var d = this;
                this.input = input, // Covers bottom-right square when both scrollbars are present.
                d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler"), d.scrollbarFiller.setAttribute("cm-not-content", "true"), 
                // Covers bottom of gutter when coverGutterNextToScrollbar is on
                // and h scrollbar is present.
                d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler"), d.gutterFiller.setAttribute("cm-not-content", "true"), 
                // Will contain the actual code, positioned to cover the viewport.
                d.lineDiv = elt("div", null, "CodeMirror-code"), // Elements are added to these to represent selection and cursors.
                d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1"), d.cursorDiv = elt("div", null, "CodeMirror-cursors"), 
                // A visibility: hidden element used to find the size of things.
                d.measure = elt("div", null, "CodeMirror-measure"), // When lines outside of the viewport are measured, they are drawn in this.
                d.lineMeasure = elt("div", null, "CodeMirror-measure"), // Wraps everything that needs to exist inside the vertically-padded coordinate system
                d.lineSpace = elt("div", [ d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv ], null, "position: relative; outline: none"), 
                // Moved around its parent to cover visible view.
                d.mover = elt("div", [ elt("div", [ d.lineSpace ], "CodeMirror-lines") ], null, "position: relative"), 
                // Set to the height of the document, allowing scrolling.
                d.sizer = elt("div", [ d.mover ], "CodeMirror-sizer"), d.sizerWidth = null, // Behavior of elts with overflow: auto and padding is
                // inconsistent across browsers. This is used to ensure the
                // scrollable area is big enough.
                d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"), 
                // Will contain the gutters, if any.
                d.gutters = elt("div", null, "CodeMirror-gutters"), d.lineGutter = null, // Actual scrollable element.
                d.scroller = elt("div", [ d.sizer, d.heightForcer, d.gutters ], "CodeMirror-scroll"), 
                d.scroller.setAttribute("tabIndex", "-1"), // The element in which the editor lives.
                d.wrapper = elt("div", [ d.scrollbarFiller, d.gutterFiller, d.scroller ], "CodeMirror"), 
                // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
                ie && ie_version < 8 && (d.gutters.style.zIndex = -1, d.scroller.style.paddingRight = 0), 
                webkit || gecko && mobile || (d.scroller.draggable = !0), place && (place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper)), 
                // Current rendered range (may be bigger than the view window).
                d.viewFrom = d.viewTo = doc.first, d.reportedViewFrom = d.reportedViewTo = doc.first, 
                // Information about the rendered lines.
                d.view = [], d.renderedView = null, // Holds info about a single rendered line when it was rendered
                // for measurement, while not in view.
                d.externalMeasured = null, // Empty space (in pixels) above the view
                d.viewOffset = 0, d.lastWrapHeight = d.lastWrapWidth = 0, d.updateLineNumbers = null, 
                d.nativeBarWidth = d.barHeight = d.barWidth = 0, d.scrollbarsClipped = !1, // Used to only resize the line number gutter when necessary (when
                // the amount of lines crosses a boundary that makes its width change)
                d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null, // Set to true when a non-horizontal-scrolling line widget is
                // added. As an optimization, line widget aligning is skipped when
                // this is false.
                d.alignWidgets = !1, d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, 
                // Tracks the maximum line length so that the horizontal scrollbar
                // can be kept static when scrolling.
                d.maxLine = null, d.maxLineLength = 0, d.maxLineChanged = !1, // Used for measuring wheel scrolling granularity
                d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null, // True when shift is held down.
                d.shift = !1, // Used to track whether anything happened since the context menu
                // was opened.
                d.selForContextMenu = null, d.activeTouch = null, input.init(d);
            }
            // Find the line object corresponding to the given line number.
            function getLine(doc, n) {
                if (n -= doc.first, n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
                for (var chunk = doc; !chunk.lines; ) for (var i = 0; ;++i) {
                    var child = chunk.children[i], sz = child.chunkSize();
                    if (n < sz) {
                        chunk = child;
                        break;
                    }
                    n -= sz;
                }
                return chunk.lines[n];
            }
            // Get the part of a document between two positions, as an array of
            // strings.
            function getBetween(doc, start, end) {
                var out = [], n = start.line;
                return doc.iter(start.line, end.line + 1, function(line) {
                    var text = line.text;
                    n == end.line && (text = text.slice(0, end.ch)), n == start.line && (text = text.slice(start.ch)), 
                    out.push(text), ++n;
                }), out;
            }
            // Get the lines between from and to, as array of strings.
            function getLines(doc, from, to) {
                var out = [];
                // iter aborts when callback returns truthy value
                return doc.iter(from, to, function(line) {
                    out.push(line.text);
                }), out;
            }
            // Update the height of a line, propagating the height change
            // upwards to parent nodes.
            function updateLineHeight(line, height) {
                var diff = height - line.height;
                if (diff) for (var n = line; n; n = n.parent) n.height += diff;
            }
            // Given a line object, find its line number by walking up through
            // its parent links.
            function lineNo(line) {
                if (null == line.parent) return null;
                for (var cur = line.parent, no = indexOf(cur.lines, line), chunk = cur.parent; chunk; cur = chunk, 
                chunk = chunk.parent) for (var i = 0; chunk.children[i] != cur; ++i) no += chunk.children[i].chunkSize();
                return no + cur.first;
            }
            // Find the line at the given vertical position, using the height
            // information in the document tree.
            function lineAtHeight(chunk, h) {
                var n = chunk.first;
                outer: do {
                    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
                        var child = chunk.children[i$1], ch = child.height;
                        if (h < ch) {
                            chunk = child;
                            continue outer;
                        }
                        h -= ch, n += child.chunkSize();
                    }
                    return n;
                } while (!chunk.lines);
                for (var i = 0; i < chunk.lines.length; ++i) {
                    var line = chunk.lines[i], lh = line.height;
                    if (h < lh) break;
                    h -= lh;
                }
                return n + i;
            }
            function isLine(doc, l) {
                return l >= doc.first && l < doc.first + doc.size;
            }
            function lineNumberFor(options, i) {
                return String(options.lineNumberFormatter(i + options.firstLineNumber));
            }
            // A Pos instance represents a position within the text.
            function Pos(line, ch, sticky) {
                return void 0 === sticky && (sticky = null), this instanceof Pos ? (this.line = line, 
                this.ch = ch, void (this.sticky = sticky)) : new Pos(line, ch, sticky);
            }
            // Compare two positions, return 0 if they are the same, a negative
            // number when a is less, and a positive number otherwise.
            function cmp(a, b) {
                return a.line - b.line || a.ch - b.ch;
            }
            function equalCursorPos(a, b) {
                return a.sticky == b.sticky && 0 == cmp(a, b);
            }
            function copyPos(x) {
                return Pos(x.line, x.ch);
            }
            function maxPos(a, b) {
                return cmp(a, b) < 0 ? b : a;
            }
            function minPos(a, b) {
                return cmp(a, b) < 0 ? a : b;
            }
            // Most of the external API clips given positions to make sure they
            // actually exist within the document.
            function clipLine(doc, n) {
                return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
            }
            function clipPos(doc, pos) {
                if (pos.line < doc.first) return Pos(doc.first, 0);
                var last = doc.first + doc.size - 1;
                return pos.line > last ? Pos(last, getLine(doc, last).text.length) : clipToLen(pos, getLine(doc, pos.line).text.length);
            }
            function clipToLen(pos, linelen) {
                var ch = pos.ch;
                return null == ch || ch > linelen ? Pos(pos.line, linelen) : ch < 0 ? Pos(pos.line, 0) : pos;
            }
            function clipPosArray(doc, array) {
                for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
                return out;
            }
            function seeReadOnlySpans() {
                sawReadOnlySpans = !0;
            }
            function seeCollapsedSpans() {
                sawCollapsedSpans = !0;
            }
            // TEXTMARKER SPANS
            function MarkedSpan(marker, from, to) {
                this.marker = marker, this.from = from, this.to = to;
            }
            // Search an array of spans for a span matching the given marker.
            function getMarkedSpanFor(spans, marker) {
                if (spans) for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.marker == marker) return span;
                }
            }
            // Remove a span from an array, returning undefined if no spans are
            // left (we don't store arrays for lines without spans).
            function removeMarkedSpan(spans, span) {
                for (var r, i = 0; i < spans.length; ++i) spans[i] != span && (r || (r = [])).push(spans[i]);
                return r;
            }
            // Add a span to a line.
            function addMarkedSpan(line, span) {
                line.markedSpans = line.markedSpans ? line.markedSpans.concat([ span ]) : [ span ], 
                span.marker.attachLine(line);
            }
            // Used for the algorithm that adjusts markers for a change in the
            // document. These functions cut an array of spans at a given
            // character position, returning an array of remaining chunks (or
            // undefined if nothing remains).
            function markedSpansBefore(old, startCh, isInsert) {
                var nw;
                if (old) for (var i = 0; i < old.length; ++i) {
                    var span = old[i], marker = span.marker, startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                    if (startsBefore || span.from == startCh && "bookmark" == marker.type && (!isInsert || !span.marker.insertLeft)) {
                        var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
                    }
                }
                return nw;
            }
            function markedSpansAfter(old, endCh, isInsert) {
                var nw;
                if (old) for (var i = 0; i < old.length; ++i) {
                    var span = old[i], marker = span.marker, endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                    if (endsAfter || span.from == endCh && "bookmark" == marker.type && (!isInsert || span.marker.insertLeft)) {
                        var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, null == span.to ? null : span.to - endCh));
                    }
                }
                return nw;
            }
            // Given a change object, compute the new set of marker spans that
            // cover the line in which the change took place. Removes spans
            // entirely within the change, reconnects spans belonging to the
            // same marker that appear on both sides of the change, and cuts off
            // spans partially within the change. Returns an array of span
            // arrays with one element for each line in (after) the change.
            function stretchSpansOverChange(doc, change) {
                if (change.full) return null;
                var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans, oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
                if (!oldFirst && !oldLast) return null;
                var startCh = change.from.ch, endCh = change.to.ch, isInsert = 0 == cmp(change.from, change.to), first = markedSpansBefore(oldFirst, startCh, isInsert), last = markedSpansAfter(oldLast, endCh, isInsert), sameLine = 1 == change.text.length, offset = lst(change.text).length + (sameLine ? startCh : 0);
                if (first) // Fix up .to properties of first
                for (var i = 0; i < first.length; ++i) {
                    var span = first[i];
                    if (null == span.to) {
                        var found = getMarkedSpanFor(last, span.marker);
                        found ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh;
                    }
                }
                if (last) // Fix up .from in last (or move them into first in case of sameLine)
                for (var i$1 = 0; i$1 < last.length; ++i$1) {
                    var span$1 = last[i$1];
                    if (null != span$1.to && (span$1.to += offset), null == span$1.from) {
                        var found$1 = getMarkedSpanFor(first, span$1.marker);
                        found$1 || (span$1.from = offset, sameLine && (first || (first = [])).push(span$1));
                    } else span$1.from += offset, sameLine && (first || (first = [])).push(span$1);
                }
                // Make sure we didn't create any zero-length spans
                first && (first = clearEmptySpans(first)), last && last != first && (last = clearEmptySpans(last));
                var newMarkers = [ first ];
                if (!sameLine) {
                    // Fill gap with whole-line-spans
                    var gapMarkers, gap = change.text.length - 2;
                    if (gap > 0 && first) for (var i$2 = 0; i$2 < first.length; ++i$2) null == first[i$2].to && (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
                    for (var i$3 = 0; i$3 < gap; ++i$3) newMarkers.push(gapMarkers);
                    newMarkers.push(last);
                }
                return newMarkers;
            }
            // Remove spans that are empty and don't have a clearWhenEmpty
            // option of false.
            function clearEmptySpans(spans) {
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    null != span.from && span.from == span.to && span.marker.clearWhenEmpty !== !1 && spans.splice(i--, 1);
                }
                return spans.length ? spans : null;
            }
            // Used to 'clip' out readOnly ranges when making a change.
            function removeReadOnlyRanges(doc, from, to) {
                var markers = null;
                if (doc.iter(from.line, to.line + 1, function(line) {
                    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                        var mark = line.markedSpans[i].marker;
                        !mark.readOnly || markers && indexOf(markers, mark) != -1 || (markers || (markers = [])).push(mark);
                    }
                }), !markers) return null;
                for (var parts = [ {
                    from: from,
                    to: to
                } ], i = 0; i < markers.length; ++i) for (var mk = markers[i], m = mk.find(0), j = 0; j < parts.length; ++j) {
                    var p = parts[j];
                    if (!(cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)) {
                        var newParts = [ j, 1 ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
                        (dfrom < 0 || !mk.inclusiveLeft && !dfrom) && newParts.push({
                            from: p.from,
                            to: m.from
                        }), (dto > 0 || !mk.inclusiveRight && !dto) && newParts.push({
                            from: m.to,
                            to: p.to
                        }), parts.splice.apply(parts, newParts), j += newParts.length - 3;
                    }
                }
                return parts;
            }
            // Connect or disconnect spans from a line.
            function detachMarkedSpans(line) {
                var spans = line.markedSpans;
                if (spans) {
                    for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
                    line.markedSpans = null;
                }
            }
            function attachMarkedSpans(line, spans) {
                if (spans) {
                    for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
                    line.markedSpans = spans;
                }
            }
            // Helpers used when computing which overlapping collapsed span
            // counts as the larger one.
            function extraLeft(marker) {
                return marker.inclusiveLeft ? -1 : 0;
            }
            function extraRight(marker) {
                return marker.inclusiveRight ? 1 : 0;
            }
            // Returns a number indicating which of two overlapping collapsed
            // spans is larger (and thus includes the other). Falls back to
            // comparing ids when the spans cover exactly the same range.
            function compareCollapsedMarkers(a, b) {
                var lenDiff = a.lines.length - b.lines.length;
                if (0 != lenDiff) return lenDiff;
                var aPos = a.find(), bPos = b.find(), fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
                if (fromCmp) return -fromCmp;
                var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
                return toCmp ? toCmp : b.id - a.id;
            }
            // Find out whether a line ends or starts in a collapsed span. If
            // so, return the marker for that span.
            function collapsedSpanAtSide(line, start) {
                var found, sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var sp = void 0, i = 0; i < sps.length; ++i) sp = sps[i], sp.marker.collapsed && null == (start ? sp.from : sp.to) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker);
                return found;
            }
            function collapsedSpanAtStart(line) {
                return collapsedSpanAtSide(line, !0);
            }
            function collapsedSpanAtEnd(line) {
                return collapsedSpanAtSide(line, !1);
            }
            // Test whether there exists a collapsed span that partially
            // overlaps (covers the start or end, but not both) of a new span.
            // Such overlap is not allowed.
            function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
                var line = getLine(doc, lineNo), sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var i = 0; i < sps.length; ++i) {
                    var sp = sps[i];
                    if (sp.marker.collapsed) {
                        var found = sp.marker.find(0), fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker), toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                        if (!(fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) && (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))) return !0;
                    }
                }
            }
            // A visual line is a line as drawn on the screen. Folding, for
            // example, can cause multiple logical lines to appear on the same
            // visual line. This finds the start of the visual line that the
            // given line is part of (usually that is the line itself).
            function visualLine(line) {
                for (var merged; merged = collapsedSpanAtStart(line); ) line = merged.find(-1, !0).line;
                return line;
            }
            function visualLineEnd(line) {
                for (var merged; merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line;
                return line;
            }
            // Returns an array of logical lines that continue the visual line
            // started by the argument, or undefined if there are no such lines.
            function visualLineContinued(line) {
                for (var merged, lines; merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line, 
                (lines || (lines = [])).push(line);
                return lines;
            }
            // Get the line number of the start of the visual line that the
            // given line number is part of.
            function visualLineNo(doc, lineN) {
                var line = getLine(doc, lineN), vis = visualLine(line);
                return line == vis ? lineN : lineNo(vis);
            }
            // Get the line number of the start of the next visual line after
            // the given line.
            function visualLineEndNo(doc, lineN) {
                if (lineN > doc.lastLine()) return lineN;
                var merged, line = getLine(doc, lineN);
                if (!lineIsHidden(doc, line)) return lineN;
                for (;merged = collapsedSpanAtEnd(line); ) line = merged.find(1, !0).line;
                return lineNo(line) + 1;
            }
            // Compute whether a line is hidden. Lines count as hidden when they
            // are part of a visual line that starts with another line, or when
            // they are entirely covered by collapsed, non-widget span.
            function lineIsHidden(doc, line) {
                var sps = sawCollapsedSpans && line.markedSpans;
                if (sps) for (var sp = void 0, i = 0; i < sps.length; ++i) if (sp = sps[i], sp.marker.collapsed) {
                    if (null == sp.from) return !0;
                    if (!sp.marker.widgetNode && 0 == sp.from && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return !0;
                }
            }
            function lineIsHiddenInner(doc, line, span) {
                if (null == span.to) {
                    var end = span.marker.find(1, !0);
                    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
                }
                if (span.marker.inclusiveRight && span.to == line.text.length) return !0;
                for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) if (sp = line.markedSpans[i], 
                sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (null == sp.to || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return !0;
            }
            // Find the height above the given line.
            function heightAtLine(lineObj) {
                lineObj = visualLine(lineObj);
                for (var h = 0, chunk = lineObj.parent, i = 0; i < chunk.lines.length; ++i) {
                    var line = chunk.lines[i];
                    if (line == lineObj) break;
                    h += line.height;
                }
                for (var p = chunk.parent; p; chunk = p, p = chunk.parent) for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
                    var cur = p.children[i$1];
                    if (cur == chunk) break;
                    h += cur.height;
                }
                return h;
            }
            // Compute the character length of a line, taking into account
            // collapsed ranges (see markText) that might hide parts, and join
            // other lines onto it.
            function lineLength(line) {
                if (0 == line.height) return 0;
                for (var merged, len = line.text.length, cur = line; merged = collapsedSpanAtStart(cur); ) {
                    var found = merged.find(0, !0);
                    cur = found.from.line, len += found.from.ch - found.to.ch;
                }
                for (cur = line; merged = collapsedSpanAtEnd(cur); ) {
                    var found$1 = merged.find(0, !0);
                    len -= cur.text.length - found$1.from.ch, cur = found$1.to.line, len += cur.text.length - found$1.to.ch;
                }
                return len;
            }
            // Find the longest line in the document.
            function findMaxLine(cm) {
                var d = cm.display, doc = cm.doc;
                d.maxLine = getLine(doc, doc.first), d.maxLineLength = lineLength(d.maxLine), d.maxLineChanged = !0, 
                doc.iter(function(line) {
                    var len = lineLength(line);
                    len > d.maxLineLength && (d.maxLineLength = len, d.maxLine = line);
                });
            }
            // BIDI HELPERS
            function iterateBidiSections(order, from, to, f) {
                if (!order) return f(from, to, "ltr");
                for (var found = !1, i = 0; i < order.length; ++i) {
                    var part = order[i];
                    (part.from < to && part.to > from || from == to && part.to == from) && (f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr"), 
                    found = !0);
                }
                found || f(from, to, "ltr");
            }
            function getBidiPartAt(order, ch, sticky) {
                var found;
                bidiOther = null;
                for (var i = 0; i < order.length; ++i) {
                    var cur = order[i];
                    if (cur.from < ch && cur.to > ch) return i;
                    cur.to == ch && (cur.from != cur.to && "before" == sticky ? found = i : bidiOther = i), 
                    cur.from == ch && (cur.from != cur.to && "before" != sticky ? found = i : bidiOther = i);
                }
                return null != found ? found : bidiOther;
            }
            // Get the bidi ordering for the given line (and cache it). Returns
            // false for lines that are fully left-to-right, and an array of
            // BidiSpan objects otherwise.
            function getOrder(line) {
                var order = line.order;
                return null == order && (order = line.order = bidiOrdering(line.text)), order;
            }
            function moveCharLogically(line, ch, dir) {
                var target = skipExtendingChars(line.text, ch + dir, dir);
                return target < 0 || target > line.text.length ? null : target;
            }
            function moveLogically(line, start, dir) {
                var ch = moveCharLogically(line, start.ch, dir);
                return null == ch ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
            }
            function endOfLine(visually, cm, lineObj, lineNo, dir) {
                if (visually) {
                    var order = getOrder(lineObj);
                    if (order) {
                        var ch, part = dir < 0 ? lst(order) : order[0], moveInStorageOrder = dir < 0 == (1 == part.level), sticky = moveInStorageOrder ? "after" : "before";
                        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
                        // it could be that the last bidi part is not on the last visual line,
                        // since visual lines contain content order-consecutive chunks.
                        // Thus, in rtl, we are looking for the first (content-order) character
                        // in the rtl chunk that is on the last line (that is, the same line
                        // as the last (content-order) character).
                        if (part.level > 0) {
                            var prep = prepareMeasureForLine(cm, lineObj);
                            ch = dir < 0 ? lineObj.text.length - 1 : 0;
                            var targetTop = measureCharPrepared(cm, prep, ch).top;
                            ch = findFirst(function(ch) {
                                return measureCharPrepared(cm, prep, ch).top == targetTop;
                            }, dir < 0 == (1 == part.level) ? part.from : part.to - 1, ch), "before" == sticky && (ch = moveCharLogically(lineObj, ch, 1, !0));
                        } else ch = dir < 0 ? part.to : part.from;
                        return new Pos(lineNo, ch, sticky);
                    }
                }
                return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
            }
            function moveVisually(cm, line, start, dir) {
                var bidi = getOrder(line);
                if (!bidi) return moveLogically(line, start, dir);
                start.ch >= line.text.length ? (start.ch = line.text.length, start.sticky = "before") : start.ch <= 0 && (start.ch = 0, 
                start.sticky = "after");
                var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
                if (part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) // Case 1: We move within an ltr part. Even with wrapped lines,
                // nothing interesting happens.
                return moveLogically(line, start, dir);
                var prep, mv = function(pos, dir) {
                    return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
                }, getWrappedLineExtent = function(ch) {
                    return cm.options.lineWrapping ? (prep = prep || prepareMeasureForLine(cm, line), 
                    wrappedLineExtentChar(cm, line, prep, ch)) : {
                        begin: 0,
                        end: line.text.length
                    };
                }, wrappedLineExtent = getWrappedLineExtent("before" == start.sticky ? mv(start, -1) : start.ch);
                if (part.level % 2 == 1) {
                    var ch = mv(start, -dir);
                    if (null != ch && (dir > 0 ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
                        // Case 2: We move within an rtl part on the same visual line
                        var sticky = dir < 0 ? "before" : "after";
                        return new Pos(start.line, ch, sticky);
                    }
                }
                // Case 3: Could not move within this bidi part in this visual line, so leave
                // the current bidi part
                var searchInVisualLine = function(partPos, dir, wrappedLineExtent) {
                    for (var getRes = function(ch, moveInStorageOrder) {
                        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
                    }; partPos >= 0 && partPos < bidi.length; partPos += dir) {
                        var part = bidi[partPos], moveInStorageOrder = dir > 0 == (1 != part.level), ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
                        if (part.from <= ch && ch < part.to) return getRes(ch, moveInStorageOrder);
                        if (ch = moveInStorageOrder ? part.from : mv(part.to, -1), wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) return getRes(ch, moveInStorageOrder);
                    }
                }, res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
                if (res) return res;
                // Case 3b: Look for other bidi parts on the next visual line
                var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
                return null == nextCh || dir > 0 && nextCh == line.text.length || !(res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh))) ? null : res;
            }
            function getHandlers(emitter, type) {
                return emitter._handlers && emitter._handlers[type] || noHandlers;
            }
            function off(emitter, type, f) {
                if (emitter.removeEventListener) emitter.removeEventListener(type, f, !1); else if (emitter.detachEvent) emitter.detachEvent("on" + type, f); else {
                    var map = emitter._handlers, arr = map && map[type];
                    if (arr) {
                        var index = indexOf(arr, f);
                        index > -1 && (map[type] = arr.slice(0, index).concat(arr.slice(index + 1)));
                    }
                }
            }
            function signal(emitter, type) {
                var handlers = getHandlers(emitter, type);
                if (handlers.length) for (var args = Array.prototype.slice.call(arguments, 2), i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);
            }
            // The DOM events that CodeMirror handles can be overridden by
            // registering a (non-DOM) handler on the editor for the event name,
            // and preventDefault-ing the event in that handler.
            function signalDOMEvent(cm, e, override) {
                return "string" == typeof e && (e = {
                    type: e,
                    preventDefault: function() {
                        this.defaultPrevented = !0;
                    }
                }), signal(cm, override || e.type, cm, e), e_defaultPrevented(e) || e.codemirrorIgnore;
            }
            function signalCursorActivity(cm) {
                var arr = cm._handlers && cm._handlers.cursorActivity;
                if (arr) for (var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []), i = 0; i < arr.length; ++i) indexOf(set, arr[i]) == -1 && set.push(arr[i]);
            }
            function hasHandler(emitter, type) {
                return getHandlers(emitter, type).length > 0;
            }
            // Add on and off methods to a constructor's prototype, to make
            // registering events on such objects more convenient.
            function eventMixin(ctor) {
                ctor.prototype.on = function(type, f) {
                    on(this, type, f);
                }, ctor.prototype.off = function(type, f) {
                    off(this, type, f);
                };
            }
            // Due to the fact that we still support jurassic IE versions, some
            // compatibility wrappers are needed.
            function e_preventDefault(e) {
                e.preventDefault ? e.preventDefault() : e.returnValue = !1;
            }
            function e_stopPropagation(e) {
                e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0;
            }
            function e_defaultPrevented(e) {
                return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue;
            }
            function e_stop(e) {
                e_preventDefault(e), e_stopPropagation(e);
            }
            function e_target(e) {
                return e.target || e.srcElement;
            }
            function e_button(e) {
                var b = e.which;
                return null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2)), 
                mac && e.ctrlKey && 1 == b && (b = 3), b;
            }
            function zeroWidthElement(measure) {
                if (null == zwspSupported) {
                    var test = elt("span", "");
                    removeChildrenAndAdd(measure, elt("span", [ test, document.createTextNode("x") ])), 
                    0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8));
                }
                var node = zwspSupported ? elt("span", "") : elt("span", "", null, "display: inline-block; width: 1px; margin-right: -1px");
                return node.setAttribute("cm-text", ""), node;
            }
            function hasBadBidiRects(measure) {
                if (null != badBidiRects) return badBidiRects;
                var txt = removeChildrenAndAdd(measure, document.createTextNode("AA")), r0 = range(txt, 0, 1).getBoundingClientRect(), r1 = range(txt, 1, 2).getBoundingClientRect();
                return removeChildren(measure), !(!r0 || r0.left == r0.right) && (badBidiRects = r1.right - r0.right < 3);
            }
            function hasBadZoomedRects(measure) {
                if (null != badZoomedRects) return badZoomedRects;
                var node = removeChildrenAndAdd(measure, elt("span", "x")), normal = node.getBoundingClientRect(), fromRange = range(node, 0, 1).getBoundingClientRect();
                return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
            }
            // Extra arguments are stored as the mode's dependencies, which is
            // used by (legacy) mechanisms like loadmode.js to automatically
            // load a mode. (Preferred mechanism is the require/define calls.)
            function defineMode(name, mode) {
                arguments.length > 2 && (mode.dependencies = Array.prototype.slice.call(arguments, 2)), 
                modes[name] = mode;
            }
            function defineMIME(mime, spec) {
                mimeModes[mime] = spec;
            }
            // Given a MIME type, a {name, ...options} config object, or a name
            // string, return a mode config object.
            function resolveMode(spec) {
                if ("string" == typeof spec && mimeModes.hasOwnProperty(spec)) spec = mimeModes[spec]; else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name)) {
                    var found = mimeModes[spec.name];
                    "string" == typeof found && (found = {
                        name: found
                    }), spec = createObj(found, spec), spec.name = found.name;
                } else {
                    if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) return resolveMode("application/xml");
                    if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) return resolveMode("application/json");
                }
                return "string" == typeof spec ? {
                    name: spec
                } : spec || {
                    name: "null"
                };
            }
            // Given a mode spec (anything that resolveMode accepts), find and
            // initialize an actual mode object.
            function getMode(options, spec) {
                spec = resolveMode(spec);
                var mfactory = modes[spec.name];
                if (!mfactory) return getMode(options, "text/plain");
                var modeObj = mfactory(options, spec);
                if (modeExtensions.hasOwnProperty(spec.name)) {
                    var exts = modeExtensions[spec.name];
                    for (var prop in exts) exts.hasOwnProperty(prop) && (modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]), 
                    modeObj[prop] = exts[prop]);
                }
                if (modeObj.name = spec.name, spec.helperType && (modeObj.helperType = spec.helperType), 
                spec.modeProps) for (var prop$1 in spec.modeProps) modeObj[prop$1] = spec.modeProps[prop$1];
                return modeObj;
            }
            function extendMode(mode, properties) {
                var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
                copyObj(properties, exts);
            }
            function copyState(mode, state) {
                if (state === !0) return state;
                if (mode.copyState) return mode.copyState(state);
                var nstate = {};
                for (var n in state) {
                    var val = state[n];
                    val instanceof Array && (val = val.concat([])), nstate[n] = val;
                }
                return nstate;
            }
            // Given a mode and a state (for that mode), find the inner mode and
            // state at the position that the state refers to.
            function innerMode(mode, state) {
                for (var info; mode.innerMode && (info = mode.innerMode(state), info && info.mode != mode); ) state = info.state, 
                mode = info.mode;
                return info || {
                    mode: mode,
                    state: state
                };
            }
            function startState(mode, a1, a2) {
                return !mode.startState || mode.startState(a1, a2);
            }
            // Compute a style array (an array starting with a mode generation
            // -- for invalidation -- followed by pairs of end positions and
            // style strings), which is used to highlight the tokens on the
            // line.
            function highlightLine(cm, line, state, forceToEnd) {
                // A styles array always starts with a number identifying the
                // mode/overlays that it is based on (for easy invalidation).
                var st = [ cm.state.modeGen ], lineClasses = {};
                // Compute the base array of styles
                runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
                    return st.push(end, style);
                }, lineClasses, forceToEnd);
                for (var loop = function(o) {
                    var overlay = cm.state.overlays[o], i = 1, at = 0;
                    runMode(cm, line.text, overlay.mode, !0, function(end, style) {
                        // Ensure there's a token end at the current position, and that i points at it
                        for (var start = i; at < end; ) {
                            var i_end = st[i];
                            i_end > end && st.splice(i, 1, end, st[i + 1], i_end), i += 2, at = Math.min(end, i_end);
                        }
                        if (style) if (overlay.opaque) st.splice(start, i - start, end, "overlay " + style), 
                        i = start + 2; else for (;start < i; start += 2) {
                            var cur = st[start + 1];
                            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
                        }
                    }, lineClasses);
                }, o = 0; o < cm.state.overlays.length; ++o) loop(o);
                return {
                    styles: st,
                    classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
                };
            }
            function getLineStyles(cm, line, updateFrontier) {
                if (!line.styles || line.styles[0] != cm.state.modeGen) {
                    var state = getStateBefore(cm, lineNo(line)), result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);
                    line.stateAfter = state, line.styles = result.styles, result.classes ? line.styleClasses = result.classes : line.styleClasses && (line.styleClasses = null), 
                    updateFrontier === cm.doc.frontier && cm.doc.frontier++;
                }
                return line.styles;
            }
            function getStateBefore(cm, n, precise) {
                var doc = cm.doc, display = cm.display;
                if (!doc.mode.startState) return !0;
                var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
                return state = state ? copyState(doc.mode, state) : startState(doc.mode), doc.iter(pos, n, function(line) {
                    processLine(cm, line.text, state);
                    var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
                    line.stateAfter = save ? copyState(doc.mode, state) : null, ++pos;
                }), precise && (doc.frontier = pos), state;
            }
            // Lightweight form of highlight -- proceed over this line and
            // update state, but don't save a style array. Used for lines that
            // aren't currently visible.
            function processLine(cm, text, state, startAt) {
                var mode = cm.doc.mode, stream = new StringStream(text, cm.options.tabSize);
                for (stream.start = stream.pos = startAt || 0, "" == text && callBlankLine(mode, state); !stream.eol(); ) readToken(mode, stream, state), 
                stream.start = stream.pos;
            }
            function callBlankLine(mode, state) {
                if (mode.blankLine) return mode.blankLine(state);
                if (mode.innerMode) {
                    var inner = innerMode(mode, state);
                    return inner.mode.blankLine ? inner.mode.blankLine(inner.state) : void 0;
                }
            }
            function readToken(mode, stream, state, inner) {
                for (var i = 0; i < 10; i++) {
                    inner && (inner[0] = innerMode(mode, state).mode);
                    var style = mode.token(stream, state);
                    if (stream.pos > stream.start) return style;
                }
                throw new Error("Mode " + mode.name + " failed to advance stream.");
            }
            // Utility for getTokenAt and getLineTokens
            function takeToken(cm, pos, precise, asArray) {
                var style, getObj = function(copy) {
                    return {
                        start: stream.start,
                        end: stream.pos,
                        string: stream.current(),
                        type: style || null,
                        state: copy ? copyState(doc.mode, state) : state
                    };
                }, doc = cm.doc, mode = doc.mode;
                pos = clipPos(doc, pos);
                var tokens, line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise), stream = new StringStream(line.text, cm.options.tabSize);
                for (asArray && (tokens = []); (asArray || stream.pos < pos.ch) && !stream.eol(); ) stream.start = stream.pos, 
                style = readToken(mode, stream, state), asArray && tokens.push(getObj(!0));
                return asArray ? tokens : getObj();
            }
            function extractLineClasses(type, output) {
                if (type) for (;;) {
                    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                    if (!lineClass) break;
                    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                    var prop = lineClass[1] ? "bgClass" : "textClass";
                    null == output[prop] ? output[prop] = lineClass[2] : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(output[prop]) || (output[prop] += " " + lineClass[2]);
                }
                return type;
            }
            // Run the given mode's parser over a line, calling f for each token.
            function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
                var flattenSpans = mode.flattenSpans;
                null == flattenSpans && (flattenSpans = cm.options.flattenSpans);
                var style, curStart = 0, curStyle = null, stream = new StringStream(text, cm.options.tabSize), inner = cm.options.addModeClass && [ null ];
                for ("" == text && extractLineClasses(callBlankLine(mode, state), lineClasses); !stream.eol(); ) {
                    if (stream.pos > cm.options.maxHighlightLength ? (flattenSpans = !1, forceToEnd && processLine(cm, text, state, stream.pos), 
                    stream.pos = text.length, style = null) : style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses), 
                    inner) {
                        var mName = inner[0].name;
                        mName && (style = "m-" + (style ? mName + " " + style : mName));
                    }
                    if (!flattenSpans || curStyle != style) {
                        for (;curStart < stream.start; ) curStart = Math.min(stream.start, curStart + 5e3), 
                        f(curStart, curStyle);
                        curStyle = style;
                    }
                    stream.start = stream.pos;
                }
                for (;curStart < stream.pos; ) {
                    // Webkit seems to refuse to render text nodes longer than 57444
                    // characters, and returns inaccurate measurements in nodes
                    // starting around 5000 chars.
                    var pos = Math.min(stream.pos, curStart + 5e3);
                    f(pos, curStyle), curStart = pos;
                }
            }
            // Finds the line to start with when starting a parse. Tries to
            // find a line with a stateAfter, so that it can start with a
            // valid state. If that fails, it returns the line with the
            // smallest indentation, which tends to need the least context to
            // parse correctly.
            function findStartLine(cm, n, precise) {
                for (var minindent, minline, doc = cm.doc, lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100), search = n; search > lim; --search) {
                    if (search <= doc.first) return doc.first;
                    var line = getLine(doc, search - 1);
                    if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
                    var indented = countColumn(line.text, null, cm.options.tabSize);
                    (null == minline || minindent > indented) && (minline = search - 1, minindent = indented);
                }
                return minline;
            }
            // Change the content (text, markers) of a line. Automatically
            // invalidates cached information and tries to re-estimate the
            // line's height.
            function updateLine(line, text, markedSpans, estimateHeight) {
                line.text = text, line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null), 
                null != line.order && (line.order = null), detachMarkedSpans(line), attachMarkedSpans(line, markedSpans);
                var estHeight = estimateHeight ? estimateHeight(line) : 1;
                estHeight != line.height && updateLineHeight(line, estHeight);
            }
            // Detach a line from the document tree and its markers.
            function cleanUpLine(line) {
                line.parent = null, detachMarkedSpans(line);
            }
            function interpretTokenStyle(style, options) {
                if (!style || /^\s*$/.test(style)) return null;
                var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
                return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
            }
            // Render the DOM representation of the text of a line. Also builds
            // up a 'line map', which points at the DOM nodes that represent
            // specific stretches of text, and is used by the measuring code.
            // The returned object contains the DOM node, this map, and
            // information about line-wide styles that were set by the mode.
            function buildLineContent(cm, lineView) {
                // The padding-right forces the element to have a 'border', which
                // is needed on Webkit to be able to get line-level bounding
                // rectangles for it (in measureChar).
                var content = elt("span", null, null, webkit ? "padding-right: .1px" : null), builder = {
                    pre: elt("pre", [ content ], "CodeMirror-line"),
                    content: content,
                    col: 0,
                    pos: 0,
                    cm: cm,
                    trailingSpace: !1,
                    splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
                };
                // hide from accessibility tree
                content.setAttribute("role", "presentation"), builder.pre.setAttribute("role", "presentation"), 
                lineView.measure = {};
                // Iterate over the logical lines that make up this visual line.
                for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
                    var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0;
                    builder.pos = 0, builder.addToken = buildToken, // Optionally wire in some hacks into the token-rendering
                    // algorithm, to deal with browser quirks.
                    hasBadBidiRects(cm.display.measure) && (order = getOrder(line)) && (builder.addToken = buildTokenBadBidi(builder.addToken, order)), 
                    builder.map = [];
                    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
                    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate)), 
                    line.styleClasses && (line.styleClasses.bgClass && (builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "")), 
                    line.styleClasses.textClass && (builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""))), 
                    // Ensure at least a single node is present, for measuring.
                    0 == builder.map.length && builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))), 
                    // Store the map and a cache object for the current logical line
                    0 == i ? (lineView.measure.map = builder.map, lineView.measure.cache = {}) : ((lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map), 
                    (lineView.measure.caches || (lineView.measure.caches = [])).push({}));
                }
                // See issue #2901
                if (webkit) {
                    var last = builder.content.lastChild;
                    (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) && (builder.content.className = "cm-tab-wrap-hack");
                }
                return signal(cm, "renderLine", cm, lineView.line, builder.pre), builder.pre.className && (builder.textClass = joinClasses(builder.pre.className, builder.textClass || "")), 
                builder;
            }
            function defaultSpecialCharPlaceholder(ch) {
                var token = elt("span", "", "cm-invalidchar");
                return token.title = "\\u" + ch.charCodeAt(0).toString(16), token.setAttribute("aria-label", token.title), 
                token;
            }
            // Build up the DOM representation for a single token, and add it to
            // the line map. Takes care to render special characters separately.
            function buildToken(builder, text, style, startStyle, endStyle, title, css) {
                if (text) {
                    var content, displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text, special = builder.cm.state.specialChars, mustWrap = !1;
                    if (special.test(text)) {
                        content = document.createDocumentFragment();
                        for (var pos = 0; ;) {
                            special.lastIndex = pos;
                            var m = special.exec(text), skipped = m ? m.index - pos : text.length - pos;
                            if (skipped) {
                                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                                ie && ie_version < 9 ? content.appendChild(elt("span", [ txt ])) : content.appendChild(txt), 
                                builder.map.push(builder.pos, builder.pos + skipped, txt), builder.col += skipped, 
                                builder.pos += skipped;
                            }
                            if (!m) break;
                            pos += skipped + 1;
                            var txt$1 = void 0;
                            if ("\t" == m[0]) {
                                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                                txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab")), txt$1.setAttribute("role", "presentation"), 
                                txt$1.setAttribute("cm-text", "\t"), builder.col += tabWidth;
                            } else "\r" == m[0] || "\n" == m[0] ? (txt$1 = content.appendChild(elt("span", "\r" == m[0] ? "" : "", "cm-invalidchar")), 
                            txt$1.setAttribute("cm-text", m[0]), builder.col += 1) : (txt$1 = builder.cm.options.specialCharPlaceholder(m[0]), 
                            txt$1.setAttribute("cm-text", m[0]), ie && ie_version < 9 ? content.appendChild(elt("span", [ txt$1 ])) : content.appendChild(txt$1), 
                            builder.col += 1);
                            builder.map.push(builder.pos, builder.pos + 1, txt$1), builder.pos++;
                        }
                    } else builder.col += text.length, content = document.createTextNode(displayText), 
                    builder.map.push(builder.pos, builder.pos + text.length, content), ie && ie_version < 9 && (mustWrap = !0), 
                    builder.pos += text.length;
                    if (builder.trailingSpace = 32 == displayText.charCodeAt(text.length - 1), style || startStyle || endStyle || mustWrap || css) {
                        var fullStyle = style || "";
                        startStyle && (fullStyle += startStyle), endStyle && (fullStyle += endStyle);
                        var token = elt("span", [ content ], fullStyle, css);
                        return title && (token.title = title), builder.content.appendChild(token);
                    }
                    builder.content.appendChild(content);
                }
            }
            function splitSpaces(text, trailingBefore) {
                if (text.length > 1 && !/  /.test(text)) return text;
                for (var spaceBefore = trailingBefore, result = "", i = 0; i < text.length; i++) {
                    var ch = text.charAt(i);
                    " " != ch || !spaceBefore || i != text.length - 1 && 32 != text.charCodeAt(i + 1) || (ch = ""), 
                    result += ch, spaceBefore = " " == ch;
                }
                return result;
            }
            // Work around nonsense dimensions being reported for stretches of
            // right-to-left text.
            function buildTokenBadBidi(inner, order) {
                return function(builder, text, style, startStyle, endStyle, title, css) {
                    style = style ? style + " cm-force-border" : "cm-force-border";
                    for (var start = builder.pos, end = start + text.length; ;) {
                        for (var part = void 0, i = 0; i < order.length && (part = order[i], !(part.to > start && part.from <= start)); i++) ;
                        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
                        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css), 
                        startStyle = null, text = text.slice(part.to - start), start = part.to;
                    }
                };
            }
            function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
                var widget = !ignoreWidget && marker.widgetNode;
                widget && builder.map.push(builder.pos, builder.pos + size, widget), !ignoreWidget && builder.cm.display.input.needsContentAttribute && (widget || (widget = builder.content.appendChild(document.createElement("span"))), 
                widget.setAttribute("cm-marker", marker.id)), widget && (builder.cm.display.input.setUneditable(widget), 
                builder.content.appendChild(widget)), builder.pos += size, builder.trailingSpace = !1;
            }
            // Outputs a number of spans to make up a line, taking highlighting
            // and marked text into account.
            function insertLineContent(line, builder, styles) {
                var spans = line.markedSpans, allText = line.text, at = 0;
                if (spans) for (var style, css, spanStyle, spanEndStyle, spanStartStyle, title, collapsed, len = allText.length, pos = 0, i = 1, text = "", nextChange = 0; ;) {
                    if (nextChange == pos) {
                        // Update current marker set
                        spanStyle = spanEndStyle = spanStartStyle = title = css = "", collapsed = null, 
                        nextChange = 1 / 0;
                        for (var foundBookmarks = [], endStyles = void 0, j = 0; j < spans.length; ++j) {
                            var sp = spans[j], m = sp.marker;
                            "bookmark" == m.type && sp.from == pos && m.widgetNode ? foundBookmarks.push(m) : sp.from <= pos && (null == sp.to || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos) ? (null != sp.to && sp.to != pos && nextChange > sp.to && (nextChange = sp.to, 
                            spanEndStyle = ""), m.className && (spanStyle += " " + m.className), m.css && (css = (css ? css + ";" : "") + m.css), 
                            m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle), m.endStyle && sp.to == nextChange && (endStyles || (endStyles = [])).push(m.endStyle, sp.to), 
                            m.title && !title && (title = m.title), m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0) && (collapsed = sp)) : sp.from > pos && nextChange > sp.from && (nextChange = sp.from);
                        }
                        if (endStyles) for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) endStyles[j$1 + 1] == nextChange && (spanEndStyle += " " + endStyles[j$1]);
                        if (!collapsed || collapsed.from == pos) for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                        if (collapsed && (collapsed.from || 0) == pos) {
                            if (buildCollapsedSpan(builder, (null == collapsed.to ? len + 1 : collapsed.to) - pos, collapsed.marker, null == collapsed.from), 
                            null == collapsed.to) return;
                            collapsed.to == pos && (collapsed = !1);
                        }
                    }
                    if (pos >= len) break;
                    for (var upto = Math.min(len, nextChange); ;) {
                        if (text) {
                            var end = pos + text.length;
                            if (!collapsed) {
                                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css);
                            }
                            if (end >= upto) {
                                text = text.slice(upto - pos), pos = upto;
                                break;
                            }
                            pos = end, spanStartStyle = "";
                        }
                        text = allText.slice(at, at = styles[i++]), style = interpretTokenStyle(styles[i++], builder.cm.options);
                    }
                } else for (var i$1 = 1; i$1 < styles.length; i$1 += 2) builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
            }
            // These objects are used to represent the visible (currently drawn)
            // part of the document. A LineView may correspond to multiple
            // logical lines, if those are connected by collapsed ranges.
            function LineView(doc, line, lineN) {
                // The starting line
                this.line = line, // Continuing lines, if any
                this.rest = visualLineContinued(line), // Number of logical lines in this visual line
                this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1, this.node = this.text = null, 
                this.hidden = lineIsHidden(doc, line);
            }
            // Create a range of LineView objects for the given lines.
            function buildViewArray(cm, from, to) {
                for (var nextPos, array = [], pos = from; pos < to; pos = nextPos) {
                    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
                    nextPos = pos + view.size, array.push(view);
                }
                return array;
            }
            function pushOperation(op) {
                operationGroup ? operationGroup.ops.push(op) : op.ownsGroup = operationGroup = {
                    ops: [ op ],
                    delayedCallbacks: []
                };
            }
            function fireCallbacksForOps(group) {
                // Calls delayed callbacks and cursorActivity handlers until no
                // new ones appear
                var callbacks = group.delayedCallbacks, i = 0;
                do {
                    for (;i < callbacks.length; i++) callbacks[i].call(null);
                    for (var j = 0; j < group.ops.length; j++) {
                        var op = group.ops[j];
                        if (op.cursorActivityHandlers) for (;op.cursorActivityCalled < op.cursorActivityHandlers.length; ) op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
                    }
                } while (i < callbacks.length);
            }
            function finishOperation(op, endCb) {
                var group = op.ownsGroup;
                if (group) try {
                    fireCallbacksForOps(group);
                } finally {
                    operationGroup = null, endCb(group);
                }
            }
            // Often, we want to signal events at a point where we are in the
            // middle of some work, but don't want the handler to start calling
            // other methods on the editor, which might be in an inconsistent
            // state or simply not expect any other events to happen.
            // signalLater looks whether there are any handlers, and schedules
            // them to be executed when the last operation ends, or, if no
            // operation is active, when a timeout fires.
            function signalLater(emitter, type) {
                var arr = getHandlers(emitter, type);
                if (arr.length) {
                    var list, args = Array.prototype.slice.call(arguments, 2);
                    operationGroup ? list = operationGroup.delayedCallbacks : orphanDelayedCallbacks ? list = orphanDelayedCallbacks : (list = orphanDelayedCallbacks = [], 
                    setTimeout(fireOrphanDelayed, 0));
                    for (var loop = function(i) {
                        list.push(function() {
                            return arr[i].apply(null, args);
                        });
                    }, i = 0; i < arr.length; ++i) loop(i);
                }
            }
            function fireOrphanDelayed() {
                var delayed = orphanDelayedCallbacks;
                orphanDelayedCallbacks = null;
                for (var i = 0; i < delayed.length; ++i) delayed[i]();
            }
            // When an aspect of a line changes, a string is added to
            // lineView.changes. This updates the relevant part of the line's
            // DOM structure.
            function updateLineForChanges(cm, lineView, lineN, dims) {
                for (var j = 0; j < lineView.changes.length; j++) {
                    var type = lineView.changes[j];
                    "text" == type ? updateLineText(cm, lineView) : "gutter" == type ? updateLineGutter(cm, lineView, lineN, dims) : "class" == type ? updateLineClasses(lineView) : "widget" == type && updateLineWidgets(cm, lineView, dims);
                }
                lineView.changes = null;
            }
            // Lines with gutter elements, widgets or a background class need to
            // be wrapped, and have the extra elements added to the wrapper div
            function ensureLineWrapped(lineView) {
                return lineView.node == lineView.text && (lineView.node = elt("div", null, null, "position: relative"), 
                lineView.text.parentNode && lineView.text.parentNode.replaceChild(lineView.node, lineView.text), 
                lineView.node.appendChild(lineView.text), ie && ie_version < 8 && (lineView.node.style.zIndex = 2)), 
                lineView.node;
            }
            function updateLineBackground(lineView) {
                var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
                if (cls && (cls += " CodeMirror-linebackground"), lineView.background) cls ? lineView.background.className = cls : (lineView.background.parentNode.removeChild(lineView.background), 
                lineView.background = null); else if (cls) {
                    var wrap = ensureLineWrapped(lineView);
                    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
                }
            }
            // Wrapper around buildLineContent which will reuse the structure
            // in display.externalMeasured when possible.
            function getLineContent(cm, lineView) {
                var ext = cm.display.externalMeasured;
                return ext && ext.line == lineView.line ? (cm.display.externalMeasured = null, lineView.measure = ext.measure, 
                ext.built) : buildLineContent(cm, lineView);
            }
            // Redraw the line's text. Interacts with the background and text
            // classes because the mode may output tokens that influence these
            // classes.
            function updateLineText(cm, lineView) {
                var cls = lineView.text.className, built = getLineContent(cm, lineView);
                lineView.text == lineView.node && (lineView.node = built.pre), lineView.text.parentNode.replaceChild(built.pre, lineView.text), 
                lineView.text = built.pre, built.bgClass != lineView.bgClass || built.textClass != lineView.textClass ? (lineView.bgClass = built.bgClass, 
                lineView.textClass = built.textClass, updateLineClasses(lineView)) : cls && (lineView.text.className = cls);
            }
            function updateLineClasses(lineView) {
                updateLineBackground(lineView), lineView.line.wrapClass ? ensureLineWrapped(lineView).className = lineView.line.wrapClass : lineView.node != lineView.text && (lineView.node.className = "");
                var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
                lineView.text.className = textClass || "";
            }
            function updateLineGutter(cm, lineView, lineN, dims) {
                if (lineView.gutter && (lineView.node.removeChild(lineView.gutter), lineView.gutter = null), 
                lineView.gutterBackground && (lineView.node.removeChild(lineView.gutterBackground), 
                lineView.gutterBackground = null), lineView.line.gutterClass) {
                    var wrap = ensureLineWrapped(lineView);
                    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"), 
                    wrap.insertBefore(lineView.gutterBackground, lineView.text);
                }
                var markers = lineView.line.gutterMarkers;
                if (cm.options.lineNumbers || markers) {
                    var wrap$1 = ensureLineWrapped(lineView), gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
                    if (cm.display.input.setUneditable(gutterWrap), wrap$1.insertBefore(gutterWrap, lineView.text), 
                    lineView.line.gutterClass && (gutterWrap.className += " " + lineView.line.gutterClass), 
                    !cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"))), 
                    markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
                        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                        found && gutterWrap.appendChild(elt("div", [ found ], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
                    }
                }
            }
            function updateLineWidgets(cm, lineView, dims) {
                lineView.alignable && (lineView.alignable = null);
                for (var node = lineView.node.firstChild, next = void 0; node; node = next) next = node.nextSibling, 
                "CodeMirror-linewidget" == node.className && lineView.node.removeChild(node);
                insertLineWidgets(cm, lineView, dims);
            }
            // Build a line's DOM representation from scratch
            function buildLineElement(cm, lineView, lineN, dims) {
                var built = getLineContent(cm, lineView);
                return lineView.text = lineView.node = built.pre, built.bgClass && (lineView.bgClass = built.bgClass), 
                built.textClass && (lineView.textClass = built.textClass), updateLineClasses(lineView), 
                updateLineGutter(cm, lineView, lineN, dims), insertLineWidgets(cm, lineView, dims), 
                lineView.node;
            }
            // A lineView may contain multiple logical lines (when merged by
            // collapsed spans). The widgets for all of them need to be drawn.
            function insertLineWidgets(cm, lineView, dims) {
                if (insertLineWidgetsFor(cm, lineView.line, lineView, dims, !0), lineView.rest) for (var i = 0; i < lineView.rest.length; i++) insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, !1);
            }
            function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
                if (line.widgets) for (var wrap = ensureLineWrapped(lineView), i = 0, ws = line.widgets; i < ws.length; ++i) {
                    var widget = ws[i], node = elt("div", [ widget.node ], "CodeMirror-linewidget");
                    widget.handleMouseEvents || node.setAttribute("cm-ignore-events", "true"), positionLineWidget(widget, node, lineView, dims), 
                    cm.display.input.setUneditable(node), allowAbove && widget.above ? wrap.insertBefore(node, lineView.gutter || lineView.text) : wrap.appendChild(node), 
                    signalLater(widget, "redraw");
                }
            }
            function positionLineWidget(widget, node, lineView, dims) {
                if (widget.noHScroll) {
                    (lineView.alignable || (lineView.alignable = [])).push(node);
                    var width = dims.wrapperWidth;
                    node.style.left = dims.fixedPos + "px", widget.coverGutter || (width -= dims.gutterTotalWidth, 
                    node.style.paddingLeft = dims.gutterTotalWidth + "px"), node.style.width = width + "px";
                }
                widget.coverGutter && (node.style.zIndex = 5, node.style.position = "relative", 
                widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px"));
            }
            function widgetHeight(widget) {
                if (null != widget.height) return widget.height;
                var cm = widget.doc.cm;
                if (!cm) return 0;
                if (!contains(document.body, widget.node)) {
                    var parentStyle = "position: relative;";
                    widget.coverGutter && (parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"), 
                    widget.noHScroll && (parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"), 
                    removeChildrenAndAdd(cm.display.measure, elt("div", [ widget.node ], null, parentStyle));
                }
                return widget.height = widget.node.parentNode.offsetHeight;
            }
            // Return true when the given mouse event happened in a widget
            function eventInWidget(display, e) {
                for (var n = e_target(e); n != display.wrapper; n = n.parentNode) if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == display.sizer && n != display.mover) return !0;
            }
            // POSITION MEASUREMENT
            function paddingTop(display) {
                return display.lineSpace.offsetTop;
            }
            function paddingVert(display) {
                return display.mover.offsetHeight - display.lineSpace.offsetHeight;
            }
            function paddingH(display) {
                if (display.cachedPaddingH) return display.cachedPaddingH;
                var e = removeChildrenAndAdd(display.measure, elt("pre", "x")), style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle, data = {
                    left: parseInt(style.paddingLeft),
                    right: parseInt(style.paddingRight)
                };
                return isNaN(data.left) || isNaN(data.right) || (display.cachedPaddingH = data), 
                data;
            }
            function scrollGap(cm) {
                return scrollerGap - cm.display.nativeBarWidth;
            }
            function displayWidth(cm) {
                return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
            }
            function displayHeight(cm) {
                return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
            }
            // Ensure the lineView.wrapping.heights array is populated. This is
            // an array of bottom offsets for the lines that make up a drawn
            // line. When lineWrapping is on, there might be more than one
            // height.
            function ensureLineHeights(cm, lineView, rect) {
                var wrapping = cm.options.lineWrapping, curWidth = wrapping && displayWidth(cm);
                if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
                    var heights = lineView.measure.heights = [];
                    if (wrapping) {
                        lineView.measure.width = curWidth;
                        for (var rects = lineView.text.firstChild.getClientRects(), i = 0; i < rects.length - 1; i++) {
                            var cur = rects[i], next = rects[i + 1];
                            Math.abs(cur.bottom - next.bottom) > 2 && heights.push((cur.bottom + next.top) / 2 - rect.top);
                        }
                    }
                    heights.push(rect.bottom - rect.top);
                }
            }
            // Find a line map (mapping character offsets to text nodes) and a
            // measurement cache for the given line number. (A line view might
            // contain multiple lines when collapsed ranges are present.)
            function mapFromLineView(lineView, line, lineN) {
                if (lineView.line == line) return {
                    map: lineView.measure.map,
                    cache: lineView.measure.cache
                };
                for (var i = 0; i < lineView.rest.length; i++) if (lineView.rest[i] == line) return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i]
                };
                for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) if (lineNo(lineView.rest[i$1]) > lineN) return {
                    map: lineView.measure.maps[i$1],
                    cache: lineView.measure.caches[i$1],
                    before: !0
                };
            }
            // Render a line into the hidden node display.externalMeasured. Used
            // when measurement is needed for a line that's not in the viewport.
            function updateExternalMeasurement(cm, line) {
                line = visualLine(line);
                var lineN = lineNo(line), view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
                view.lineN = lineN;
                var built = view.built = buildLineContent(cm, view);
                return view.text = built.pre, removeChildrenAndAdd(cm.display.lineMeasure, built.pre), 
                view;
            }
            // Get a {top, bottom, left, right} box (in line-local coordinates)
            // for a given character.
            function measureChar(cm, line, ch, bias) {
                return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
            }
            // Find a line view that corresponds to the given line number.
            function findViewForLine(cm, lineN) {
                if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) return cm.display.view[findViewIndex(cm, lineN)];
                var ext = cm.display.externalMeasured;
                return ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size ? ext : void 0;
            }
            // Measurement can be split in two steps, the set-up work that
            // applies to the whole line, and the measurement of the actual
            // character. Functions like coordsChar, that need to do a lot of
            // measurements in a row, can thus ensure that the set-up work is
            // only done once.
            function prepareMeasureForLine(cm, line) {
                var lineN = lineNo(line), view = findViewForLine(cm, lineN);
                view && !view.text ? view = null : view && view.changes && (updateLineForChanges(cm, view, lineN, getDimensions(cm)), 
                cm.curOp.forceUpdate = !0), view || (view = updateExternalMeasurement(cm, line));
                var info = mapFromLineView(view, line, lineN);
                return {
                    line: line,
                    view: view,
                    rect: null,
                    map: info.map,
                    cache: info.cache,
                    before: info.before,
                    hasHeights: !1
                };
            }
            // Given a prepared measurement object, measures the position of an
            // actual character (or fetches it from the cache).
            function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
                prepared.before && (ch = -1);
                var found, key = ch + (bias || "");
                return prepared.cache.hasOwnProperty(key) ? found = prepared.cache[key] : (prepared.rect || (prepared.rect = prepared.view.text.getBoundingClientRect()), 
                prepared.hasHeights || (ensureLineHeights(cm, prepared.view, prepared.rect), prepared.hasHeights = !0), 
                found = measureCharInner(cm, prepared, ch, bias), found.bogus || (prepared.cache[key] = found)), 
                {
                    left: found.left,
                    right: found.right,
                    top: varHeight ? found.rtop : found.top,
                    bottom: varHeight ? found.rbottom : found.bottom
                };
            }
            function nodeAndOffsetInLineMap(map, ch, bias) {
                // First, search the line map for the text node corresponding to,
                // or closest to, the target character.
                for (var node, start, end, collapse, mStart, mEnd, i = 0; i < map.length; i += 3) if (mStart = map[i], 
                mEnd = map[i + 1], ch < mStart ? (start = 0, end = 1, collapse = "left") : ch < mEnd ? (start = ch - mStart, 
                end = start + 1) : (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) && (end = mEnd - mStart, 
                start = end - 1, ch >= mEnd && (collapse = "right")), null != start) {
                    if (node = map[i + 2], mStart == mEnd && bias == (node.insertLeft ? "left" : "right") && (collapse = bias), 
                    "left" == bias && 0 == start) for (;i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft; ) node = map[(i -= 3) + 2], 
                    collapse = "left";
                    if ("right" == bias && start == mEnd - mStart) for (;i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft; ) node = map[(i += 3) + 2], 
                    collapse = "right";
                    break;
                }
                return {
                    node: node,
                    start: start,
                    end: end,
                    collapse: collapse,
                    coverStart: mStart,
                    coverEnd: mEnd
                };
            }
            function getUsefulRect(rects, bias) {
                var rect = nullRect;
                if ("left" == bias) for (var i = 0; i < rects.length && (rect = rects[i]).left == rect.right; i++) ; else for (var i$1 = rects.length - 1; i$1 >= 0 && (rect = rects[i$1]).left == rect.right; i$1--) ;
                return rect;
            }
            function measureCharInner(cm, prepared, ch, bias) {
                var rect, place = nodeAndOffsetInLineMap(prepared.map, ch, bias), node = place.node, start = place.start, end = place.end, collapse = place.collapse;
                if (3 == node.nodeType) {
                    // If it is a text node, use a range to retrieve the coordinates.
                    for (var i$1 = 0; i$1 < 4; i$1++) {
                        // Retry a maximum of 4 times when nonsense rectangles are returned
                        for (;start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start)); ) --start;
                        for (;place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end)); ) ++end;
                        if (rect = ie && ie_version < 9 && 0 == start && end == place.coverEnd - place.coverStart ? node.parentNode.getBoundingClientRect() : getUsefulRect(range(node, start, end).getClientRects(), bias), 
                        rect.left || rect.right || 0 == start) break;
                        end = start, start -= 1, collapse = "right";
                    }
                    ie && ie_version < 11 && (rect = maybeUpdateRectForZooming(cm.display.measure, rect));
                } else {
                    // If it is a widget, simply get the box for the whole widget.
                    start > 0 && (collapse = bias = "right");
                    var rects;
                    rect = cm.options.lineWrapping && (rects = node.getClientRects()).length > 1 ? rects["right" == bias ? rects.length - 1 : 0] : node.getBoundingClientRect();
                }
                if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
                    var rSpan = node.parentNode.getClientRects()[0];
                    rect = rSpan ? {
                        left: rSpan.left,
                        right: rSpan.left + charWidth(cm.display),
                        top: rSpan.top,
                        bottom: rSpan.bottom
                    } : nullRect;
                }
                for (var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top, mid = (rtop + rbot) / 2, heights = prepared.view.measure.heights, i = 0; i < heights.length - 1 && !(mid < heights[i]); i++) ;
                var top = i ? heights[i - 1] : 0, bot = heights[i], result = {
                    left: ("right" == collapse ? rect.right : rect.left) - prepared.rect.left,
                    right: ("left" == collapse ? rect.left : rect.right) - prepared.rect.left,
                    top: top,
                    bottom: bot
                };
                return rect.left || rect.right || (result.bogus = !0), cm.options.singleCursorHeightPerLine || (result.rtop = rtop, 
                result.rbottom = rbot), result;
            }
            // Work around problem with bounding client rects on ranges being
            // returned incorrectly when zoomed on IE10 and below.
            function maybeUpdateRectForZooming(measure, rect) {
                if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) return rect;
                var scaleX = screen.logicalXDPI / screen.deviceXDPI, scaleY = screen.logicalYDPI / screen.deviceYDPI;
                return {
                    left: rect.left * scaleX,
                    right: rect.right * scaleX,
                    top: rect.top * scaleY,
                    bottom: rect.bottom * scaleY
                };
            }
            function clearLineMeasurementCacheFor(lineView) {
                if (lineView.measure && (lineView.measure.cache = {}, lineView.measure.heights = null, 
                lineView.rest)) for (var i = 0; i < lineView.rest.length; i++) lineView.measure.caches[i] = {};
            }
            function clearLineMeasurementCache(cm) {
                cm.display.externalMeasure = null, removeChildren(cm.display.lineMeasure);
                for (var i = 0; i < cm.display.view.length; i++) clearLineMeasurementCacheFor(cm.display.view[i]);
            }
            function clearCaches(cm) {
                clearLineMeasurementCache(cm), cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null, 
                cm.options.lineWrapping || (cm.display.maxLineChanged = !0), cm.display.lineNumChars = null;
            }
            function pageScrollX() {
                return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
            }
            function pageScrollY() {
                return window.pageYOffset || (document.documentElement || document.body).scrollTop;
            }
            // Converts a {top, bottom, left, right} box from line-local
            // coordinates into another coordinate system. Context may be one of
            // "line", "div" (display.lineDiv), "local"./null (editor), "window",
            // or "page".
            function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
                if (!includeWidgets && lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
                    var size = widgetHeight(lineObj.widgets[i]);
                    rect.top += size, rect.bottom += size;
                }
                if ("line" == context) return rect;
                context || (context = "local");
                var yOff = heightAtLine(lineObj);
                if ("local" == context ? yOff += paddingTop(cm.display) : yOff -= cm.display.viewOffset, 
                "page" == context || "window" == context) {
                    var lOff = cm.display.lineSpace.getBoundingClientRect();
                    yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
                    var xOff = lOff.left + ("window" == context ? 0 : pageScrollX());
                    rect.left += xOff, rect.right += xOff;
                }
                return rect.top += yOff, rect.bottom += yOff, rect;
            }
            // Coverts a box from "div" coords to another coordinate system.
            // Context may be "window", "page", "div", or "local"./null.
            function fromCoordSystem(cm, coords, context) {
                if ("div" == context) return coords;
                var left = coords.left, top = coords.top;
                // First move into "page" coordinate system
                if ("page" == context) left -= pageScrollX(), top -= pageScrollY(); else if ("local" == context || !context) {
                    var localBox = cm.display.sizer.getBoundingClientRect();
                    left += localBox.left, top += localBox.top;
                }
                var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
                return {
                    left: left - lineSpaceBox.left,
                    top: top - lineSpaceBox.top
                };
            }
            function charCoords(cm, pos, context, lineObj, bias) {
                return lineObj || (lineObj = getLine(cm.doc, pos.line)), intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
            }
            // Returns a box for a given cursor position, which may have an
            // 'other' property containing the position of the secondary cursor
            // on a bidi boundary.
            // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
            // and after `char - 1` in writing order of `char - 1`
            // A cursor Pos(line, char, "after") is on the same visual line as `char`
            // and before `char` in writing order of `char`
            // Examples (upper-case letters are RTL, lower-case are LTR):
            //     Pos(0, 1, ...)
            //     before   after
            // ab     a|b     a|b
            // aB     a|B     aB|
            // Ab     |Ab     A|b
            // AB     B|A     B|A
            // Every position after the last character on a line is considered to stick
            // to the last character on the line.
            function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
                function get(ch, right) {
                    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
                    return right ? m.left = m.right : m.right = m.left, intoCoordSystem(cm, lineObj, m, context);
                }
                function getBidi(ch, partPos, invert) {
                    var part = order[partPos], right = part.level % 2 != 0;
                    return get(invert ? ch - 1 : ch, right != invert);
                }
                lineObj = lineObj || getLine(cm.doc, pos.line), preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
                var order = getOrder(lineObj), ch = pos.ch, sticky = pos.sticky;
                if (ch >= lineObj.text.length ? (ch = lineObj.text.length, sticky = "before") : ch <= 0 && (ch = 0, 
                sticky = "after"), !order) return get("before" == sticky ? ch - 1 : ch, "before" == sticky);
                var partPos = getBidiPartAt(order, ch, sticky), other = bidiOther, val = getBidi(ch, partPos, "before" == sticky);
                return null != other && (val.other = getBidi(ch, other, "before" != sticky)), val;
            }
            // Used to cheaply estimate the coordinates for a position. Used for
            // intermediate scroll updates.
            function estimateCoords(cm, pos) {
                var left = 0;
                pos = clipPos(cm.doc, pos), cm.options.lineWrapping || (left = charWidth(cm.display) * pos.ch);
                var lineObj = getLine(cm.doc, pos.line), top = heightAtLine(lineObj) + paddingTop(cm.display);
                return {
                    left: left,
                    right: left,
                    top: top,
                    bottom: top + lineObj.height
                };
            }
            // Positions returned by coordsChar contain some extra information.
            // xRel is the relative x position of the input coordinates compared
            // to the found position (so xRel > 0 means the coordinates are to
            // the right of the character position, for example). When outside
            // is true, that means the coordinates lie outside the line's
            // vertical range.
            function PosWithInfo(line, ch, sticky, outside, xRel) {
                var pos = Pos(line, ch, sticky);
                return pos.xRel = xRel, outside && (pos.outside = !0), pos;
            }
            // Compute the character position closest to the given coordinates.
            // Input must be lineSpace-local ("div" coordinate system).
            function coordsChar(cm, x, y) {
                var doc = cm.doc;
                if (y += cm.display.viewOffset, y < 0) return PosWithInfo(doc.first, 0, null, !0, -1);
                var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
                if (lineN > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, !0, 1);
                x < 0 && (x = 0);
                for (var lineObj = getLine(doc, lineN); ;) {
                    var found = coordsCharInner(cm, lineObj, lineN, x, y), merged = collapsedSpanAtEnd(lineObj), mergedPos = merged && merged.find(0, !0);
                    if (!merged || !(found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) return found;
                    lineN = lineNo(lineObj = mergedPos.to.line);
                }
            }
            function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
                var measure = function(ch) {
                    return intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), "line");
                }, end = lineObj.text.length, begin = findFirst(function(ch) {
                    return measure(ch - 1).bottom <= y;
                }, end, 0);
                return end = findFirst(function(ch) {
                    return measure(ch).top > y;
                }, begin, end), {
                    begin: begin,
                    end: end
                };
            }
            function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
                var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
                return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
            }
            function coordsCharInner(cm, lineObj, lineNo, x, y) {
                y -= heightAtLine(lineObj);
                var pos, begin = 0, end = lineObj.text.length, preparedMeasure = prepareMeasureForLine(cm, lineObj), order = getOrder(lineObj);
                if (order) {
                    if (cm.options.lineWrapping) {
                        var assign;
                        assign = wrappedLineExtent(cm, lineObj, preparedMeasure, y), begin = assign.begin, 
                        end = assign.end, assign;
                    }
                    pos = new Pos(lineNo, begin);
                    var prevDiff, prevPos, beginLeft = cursorCoords(cm, pos, "line", lineObj, preparedMeasure).left, dir = beginLeft < x ? 1 : -1, diff = beginLeft - x;
                    do {
                        if (prevDiff = diff, prevPos = pos, pos = moveVisually(cm, lineObj, pos, dir), null == pos || pos.ch < begin || end <= ("before" == pos.sticky ? pos.ch - 1 : pos.ch)) {
                            pos = prevPos;
                            break;
                        }
                        diff = cursorCoords(cm, pos, "line", lineObj, preparedMeasure).left - x;
                    } while (dir < 0 != diff < 0 && Math.abs(diff) <= Math.abs(prevDiff));
                    if (Math.abs(diff) > Math.abs(prevDiff)) {
                        if (diff < 0 == prevDiff < 0) throw new Error("Broke out of infinite loop in coordsCharInner");
                        pos = prevPos;
                    }
                } else {
                    var ch = findFirst(function(ch) {
                        var box = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, ch), "line");
                        // For the cursor stickiness
                        return box.top > y ? (end = Math.min(ch, end), !0) : !(box.bottom <= y) && (box.left > x || !(box.right < x) && x - box.left < box.right - x);
                    }, begin, end);
                    ch = skipExtendingChars(lineObj.text, ch, 1), pos = new Pos(lineNo, ch, ch == end ? "before" : "after");
                }
                var coords = cursorCoords(cm, pos, "line", lineObj, preparedMeasure);
                return (y < coords.top || coords.bottom < y) && (pos.outside = !0), pos.xRel = x < coords.left ? -1 : x > coords.right ? 1 : 0, 
                pos;
            }
            // Compute the default text height.
            function textHeight(display) {
                if (null != display.cachedTextHeight) return display.cachedTextHeight;
                if (null == measureText) {
                    measureText = elt("pre");
                    // Measure a bunch of lines, for browsers that compute
                    // fractional heights.
                    for (var i = 0; i < 49; ++i) measureText.appendChild(document.createTextNode("x")), 
                    measureText.appendChild(elt("br"));
                    measureText.appendChild(document.createTextNode("x"));
                }
                removeChildrenAndAdd(display.measure, measureText);
                var height = measureText.offsetHeight / 50;
                return height > 3 && (display.cachedTextHeight = height), removeChildren(display.measure), 
                height || 1;
            }
            // Compute the default character width.
            function charWidth(display) {
                if (null != display.cachedCharWidth) return display.cachedCharWidth;
                var anchor = elt("span", "xxxxxxxxxx"), pre = elt("pre", [ anchor ]);
                removeChildrenAndAdd(display.measure, pre);
                var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
                return width > 2 && (display.cachedCharWidth = width), width || 10;
            }
            // Do a bulk-read of the DOM positions and sizes needed to draw the
            // view, so that we don't interleave reading and writing to the DOM.
            function getDimensions(cm) {
                for (var d = cm.display, left = {}, width = {}, gutterLeft = d.gutters.clientLeft, n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, 
                ++i) left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft, width[cm.options.gutters[i]] = n.clientWidth;
                return {
                    fixedPos: compensateForHScroll(d),
                    gutterTotalWidth: d.gutters.offsetWidth,
                    gutterLeft: left,
                    gutterWidth: width,
                    wrapperWidth: d.wrapper.clientWidth
                };
            }
            // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
            // but using getBoundingClientRect to get a sub-pixel-accurate
            // result.
            function compensateForHScroll(display) {
                return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
            }
            // Returns a function that estimates the height of a line, to use as
            // first approximation until the line becomes visible (and is thus
            // properly measurable).
            function estimateHeight(cm) {
                var th = textHeight(cm.display), wrapping = cm.options.lineWrapping, perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
                return function(line) {
                    if (lineIsHidden(cm.doc, line)) return 0;
                    var widgetsHeight = 0;
                    if (line.widgets) for (var i = 0; i < line.widgets.length; i++) line.widgets[i].height && (widgetsHeight += line.widgets[i].height);
                    return wrapping ? widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th : widgetsHeight + th;
                };
            }
            function estimateLineHeights(cm) {
                var doc = cm.doc, est = estimateHeight(cm);
                doc.iter(function(line) {
                    var estHeight = est(line);
                    estHeight != line.height && updateLineHeight(line, estHeight);
                });
            }
            // Given a mouse event, find the corresponding position. If liberal
            // is false, it checks whether a gutter or scrollbar was clicked,
            // and returns null if it was. forRect is used by rectangular
            // selections, and tries to estimate a character position even for
            // coordinates beyond the right of the text.
            function posFromMouse(cm, e, liberal, forRect) {
                var display = cm.display;
                if (!liberal && "true" == e_target(e).getAttribute("cm-not-content")) return null;
                var x, y, space = display.lineSpace.getBoundingClientRect();
                // Fails unpredictably on IE[67] when mouse is dragged around quickly.
                try {
                    x = e.clientX - space.left, y = e.clientY - space.top;
                } catch (e) {
                    return null;
                }
                var line, coords = coordsChar(cm, x, y);
                if (forRect && 1 == coords.xRel && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
                    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
                    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
                }
                return coords;
            }
            // Find the view element corresponding to a given line. Return null
            // when the line isn't visible.
            function findViewIndex(cm, n) {
                if (n >= cm.display.viewTo) return null;
                if (n -= cm.display.viewFrom, n < 0) return null;
                for (var view = cm.display.view, i = 0; i < view.length; i++) if (n -= view[i].size, 
                n < 0) return i;
            }
            function updateSelection(cm) {
                cm.display.input.showSelection(cm.display.input.prepareSelection());
            }
            function prepareSelection(cm, primary) {
                for (var doc = cm.doc, result = {}, curFragment = result.cursors = document.createDocumentFragment(), selFragment = result.selection = document.createDocumentFragment(), i = 0; i < doc.sel.ranges.length; i++) if (primary !== !1 || i != doc.sel.primIndex) {
                    var range = doc.sel.ranges[i];
                    if (!(range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom)) {
                        var collapsed = range.empty();
                        (collapsed || cm.options.showCursorWhenSelecting) && drawSelectionCursor(cm, range.head, curFragment), 
                        collapsed || drawSelectionRange(cm, range, selFragment);
                    }
                }
                return result;
            }
            // Draws a cursor for the given range
            function drawSelectionCursor(cm, head, output) {
                var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine), cursor = output.appendChild(elt("div", "", "CodeMirror-cursor"));
                if (cursor.style.left = pos.left + "px", cursor.style.top = pos.top + "px", cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px", 
                pos.other) {
                    // Secondary cursor, shown when on a 'jump' in bi-directional text
                    var otherCursor = output.appendChild(elt("div", "", "CodeMirror-cursor CodeMirror-secondarycursor"));
                    otherCursor.style.display = "", otherCursor.style.left = pos.other.left + "px", 
                    otherCursor.style.top = pos.other.top + "px", otherCursor.style.height = .85 * (pos.other.bottom - pos.other.top) + "px";
                }
            }
            // Draws the given range as a highlighted selection
            function drawSelectionRange(cm, range, output) {
                function add(left, top, width, bottom) {
                    top < 0 && (top = 0), top = Math.round(top), bottom = Math.round(bottom), fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (null == width ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
                }
                function drawForLine(line, fromArg, toArg) {
                    function coords(ch, bias) {
                        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
                    }
                    var start, end, lineObj = getLine(doc, line), lineLen = lineObj.text.length;
                    return iterateBidiSections(getOrder(lineObj), fromArg || 0, null == toArg ? lineLen : toArg, function(from, to, dir) {
                        var rightPos, left, right, leftPos = coords(from, "left");
                        if (from == to) rightPos = leftPos, left = right = leftPos.left; else {
                            if (rightPos = coords(to - 1, "right"), "rtl" == dir) {
                                var tmp = leftPos;
                                leftPos = rightPos, rightPos = tmp;
                            }
                            left = leftPos.left, right = rightPos.right;
                        }
                        null == fromArg && 0 == from && (left = leftSide), rightPos.top - leftPos.top > 3 && (// Different lines, draw top part
                        add(left, leftPos.top, null, leftPos.bottom), left = leftSide, leftPos.bottom < rightPos.top && add(left, leftPos.bottom, null, rightPos.top)), 
                        null == toArg && to == lineLen && (right = rightSide), (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) && (start = leftPos), 
                        (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) && (end = rightPos), 
                        left < leftSide + 1 && (left = leftSide), add(left, rightPos.top, right - left, rightPos.bottom);
                    }), {
                        start: start,
                        end: end
                    };
                }
                var display = cm.display, doc = cm.doc, fragment = document.createDocumentFragment(), padding = paddingH(cm.display), leftSide = padding.left, rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right, sFrom = range.from(), sTo = range.to();
                if (sFrom.line == sTo.line) drawForLine(sFrom.line, sFrom.ch, sTo.ch); else {
                    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line), singleVLine = visualLine(fromLine) == visualLine(toLine), leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end, rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
                    singleVLine && (leftEnd.top < rightStart.top - 2 ? (add(leftEnd.right, leftEnd.top, null, leftEnd.bottom), 
                    add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)) : add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)), 
                    leftEnd.bottom < rightStart.top && add(leftSide, leftEnd.bottom, null, rightStart.top);
                }
                output.appendChild(fragment);
            }
            // Cursor-blinking
            function restartBlink(cm) {
                if (cm.state.focused) {
                    var display = cm.display;
                    clearInterval(display.blinker);
                    var on = !0;
                    display.cursorDiv.style.visibility = "", cm.options.cursorBlinkRate > 0 ? display.blinker = setInterval(function() {
                        return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
                    }, cm.options.cursorBlinkRate) : cm.options.cursorBlinkRate < 0 && (display.cursorDiv.style.visibility = "hidden");
                }
            }
            function ensureFocus(cm) {
                cm.state.focused || (cm.display.input.focus(), onFocus(cm));
            }
            function delayBlurEvent(cm) {
                cm.state.delayingBlurEvent = !0, setTimeout(function() {
                    cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1, onBlur(cm));
                }, 100);
            }
            function onFocus(cm, e) {
                cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1), "nocursor" != cm.options.readOnly && (cm.state.focused || (signal(cm, "focus", cm, e), 
                cm.state.focused = !0, addClass(cm.display.wrapper, "CodeMirror-focused"), // This test prevents this from firing when a context
                // menu is closed (since the input reset would kill the
                // select-all detection hack)
                cm.curOp || cm.display.selForContextMenu == cm.doc.sel || (cm.display.input.reset(), 
                webkit && setTimeout(function() {
                    return cm.display.input.reset(!0);
                }, 20)), cm.display.input.receivedFocus()), restartBlink(cm));
            }
            function onBlur(cm, e) {
                cm.state.delayingBlurEvent || (cm.state.focused && (signal(cm, "blur", cm, e), cm.state.focused = !1, 
                rmClass(cm.display.wrapper, "CodeMirror-focused")), clearInterval(cm.display.blinker), 
                setTimeout(function() {
                    cm.state.focused || (cm.display.shift = !1);
                }, 150));
            }
            // Re-align line numbers and gutter marks to compensate for
            // horizontal scrolling.
            function alignHorizontally(cm) {
                var display = cm.display, view = display.view;
                if (display.alignWidgets || display.gutters.firstChild && cm.options.fixedGutter) {
                    for (var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft, gutterW = display.gutters.offsetWidth, left = comp + "px", i = 0; i < view.length; i++) if (!view[i].hidden) {
                        cm.options.fixedGutter && (view[i].gutter && (view[i].gutter.style.left = left), 
                        view[i].gutterBackground && (view[i].gutterBackground.style.left = left));
                        var align = view[i].alignable;
                        if (align) for (var j = 0; j < align.length; j++) align[j].style.left = left;
                    }
                    cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px");
                }
            }
            // Used to ensure that the line number gutter is still the right
            // size for the current document size. Returns true when an update
            // is needed.
            function maybeUpdateLineNumberWidth(cm) {
                if (!cm.options.lineNumbers) return !1;
                var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
                if (last.length != display.lineNumChars) {
                    var test = display.measure.appendChild(elt("div", [ elt("div", last) ], "CodeMirror-linenumber CodeMirror-gutter-elt")), innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
                    return display.lineGutter.style.width = "", display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1, 
                    display.lineNumWidth = display.lineNumInnerWidth + padding, display.lineNumChars = display.lineNumInnerWidth ? last.length : -1, 
                    display.lineGutter.style.width = display.lineNumWidth + "px", updateGutterSpace(cm), 
                    !0;
                }
                return !1;
            }
            // Read the actual heights of the rendered lines, and update their
            // stored heights to match.
            function updateHeightsInViewport(cm) {
                for (var display = cm.display, prevBottom = display.lineDiv.offsetTop, i = 0; i < display.view.length; i++) {
                    var cur = display.view[i], height = void 0;
                    if (!cur.hidden) {
                        if (ie && ie_version < 8) {
                            var bot = cur.node.offsetTop + cur.node.offsetHeight;
                            height = bot - prevBottom, prevBottom = bot;
                        } else {
                            var box = cur.node.getBoundingClientRect();
                            height = box.bottom - box.top;
                        }
                        var diff = cur.line.height - height;
                        if (height < 2 && (height = textHeight(display)), (diff > .001 || diff < -.001) && (updateLineHeight(cur.line, height), 
                        updateWidgetHeight(cur.line), cur.rest)) for (var j = 0; j < cur.rest.length; j++) updateWidgetHeight(cur.rest[j]);
                    }
                }
            }
            // Read and store the height of line widgets associated with the
            // given line.
            function updateWidgetHeight(line) {
                if (line.widgets) for (var i = 0; i < line.widgets.length; ++i) line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;
            }
            // Compute the lines that are visible in a given viewport (defaults
            // the the current scroll position). viewport may contain top,
            // height, and ensure (see op.scrollToPos) properties.
            function visibleLines(display, doc, viewport) {
                var top = viewport && null != viewport.top ? Math.max(0, viewport.top) : display.scroller.scrollTop;
                top = Math.floor(top - paddingTop(display));
                var bottom = viewport && null != viewport.bottom ? viewport.bottom : top + display.wrapper.clientHeight, from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
                // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
                // forces those lines into the viewport (if possible).
                if (viewport && viewport.ensure) {
                    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
                    ensureFrom < from ? (from = ensureFrom, to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)) : Math.min(ensureTo, doc.lastLine()) >= to && (from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight), 
                    to = ensureTo);
                }
                return {
                    from: from,
                    to: Math.max(to, from + 1)
                };
            }
            // Sync the scrollable area and scrollbars, ensure the viewport
            // covers the visible area.
            function setScrollTop(cm, val) {
                Math.abs(cm.doc.scrollTop - val) < 2 || (cm.doc.scrollTop = val, gecko || updateDisplaySimple(cm, {
                    top: val
                }), cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val), 
                cm.display.scrollbars.setScrollTop(val), gecko && updateDisplaySimple(cm), startWorker(cm, 100));
            }
            // Sync scroller and scrollbar, ensure the gutter elements are
            // aligned.
            function setScrollLeft(cm, val, isScroller) {
                (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) || (val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth), 
                cm.doc.scrollLeft = val, alignHorizontally(cm), cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val), 
                cm.display.scrollbars.setScrollLeft(val));
            }
            function wheelEventDelta(e) {
                var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
                return null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail), 
                null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta), 
                {
                    x: dx,
                    y: dy
                };
            }
            function wheelEventPixels(e) {
                var delta = wheelEventDelta(e);
                return delta.x *= wheelPixelsPerUnit, delta.y *= wheelPixelsPerUnit, delta;
            }
            function onScrollWheel(cm, e) {
                var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y, display = cm.display, scroll = display.scroller, canScrollX = scroll.scrollWidth > scroll.clientWidth, canScrollY = scroll.scrollHeight > scroll.clientHeight;
                if (dx && canScrollX || dy && canScrollY) {
                    // Webkit browsers on OS X abort momentum scrolls when the target
                    // of the scroll event is removed from the scrollable element.
                    // This hack (see related code in patchDisplay) makes sure the
                    // element is kept around.
                    if (dy && mac && webkit) outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) for (var i = 0; i < view.length; i++) if (view[i].node == cur) {
                        cm.display.currentWheelTarget = cur;
                        break outer;
                    }
                    // On some browsers, horizontal scrolling will cause redraws to
                    // happen before the gutter has been realigned, causing it to
                    // wriggle around in a most unseemly way. When we have an
                    // estimated pixels/delta value, we just handle horizontal
                    // scrolling entirely here. It'll be slightly off from native, but
                    // better than glitching out.
                    if (dx && !gecko && !presto && null != wheelPixelsPerUnit) // Abort measurement, if in progress
                    // Only prevent default scrolling if vertical scrolling is
                    // actually possible. Otherwise, it causes vertical scroll
                    // jitter on OSX trackpads when deltaX is small and deltaY
                    // is large (issue #3579)
                    return dy && canScrollY && setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight))), 
                    setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth))), 
                    (!dy || dy && canScrollY) && e_preventDefault(e), void (display.wheelStartX = null);
                    // 'Project' the visible viewport to cover the area that is being
                    // scrolled into view (if we know enough to estimate it).
                    if (dy && null != wheelPixelsPerUnit) {
                        var pixels = dy * wheelPixelsPerUnit, top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
                        pixels < 0 ? top = Math.max(0, top + pixels - 50) : bot = Math.min(cm.doc.height, bot + pixels + 50), 
                        updateDisplaySimple(cm, {
                            top: top,
                            bottom: bot
                        });
                    }
                    wheelSamples < 20 && (null == display.wheelStartX ? (display.wheelStartX = scroll.scrollLeft, 
                    display.wheelStartY = scroll.scrollTop, display.wheelDX = dx, display.wheelDY = dy, 
                    setTimeout(function() {
                        if (null != display.wheelStartX) {
                            var movedX = scroll.scrollLeft - display.wheelStartX, movedY = scroll.scrollTop - display.wheelStartY, sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                            display.wheelStartX = display.wheelStartY = null, sample && (wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1), 
                            ++wheelSamples);
                        }
                    }, 200)) : (display.wheelDX += dx, display.wheelDY += dy));
                }
            }
            // SCROLLBARS
            // Prepare DOM reads needed to update the scrollbars. Done in one
            // shot to minimize update/measure roundtrips.
            function measureForScrollbars(cm) {
                var d = cm.display, gutterW = d.gutters.offsetWidth, docH = Math.round(cm.doc.height + paddingVert(cm.display));
                return {
                    clientHeight: d.scroller.clientHeight,
                    viewHeight: d.wrapper.clientHeight,
                    scrollWidth: d.scroller.scrollWidth,
                    clientWidth: d.scroller.clientWidth,
                    viewWidth: d.wrapper.clientWidth,
                    barLeft: cm.options.fixedGutter ? gutterW : 0,
                    docHeight: docH,
                    scrollHeight: docH + scrollGap(cm) + d.barHeight,
                    nativeBarWidth: d.nativeBarWidth,
                    gutterWidth: gutterW
                };
            }
            function updateScrollbars(cm, measure) {
                measure || (measure = measureForScrollbars(cm));
                var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
                updateScrollbarsInner(cm, measure);
                for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) startWidth != cm.display.barWidth && cm.options.lineWrapping && updateHeightsInViewport(cm), 
                updateScrollbarsInner(cm, measureForScrollbars(cm)), startWidth = cm.display.barWidth, 
                startHeight = cm.display.barHeight;
            }
            // Re-synchronize the fake scrollbars with the actual size of the
            // content.
            function updateScrollbarsInner(cm, measure) {
                var d = cm.display, sizes = d.scrollbars.update(measure);
                d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px", d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px", 
                d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent", sizes.right && sizes.bottom ? (d.scrollbarFiller.style.display = "block", 
                d.scrollbarFiller.style.height = sizes.bottom + "px", d.scrollbarFiller.style.width = sizes.right + "px") : d.scrollbarFiller.style.display = "", 
                sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter ? (d.gutterFiller.style.display = "block", 
                d.gutterFiller.style.height = sizes.bottom + "px", d.gutterFiller.style.width = measure.gutterWidth + "px") : d.gutterFiller.style.display = "";
            }
            function initScrollbars(cm) {
                cm.display.scrollbars && (cm.display.scrollbars.clear(), cm.display.scrollbars.addClass && rmClass(cm.display.wrapper, cm.display.scrollbars.addClass)), 
                cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
                    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller), // Prevent clicks in the scrollbars from killing focus
                    on(node, "mousedown", function() {
                        cm.state.focused && setTimeout(function() {
                            return cm.display.input.focus();
                        }, 0);
                    }), node.setAttribute("cm-not-content", "true");
                }, function(pos, axis) {
                    "horizontal" == axis ? setScrollLeft(cm, pos) : setScrollTop(cm, pos);
                }, cm), cm.display.scrollbars.addClass && addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
            }
            // SCROLLING THINGS INTO VIEW
            // If an editor sits on the top or bottom of the window, partially
            // scrolled out of view, this ensures that the cursor is visible.
            function maybeScrollWindow(cm, coords) {
                if (!signalDOMEvent(cm, "scrollCursorIntoView")) {
                    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
                    if (coords.top + box.top < 0 ? doScroll = !0 : coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = !1), 
                    null != doScroll && !phantom) {
                        var scrollNode = elt("div", "", null, "position: absolute;\n                         top: " + (coords.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + coords.left + "px; width: 2px;");
                        cm.display.lineSpace.appendChild(scrollNode), scrollNode.scrollIntoView(doScroll), 
                        cm.display.lineSpace.removeChild(scrollNode);
                    }
                }
            }
            // Scroll a given position into view (immediately), verifying that
            // it actually became visible (as line heights are accurately
            // measured, the position of something may 'drift' during drawing).
            function scrollPosIntoView(cm, pos, end, margin) {
                null == margin && (margin = 0);
                for (var coords, limit = 0; limit < 5; limit++) {
                    var changed = !1;
                    coords = cursorCoords(cm, pos);
                    var endCoords = end && end != pos ? cursorCoords(cm, end) : coords, scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin), startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
                    if (null != scrollPos.scrollTop && (setScrollTop(cm, scrollPos.scrollTop), Math.abs(cm.doc.scrollTop - startTop) > 1 && (changed = !0)), 
                    null != scrollPos.scrollLeft && (setScrollLeft(cm, scrollPos.scrollLeft), Math.abs(cm.doc.scrollLeft - startLeft) > 1 && (changed = !0)), 
                    !changed) break;
                }
                return coords;
            }
            // Scroll a given set of coordinates into view (immediately).
            function scrollIntoView(cm, x1, y1, x2, y2) {
                var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
                null != scrollPos.scrollTop && setScrollTop(cm, scrollPos.scrollTop), null != scrollPos.scrollLeft && setScrollLeft(cm, scrollPos.scrollLeft);
            }
            // Calculate a new scroll position needed to scroll the given
            // rectangle into view. Returns an object with scrollTop and
            // scrollLeft properties. When these are undefined, the
            // vertical/horizontal position does not need to be adjusted.
            function calculateScrollPos(cm, x1, y1, x2, y2) {
                var display = cm.display, snapMargin = textHeight(cm.display);
                y1 < 0 && (y1 = 0);
                var screentop = cm.curOp && null != cm.curOp.scrollTop ? cm.curOp.scrollTop : display.scroller.scrollTop, screen = displayHeight(cm), result = {};
                y2 - y1 > screen && (y2 = y1 + screen);
                var docBottom = cm.doc.height + paddingVert(display), atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
                if (y1 < screentop) result.scrollTop = atTop ? 0 : y1; else if (y2 > screentop + screen) {
                    var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
                    newTop != screentop && (result.scrollTop = newTop);
                }
                var screenleft = cm.curOp && null != cm.curOp.scrollLeft ? cm.curOp.scrollLeft : display.scroller.scrollLeft, screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0), tooWide = x2 - x1 > screenw;
                return tooWide && (x2 = x1 + screenw), x1 < 10 ? result.scrollLeft = 0 : x1 < screenleft ? result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10)) : x2 > screenw + screenleft - 3 && (result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw), 
                result;
            }
            // Store a relative adjustment to the scroll position in the current
            // operation (to be applied when the operation finishes).
            function addToScrollPos(cm, left, top) {
                null == left && null == top || resolveScrollToPos(cm), null != left && (cm.curOp.scrollLeft = (null == cm.curOp.scrollLeft ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left), 
                null != top && (cm.curOp.scrollTop = (null == cm.curOp.scrollTop ? cm.doc.scrollTop : cm.curOp.scrollTop) + top);
            }
            // Make sure that at the end of the operation the current cursor is
            // shown.
            function ensureCursorVisible(cm) {
                resolveScrollToPos(cm);
                var cur = cm.getCursor(), from = cur, to = cur;
                cm.options.lineWrapping || (from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur, to = Pos(cur.line, cur.ch + 1)), 
                cm.curOp.scrollToPos = {
                    from: from,
                    to: to,
                    margin: cm.options.cursorScrollMargin,
                    isCursor: !0
                };
            }
            // When an operation has its scrollToPos property set, and another
            // scroll action is applied before the end of the operation, this
            // 'simulates' scrolling that position into view in a cheap way, so
            // that the effect of intermediate scroll commands is not ignored.
            function resolveScrollToPos(cm) {
                var range = cm.curOp.scrollToPos;
                if (range) {
                    cm.curOp.scrollToPos = null;
                    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to), sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
                    cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
                }
            }
            // Start a new operation.
            function startOperation(cm) {
                cm.curOp = {
                    cm: cm,
                    viewChanged: !1,
                    // Flag that indicates that lines might need to be redrawn
                    startHeight: cm.doc.height,
                    // Used to detect need to update scrollbar
                    forceUpdate: !1,
                    // Used to force a redraw
                    updateInput: null,
                    // Whether to reset the input textarea
                    typing: !1,
                    // Whether this reset should be careful to leave existing text (for compositing)
                    changeObjs: null,
                    // Accumulated changes, for firing change events
                    cursorActivityHandlers: null,
                    // Set of handlers to fire cursorActivity on
                    cursorActivityCalled: 0,
                    // Tracks which cursorActivity handlers have been called already
                    selectionChanged: !1,
                    // Whether the selection needs to be redrawn
                    updateMaxLine: !1,
                    // Set when the widest line needs to be determined anew
                    scrollLeft: null,
                    scrollTop: null,
                    // Intermediate scroll position, not pushed to DOM yet
                    scrollToPos: null,
                    // Used to scroll to a specific position
                    focus: !1,
                    id: ++nextOpId
                }, pushOperation(cm.curOp);
            }
            // Finish an operation, updating the display and signalling delayed events
            function endOperation(cm) {
                var op = cm.curOp;
                finishOperation(op, function(group) {
                    for (var i = 0; i < group.ops.length; i++) group.ops[i].cm.curOp = null;
                    endOperations(group);
                });
            }
            // The DOM updates done when an operation finishes are batched so
            // that the minimum number of relayouts are required.
            function endOperations(group) {
                for (var ops = group.ops, i = 0; i < ops.length; i++) endOperation_R1(ops[i]);
                for (var i$1 = 0; i$1 < ops.length; i$1++) endOperation_W1(ops[i$1]);
                for (var i$2 = 0; i$2 < ops.length; i$2++) endOperation_R2(ops[i$2]);
                for (var i$3 = 0; i$3 < ops.length; i$3++) endOperation_W2(ops[i$3]);
                for (var i$4 = 0; i$4 < ops.length; i$4++) endOperation_finish(ops[i$4]);
            }
            function endOperation_R1(op) {
                var cm = op.cm, display = cm.display;
                maybeClipScrollbars(cm), op.updateMaxLine && findMaxLine(cm), op.mustUpdate = op.viewChanged || op.forceUpdate || null != op.scrollTop || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping, 
                op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
                    top: op.scrollTop,
                    ensure: op.scrollToPos
                }, op.forceUpdate);
            }
            function endOperation_W1(op) {
                op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
            }
            function endOperation_R2(op) {
                var cm = op.cm, display = cm.display;
                op.updatedDisplay && updateHeightsInViewport(cm), op.barMeasure = measureForScrollbars(cm), 
                // If the max line changed since it was last measured, measure it,
                // and ensure the document's width matches it.
                // updateDisplay_W2 will use these properties to do the actual resizing
                display.maxLineChanged && !cm.options.lineWrapping && (op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3, 
                cm.display.sizerWidth = op.adjustWidthTo, op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth), 
                op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))), 
                (op.updatedDisplay || op.selectionChanged) && (op.preparedSelection = display.input.prepareSelection(op.focus));
            }
            function endOperation_W2(op) {
                var cm = op.cm;
                null != op.adjustWidthTo && (cm.display.sizer.style.minWidth = op.adjustWidthTo + "px", 
                op.maxScrollLeft < cm.doc.scrollLeft && setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), !0), 
                cm.display.maxLineChanged = !1);
                var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus());
                op.preparedSelection && cm.display.input.showSelection(op.preparedSelection, takeFocus), 
                (op.updatedDisplay || op.startHeight != cm.doc.height) && updateScrollbars(cm, op.barMeasure), 
                op.updatedDisplay && setDocumentHeight(cm, op.barMeasure), op.selectionChanged && restartBlink(cm), 
                cm.state.focused && op.updateInput && cm.display.input.reset(op.typing), takeFocus && ensureFocus(op.cm);
            }
            function endOperation_finish(op) {
                var cm = op.cm, display = cm.display, doc = cm.doc;
                // If we need to scroll a specific position into view, do so.
                if (op.updatedDisplay && postUpdateDisplay(cm, op.update), // Abort mouse wheel delta measurement, when scrolling explicitly
                null == display.wheelStartX || null == op.scrollTop && null == op.scrollLeft && !op.scrollToPos || (display.wheelStartX = display.wheelStartY = null), 
                // Propagate the scroll position to the actual DOM scroller
                null == op.scrollTop || display.scroller.scrollTop == op.scrollTop && !op.forceScroll || (doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop)), 
                display.scrollbars.setScrollTop(doc.scrollTop), display.scroller.scrollTop = doc.scrollTop), 
                null == op.scrollLeft || display.scroller.scrollLeft == op.scrollLeft && !op.forceScroll || (doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft)), 
                display.scrollbars.setScrollLeft(doc.scrollLeft), display.scroller.scrollLeft = doc.scrollLeft, 
                alignHorizontally(cm)), op.scrollToPos) {
                    var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
                    op.scrollToPos.isCursor && cm.state.focused && maybeScrollWindow(cm, coords);
                }
                // Fire events for markers that are hidden/unidden by editing or
                // undoing
                var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
                if (hidden) for (var i = 0; i < hidden.length; ++i) hidden[i].lines.length || signal(hidden[i], "hide");
                if (unhidden) for (var i$1 = 0; i$1 < unhidden.length; ++i$1) unhidden[i$1].lines.length && signal(unhidden[i$1], "unhide");
                display.wrapper.offsetHeight && (doc.scrollTop = cm.display.scroller.scrollTop), 
                // Fire change events, and delayed event handlers
                op.changeObjs && signal(cm, "changes", cm, op.changeObjs), op.update && op.update.finish();
            }
            // Run the given function in an operation
            function runInOp(cm, f) {
                if (cm.curOp) return f();
                startOperation(cm);
                try {
                    return f();
                } finally {
                    endOperation(cm);
                }
            }
            // Wraps a function in an operation. Returns the wrapped function.
            function operation(cm, f) {
                return function() {
                    if (cm.curOp) return f.apply(cm, arguments);
                    startOperation(cm);
                    try {
                        return f.apply(cm, arguments);
                    } finally {
                        endOperation(cm);
                    }
                };
            }
            // Used to add methods to editor and doc instances, wrapping them in
            // operations.
            function methodOp(f) {
                return function() {
                    if (this.curOp) return f.apply(this, arguments);
                    startOperation(this);
                    try {
                        return f.apply(this, arguments);
                    } finally {
                        endOperation(this);
                    }
                };
            }
            function docMethodOp(f) {
                return function() {
                    var cm = this.cm;
                    if (!cm || cm.curOp) return f.apply(this, arguments);
                    startOperation(cm);
                    try {
                        return f.apply(this, arguments);
                    } finally {
                        endOperation(cm);
                    }
                };
            }
            // Updates the display.view data structure for a given change to the
            // document. From and to are in pre-change coordinates. Lendiff is
            // the amount of lines added or subtracted by the change. This is
            // used for changes that span multiple lines, or change the way
            // lines are divided into visual lines. regLineChange (below)
            // registers single-line changes.
            function regChange(cm, from, to, lendiff) {
                null == from && (from = cm.doc.first), null == to && (to = cm.doc.first + cm.doc.size), 
                lendiff || (lendiff = 0);
                var display = cm.display;
                if (lendiff && to < display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers > from) && (display.updateLineNumbers = from), 
                cm.curOp.viewChanged = !0, from >= display.viewTo) // Change after
                sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo && resetView(cm); else if (to <= display.viewFrom) // Change before
                sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom ? resetView(cm) : (display.viewFrom += lendiff, 
                display.viewTo += lendiff); else if (from <= display.viewFrom && to >= display.viewTo) // Full overlap
                resetView(cm); else if (from <= display.viewFrom) {
                    // Top overlap
                    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
                    cut ? (display.view = display.view.slice(cut.index), display.viewFrom = cut.lineN, 
                    display.viewTo += lendiff) : resetView(cm);
                } else if (to >= display.viewTo) {
                    // Bottom overlap
                    var cut$1 = viewCuttingPoint(cm, from, from, -1);
                    cut$1 ? (display.view = display.view.slice(0, cut$1.index), display.viewTo = cut$1.lineN) : resetView(cm);
                } else {
                    // Gap in the middle
                    var cutTop = viewCuttingPoint(cm, from, from, -1), cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
                    cutTop && cutBot ? (display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index)), 
                    display.viewTo += lendiff) : resetView(cm);
                }
                var ext = display.externalMeasured;
                ext && (to < ext.lineN ? ext.lineN += lendiff : from < ext.lineN + ext.size && (display.externalMeasured = null));
            }
            // Register a change to a single line. Type must be one of "text",
            // "gutter", "class", "widget"
            function regLineChange(cm, line, type) {
                cm.curOp.viewChanged = !0;
                var display = cm.display, ext = cm.display.externalMeasured;
                if (ext && line >= ext.lineN && line < ext.lineN + ext.size && (display.externalMeasured = null), 
                !(line < display.viewFrom || line >= display.viewTo)) {
                    var lineView = display.view[findViewIndex(cm, line)];
                    if (null != lineView.node) {
                        var arr = lineView.changes || (lineView.changes = []);
                        indexOf(arr, type) == -1 && arr.push(type);
                    }
                }
            }
            // Clear the view.
            function resetView(cm) {
                cm.display.viewFrom = cm.display.viewTo = cm.doc.first, cm.display.view = [], cm.display.viewOffset = 0;
            }
            function viewCuttingPoint(cm, oldN, newN, dir) {
                var diff, index = findViewIndex(cm, oldN), view = cm.display.view;
                if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) return {
                    index: index,
                    lineN: newN
                };
                for (var n = cm.display.viewFrom, i = 0; i < index; i++) n += view[i].size;
                if (n != oldN) {
                    if (dir > 0) {
                        if (index == view.length - 1) return null;
                        diff = n + view[index].size - oldN, index++;
                    } else diff = n - oldN;
                    oldN += diff, newN += diff;
                }
                for (;visualLineNo(cm.doc, newN) != newN; ) {
                    if (index == (dir < 0 ? 0 : view.length - 1)) return null;
                    newN += dir * view[index - (dir < 0 ? 1 : 0)].size, index += dir;
                }
                return {
                    index: index,
                    lineN: newN
                };
            }
            // Force the view to cover a given range, adding empty view element
            // or clipping off existing ones as needed.
            function adjustView(cm, from, to) {
                var display = cm.display, view = display.view;
                0 == view.length || from >= display.viewTo || to <= display.viewFrom ? (display.view = buildViewArray(cm, from, to), 
                display.viewFrom = from) : (display.viewFrom > from ? display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) : display.viewFrom < from && (display.view = display.view.slice(findViewIndex(cm, from))), 
                display.viewFrom = from, display.viewTo < to ? display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) : display.viewTo > to && (display.view = display.view.slice(0, findViewIndex(cm, to)))), 
                display.viewTo = to;
            }
            // Count the number of lines in the view whose DOM representation is
            // out of date (or nonexistent).
            function countDirtyView(cm) {
                for (var view = cm.display.view, dirty = 0, i = 0; i < view.length; i++) {
                    var lineView = view[i];
                    lineView.hidden || lineView.node && !lineView.changes || ++dirty;
                }
                return dirty;
            }
            // HIGHLIGHT WORKER
            function startWorker(cm, time) {
                cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo && cm.state.highlight.set(time, bind(highlightWorker, cm));
            }
            function highlightWorker(cm) {
                var doc = cm.doc;
                if (doc.frontier < doc.first && (doc.frontier = doc.first), !(doc.frontier >= cm.display.viewTo)) {
                    var end = +new Date() + cm.options.workTime, state = copyState(doc.mode, getStateBefore(cm, doc.frontier)), changedLines = [];
                    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
                        if (doc.frontier >= cm.display.viewFrom) {
                            // Visible
                            var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength, highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, !0);
                            line.styles = highlighted.styles;
                            var oldCls = line.styleClasses, newCls = highlighted.classes;
                            newCls ? line.styleClasses = newCls : oldCls && (line.styleClasses = null);
                            for (var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass), i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
                            ischange && changedLines.push(doc.frontier), line.stateAfter = tooLong ? state : copyState(doc.mode, state);
                        } else line.text.length <= cm.options.maxHighlightLength && processLine(cm, line.text, state), 
                        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
                        if (++doc.frontier, +new Date() > end) return startWorker(cm, cm.options.workDelay), 
                        !0;
                    }), changedLines.length && runInOp(cm, function() {
                        for (var i = 0; i < changedLines.length; i++) regLineChange(cm, changedLines[i], "text");
                    });
                }
            }
            function maybeClipScrollbars(cm) {
                var display = cm.display;
                !display.scrollbarsClipped && display.scroller.offsetWidth && (display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth, 
                display.heightForcer.style.height = scrollGap(cm) + "px", display.sizer.style.marginBottom = -display.nativeBarWidth + "px", 
                display.sizer.style.borderRightWidth = scrollGap(cm) + "px", display.scrollbarsClipped = !0);
            }
            // Does the actual updating of the line display. Bails out
            // (returning false) when there is nothing to be done and forced is
            // false.
            function updateDisplayIfNeeded(cm, update) {
                var display = cm.display, doc = cm.doc;
                if (update.editorIsHidden) return resetView(cm), !1;
                // Bail out if the visible area is already rendered and nothing changed.
                if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && 0 == countDirtyView(cm)) return !1;
                maybeUpdateLineNumberWidth(cm) && (resetView(cm), update.dims = getDimensions(cm));
                // Compute a suitable new viewport (from & to)
                var end = doc.first + doc.size, from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first), to = Math.min(end, update.visible.to + cm.options.viewportMargin);
                display.viewFrom < from && from - display.viewFrom < 20 && (from = Math.max(doc.first, display.viewFrom)), 
                display.viewTo > to && display.viewTo - to < 20 && (to = Math.min(end, display.viewTo)), 
                sawCollapsedSpans && (from = visualLineNo(cm.doc, from), to = visualLineEndNo(cm.doc, to));
                var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
                adjustView(cm, from, to), display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom)), 
                // Position the mover div to align with the current scroll position
                cm.display.mover.style.top = display.viewOffset + "px";
                var toUpdate = countDirtyView(cm);
                if (!different && 0 == toUpdate && !update.force && display.renderedView == display.view && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo)) return !1;
                // For big changes, we hide the enclosing element during the
                // update, since that speeds up the operations on most browsers.
                var focused = activeElt();
                // There might have been a widget with a focused element that got
                // hidden or updated, if so re-focus it.
                // Prevent selection and cursors from interfering with the scroll
                // width and height.
                return toUpdate > 4 && (display.lineDiv.style.display = "none"), patchDisplay(cm, display.updateLineNumbers, update.dims), 
                toUpdate > 4 && (display.lineDiv.style.display = ""), display.renderedView = display.view, 
                focused && activeElt() != focused && focused.offsetHeight && focused.focus(), removeChildren(display.cursorDiv), 
                removeChildren(display.selectionDiv), display.gutters.style.height = display.sizer.style.minHeight = 0, 
                different && (display.lastWrapHeight = update.wrapperHeight, display.lastWrapWidth = update.wrapperWidth, 
                startWorker(cm, 400)), display.updateLineNumbers = null, !0;
            }
            function postUpdateDisplay(cm, update) {
                for (var viewport = update.viewport, first = !0; (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm) || (// Clip forced viewport to actual scrollable area.
                viewport && null != viewport.top && (viewport = {
                    top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
                }), // Updated line heights might result in the drawn area not
                // actually covering the viewport. Keep looping until it does.
                update.visible = visibleLines(cm.display, cm.doc, viewport), !(update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo))) && updateDisplayIfNeeded(cm, update); first = !1) {
                    updateHeightsInViewport(cm);
                    var barMeasure = measureForScrollbars(cm);
                    updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure);
                }
                update.signal(cm, "update", cm), cm.display.viewFrom == cm.display.reportedViewFrom && cm.display.viewTo == cm.display.reportedViewTo || (update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo), 
                cm.display.reportedViewFrom = cm.display.viewFrom, cm.display.reportedViewTo = cm.display.viewTo);
            }
            function updateDisplaySimple(cm, viewport) {
                var update = new DisplayUpdate(cm, viewport);
                if (updateDisplayIfNeeded(cm, update)) {
                    updateHeightsInViewport(cm), postUpdateDisplay(cm, update);
                    var barMeasure = measureForScrollbars(cm);
                    updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure), 
                    update.finish();
                }
            }
            // Sync the actual display DOM structure with display.view, removing
            // nodes for lines that are no longer in view, and creating the ones
            // that are not there yet, and updating the ones that are out of
            // date.
            function patchDisplay(cm, updateNumbersFrom, dims) {
                function rm(node) {
                    var next = node.nextSibling;
                    // Works around a throw-scroll bug in OS X Webkit
                    return webkit && mac && cm.display.currentWheelTarget == node ? node.style.display = "none" : node.parentNode.removeChild(node), 
                    next;
                }
                // Loop over the elements in the view, syncing cur (the DOM nodes
                // in display.lineDiv) with the view as we go.
                for (var display = cm.display, lineNumbers = cm.options.lineNumbers, container = display.lineDiv, cur = container.firstChild, view = display.view, lineN = display.viewFrom, i = 0; i < view.length; i++) {
                    var lineView = view[i];
                    if (lineView.hidden) ; else if (lineView.node && lineView.node.parentNode == container) {
                        // Already drawn
                        for (;cur != lineView.node; ) cur = rm(cur);
                        var updateNumber = lineNumbers && null != updateNumbersFrom && updateNumbersFrom <= lineN && lineView.lineNumber;
                        lineView.changes && (indexOf(lineView.changes, "gutter") > -1 && (updateNumber = !1), 
                        updateLineForChanges(cm, lineView, lineN, dims)), updateNumber && (removeChildren(lineView.lineNumber), 
                        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))), 
                        cur = lineView.node.nextSibling;
                    } else {
                        // Not drawn yet
                        var node = buildLineElement(cm, lineView, lineN, dims);
                        container.insertBefore(node, cur);
                    }
                    lineN += lineView.size;
                }
                for (;cur; ) cur = rm(cur);
            }
            function updateGutterSpace(cm) {
                var width = cm.display.gutters.offsetWidth;
                cm.display.sizer.style.marginLeft = width + "px";
            }
            function setDocumentHeight(cm, measure) {
                cm.display.sizer.style.minHeight = measure.docHeight + "px", cm.display.heightForcer.style.top = measure.docHeight + "px", 
                cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
            }
            // Rebuild the gutter elements, ensure the margin to the left of the
            // code matches their width.
            function updateGutters(cm) {
                var gutters = cm.display.gutters, specs = cm.options.gutters;
                removeChildren(gutters);
                for (var i = 0; i < specs.length; ++i) {
                    var gutterClass = specs[i], gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
                    "CodeMirror-linenumbers" == gutterClass && (cm.display.lineGutter = gElt, gElt.style.width = (cm.display.lineNumWidth || 1) + "px");
                }
                gutters.style.display = i ? "" : "none", updateGutterSpace(cm);
            }
            // Make sure the gutters options contains the element
            // "CodeMirror-linenumbers" when the lineNumbers option is true.
            function setGuttersForLineNumbers(options) {
                var found = indexOf(options.gutters, "CodeMirror-linenumbers");
                found == -1 && options.lineNumbers ? options.gutters = options.gutters.concat([ "CodeMirror-linenumbers" ]) : found > -1 && !options.lineNumbers && (options.gutters = options.gutters.slice(0), 
                options.gutters.splice(found, 1));
            }
            // Take an unsorted, potentially overlapping set of ranges, and
            // build a selection out of it. 'Consumes' ranges array (modifying
            // it).
            function normalizeSelection(ranges, primIndex) {
                var prim = ranges[primIndex];
                ranges.sort(function(a, b) {
                    return cmp(a.from(), b.from());
                }), primIndex = indexOf(ranges, prim);
                for (var i = 1; i < ranges.length; i++) {
                    var cur = ranges[i], prev = ranges[i - 1];
                    if (cmp(prev.to(), cur.from()) >= 0) {
                        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to()), inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                        i <= primIndex && --primIndex, ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
                    }
                }
                return new Selection(ranges, primIndex);
            }
            function simpleSelection(anchor, head) {
                return new Selection([ new Range(anchor, head || anchor) ], 0);
            }
            // Compute the position of the end of a change (its 'to' property
            // refers to the pre-change end).
            function changeEnd(change) {
                return change.text ? Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0)) : change.to;
            }
            // Adjust a position to refer to the post-change position of the
            // same text, or the end of the change if the change covers it.
            function adjustForChange(pos, change) {
                if (cmp(pos, change.from) < 0) return pos;
                if (cmp(pos, change.to) <= 0) return changeEnd(change);
                var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
                return pos.line == change.to.line && (ch += changeEnd(change).ch - change.to.ch), 
                Pos(line, ch);
            }
            function computeSelAfterChange(doc, change) {
                for (var out = [], i = 0; i < doc.sel.ranges.length; i++) {
                    var range = doc.sel.ranges[i];
                    out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
                }
                return normalizeSelection(out, doc.sel.primIndex);
            }
            function offsetPos(pos, old, nw) {
                return pos.line == old.line ? Pos(nw.line, pos.ch - old.ch + nw.ch) : Pos(nw.line + (pos.line - old.line), pos.ch);
            }
            // Used by replaceSelections to allow moving the selection to the
            // start or around the replaced test. Hint may be "start" or "around".
            function computeReplacedSel(doc, changes, hint) {
                for (var out = [], oldPrev = Pos(doc.first, 0), newPrev = oldPrev, i = 0; i < changes.length; i++) {
                    var change = changes[i], from = offsetPos(change.from, oldPrev, newPrev), to = offsetPos(changeEnd(change), oldPrev, newPrev);
                    if (oldPrev = change.to, newPrev = to, "around" == hint) {
                        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
                        out[i] = new Range(inv ? to : from, inv ? from : to);
                    } else out[i] = new Range(from, from);
                }
                return new Selection(out, doc.sel.primIndex);
            }
            // Used to get the editor into a consistent state again when options change.
            function loadMode(cm) {
                cm.doc.mode = getMode(cm.options, cm.doc.modeOption), resetModeState(cm);
            }
            function resetModeState(cm) {
                cm.doc.iter(function(line) {
                    line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null);
                }), cm.doc.frontier = cm.doc.first, startWorker(cm, 100), cm.state.modeGen++, cm.curOp && regChange(cm);
            }
            // DOCUMENT DATA STRUCTURE
            // By default, updates that start and end at the beginning of a line
            // are treated specially, in order to make the association of line
            // widgets and marker elements with the text behave more intuitive.
            function isWholeLineUpdate(doc, change) {
                return 0 == change.from.ch && 0 == change.to.ch && "" == lst(change.text) && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
            }
            // Perform a change on the document data structure.
            function updateDoc(doc, change, markedSpans, estimateHeight) {
                function spansFor(n) {
                    return markedSpans ? markedSpans[n] : null;
                }
                function update(line, text, spans) {
                    updateLine(line, text, spans, estimateHeight), signalLater(line, "change", line, change);
                }
                function linesFor(start, end) {
                    for (var result = [], i = start; i < end; ++i) result.push(new Line(text[i], spansFor(i), estimateHeight));
                    return result;
                }
                var from = change.from, to = change.to, text = change.text, firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line), lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
                // Adjust the line structure
                if (change.full) doc.insert(0, linesFor(0, text.length)), doc.remove(text.length, doc.size - text.length); else if (isWholeLineUpdate(doc, change)) {
                    // This is a whole-line replace. Treated specially to make
                    // sure line objects move the way they are supposed to.
                    var added = linesFor(0, text.length - 1);
                    update(lastLine, lastLine.text, lastSpans), nlines && doc.remove(from.line, nlines), 
                    added.length && doc.insert(from.line, added);
                } else if (firstLine == lastLine) if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans); else {
                    var added$1 = linesFor(1, text.length - 1);
                    added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight)), 
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), doc.insert(from.line + 1, added$1);
                } else if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0)), 
                doc.remove(from.line + 1, nlines); else {
                    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
                    var added$2 = linesFor(1, text.length - 1);
                    nlines > 1 && doc.remove(from.line + 1, nlines - 1), doc.insert(from.line + 1, added$2);
                }
                signalLater(doc, "change", doc, change);
            }
            // Call f for all linked documents.
            function linkedDocs(doc, f, sharedHistOnly) {
                function propagate(doc, skip, sharedHist) {
                    if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
                        var rel = doc.linked[i];
                        if (rel.doc != skip) {
                            var shared = sharedHist && rel.sharedHist;
                            sharedHistOnly && !shared || (f(rel.doc, shared), propagate(rel.doc, doc, shared));
                        }
                    }
                }
                propagate(doc, null, !0);
            }
            // Attach a document to an editor.
            function attachDoc(cm, doc) {
                if (doc.cm) throw new Error("This document is already in use.");
                cm.doc = doc, doc.cm = cm, estimateLineHeights(cm), loadMode(cm), cm.options.lineWrapping || findMaxLine(cm), 
                cm.options.mode = doc.modeOption, regChange(cm);
            }
            function History(startGen) {
                // Arrays of change events and selections. Doing something adds an
                // event to done and clears undo. Undoing moves events from done
                // to undone, redoing moves them in the other direction.
                this.done = [], this.undone = [], this.undoDepth = 1 / 0, // Used to track when changes can be merged into a single undo
                // event
                this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, 
                // Used by the isClean() method
                this.generation = this.maxGeneration = startGen || 1;
            }
            // Create a history change event from an updateDoc-style change
            // object.
            function historyChangeFromChange(doc, change) {
                var histChange = {
                    from: copyPos(change.from),
                    to: changeEnd(change),
                    text: getBetween(doc, change.from, change.to)
                };
                return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), 
                linkedDocs(doc, function(doc) {
                    return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
                }, !0), histChange;
            }
            // Pop all selection events off the end of a history array. Stop at
            // a change event.
            function clearSelectionEvents(array) {
                for (;array.length; ) {
                    var last = lst(array);
                    if (!last.ranges) break;
                    array.pop();
                }
            }
            // Find the top change event in the history. Pop off selection
            // events that are in the way.
            function lastChangeEvent(hist, force) {
                return force ? (clearSelectionEvents(hist.done), lst(hist.done)) : hist.done.length && !lst(hist.done).ranges ? lst(hist.done) : hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges ? (hist.done.pop(), 
                lst(hist.done)) : void 0;
            }
            // Register a change in the history. Merges changes that are within
            // a single operation, or are close together with an origin that
            // allows merging (starting with "+") into a single event.
            function addChangeToHistory(doc, change, selAfter, opId) {
                var hist = doc.history;
                hist.undone.length = 0;
                var cur, last, time = +new Date();
                if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || "*" == change.origin.charAt(0))) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) // Merge this change into the last event
                last = lst(cur.changes), 0 == cmp(change.from, change.to) && 0 == cmp(change.from, last.to) ? // Optimized case for simple insertion -- don't want to add
                // new changesets for every character typed
                last.to = changeEnd(change) : // Add new sub-event
                cur.changes.push(historyChangeFromChange(doc, change)); else {
                    // Can not be merged, start a new event.
                    var before = lst(hist.done);
                    for (before && before.ranges || pushSelectionToHistory(doc.sel, hist.done), cur = {
                        changes: [ historyChangeFromChange(doc, change) ],
                        generation: hist.generation
                    }, hist.done.push(cur); hist.done.length > hist.undoDepth; ) hist.done.shift(), 
                    hist.done[0].ranges || hist.done.shift();
                }
                hist.done.push(selAfter), hist.generation = ++hist.maxGeneration, hist.lastModTime = hist.lastSelTime = time, 
                hist.lastOp = hist.lastSelOp = opId, hist.lastOrigin = hist.lastSelOrigin = change.origin, 
                last || signal(doc, "historyAdded");
            }
            function selectionEventCanBeMerged(doc, origin, prev, sel) {
                var ch = origin.charAt(0);
                return "*" == ch || "+" == ch && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
            }
            // Called whenever the selection changes, sets the new selection as
            // the pending selection in the history, and pushes the old pending
            // selection into the 'done' array when it was significantly
            // different (in number of selected ranges, emptiness, or time).
            function addSelectionToHistory(doc, sel, opId, options) {
                var hist = doc.history, origin = options && options.origin;
                // A new event is started when the previous origin does not match
                // the current, or the origins don't allow matching. Origins
                // starting with * are always merged, those starting with + are
                // merged when similar and close together in time.
                opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)) ? hist.done[hist.done.length - 1] = sel : pushSelectionToHistory(sel, hist.done), 
                hist.lastSelTime = +new Date(), hist.lastSelOrigin = origin, hist.lastSelOp = opId, 
                options && options.clearRedo !== !1 && clearSelectionEvents(hist.undone);
            }
            function pushSelectionToHistory(sel, dest) {
                var top = lst(dest);
                top && top.ranges && top.equals(sel) || dest.push(sel);
            }
            // Used to store marked span information in the history.
            function attachLocalSpans(doc, change, from, to) {
                var existing = change["spans_" + doc.id], n = 0;
                doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
                    line.markedSpans && ((existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans), 
                    ++n;
                });
            }
            // When un/re-doing restores text containing marked spans, those
            // that have been explicitly cleared should not be restored.
            function removeClearedSpans(spans) {
                if (!spans) return null;
                for (var out, i = 0; i < spans.length; ++i) spans[i].marker.explicitlyCleared ? out || (out = spans.slice(0, i)) : out && out.push(spans[i]);
                return out ? out.length ? out : null : spans;
            }
            // Retrieve and filter the old marked spans stored in a change event.
            function getOldSpans(doc, change) {
                var found = change["spans_" + doc.id];
                if (!found) return null;
                for (var nw = [], i = 0; i < change.text.length; ++i) nw.push(removeClearedSpans(found[i]));
                return nw;
            }
            // Used for un/re-doing changes from the history. Combines the
            // result of computing the existing spans with the set of spans that
            // existed in the history (so that deleting around a span and then
            // undoing brings back the span).
            function mergeOldSpans(doc, change) {
                var old = getOldSpans(doc, change), stretched = stretchSpansOverChange(doc, change);
                if (!old) return stretched;
                if (!stretched) return old;
                for (var i = 0; i < old.length; ++i) {
                    var oldCur = old[i], stretchCur = stretched[i];
                    if (oldCur && stretchCur) spans: for (var j = 0; j < stretchCur.length; ++j) {
                        for (var span = stretchCur[j], k = 0; k < oldCur.length; ++k) if (oldCur[k].marker == span.marker) continue spans;
                        oldCur.push(span);
                    } else stretchCur && (old[i] = stretchCur);
                }
                return old;
            }
            // Used both to provide a JSON-safe object in .getHistory, and, when
            // detaching a document, to split the history in two
            function copyHistoryArray(events, newGroup, instantiateSel) {
                for (var copy = [], i = 0; i < events.length; ++i) {
                    var event = events[i];
                    if (event.ranges) copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event); else {
                        var changes = event.changes, newChanges = [];
                        copy.push({
                            changes: newChanges
                        });
                        for (var j = 0; j < changes.length; ++j) {
                            var change = changes[j], m = void 0;
                            if (newChanges.push({
                                from: change.from,
                                to: change.to,
                                text: change.text
                            }), newGroup) for (var prop in change) (m = prop.match(/^spans_(\d+)$/)) && indexOf(newGroup, Number(m[1])) > -1 && (lst(newChanges)[prop] = change[prop], 
                            delete change[prop]);
                        }
                    }
                }
                return copy;
            }
            // The 'scroll' parameter given to many of these indicated whether
            // the new cursor position should be scrolled into view after
            // modifying the selection.
            // If shift is held or the extend flag is set, extends a range to
            // include a given position (and optionally a second position).
            // Otherwise, simply returns the range between the given positions.
            // Used for cursor motion and such.
            function extendRange(doc, range, head, other) {
                if (doc.cm && doc.cm.display.shift || doc.extend) {
                    var anchor = range.anchor;
                    if (other) {
                        var posBefore = cmp(head, anchor) < 0;
                        posBefore != cmp(other, anchor) < 0 ? (anchor = head, head = other) : posBefore != cmp(head, other) < 0 && (head = other);
                    }
                    return new Range(anchor, head);
                }
                return new Range(other || head, head);
            }
            // Extend the primary selection range, discard the rest.
            function extendSelection(doc, head, other, options) {
                setSelection(doc, new Selection([ extendRange(doc, doc.sel.primary(), head, other) ], 0), options);
            }
            // Extend all selections (pos is an array of selections with length
            // equal the number of selections)
            function extendSelections(doc, heads, options) {
                for (var out = [], i = 0; i < doc.sel.ranges.length; i++) out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
                var newSel = normalizeSelection(out, doc.sel.primIndex);
                setSelection(doc, newSel, options);
            }
            // Updates a single range in the selection.
            function replaceOneSelection(doc, i, range, options) {
                var ranges = doc.sel.ranges.slice(0);
                ranges[i] = range, setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
            }
            // Reset the selection to a single range.
            function setSimpleSelection(doc, anchor, head, options) {
                setSelection(doc, simpleSelection(anchor, head), options);
            }
            // Give beforeSelectionChange handlers a change to influence a
            // selection update.
            function filterSelectionChange(doc, sel, options) {
                var obj = {
                    ranges: sel.ranges,
                    update: function(ranges) {
                        var this$1 = this;
                        this.ranges = [];
                        for (var i = 0; i < ranges.length; i++) this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
                    },
                    origin: options && options.origin
                };
                return signal(doc, "beforeSelectionChange", doc, obj), doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, obj), 
                obj.ranges != sel.ranges ? normalizeSelection(obj.ranges, obj.ranges.length - 1) : sel;
            }
            function setSelectionReplaceHistory(doc, sel, options) {
                var done = doc.history.done, last = lst(done);
                last && last.ranges ? (done[done.length - 1] = sel, setSelectionNoUndo(doc, sel, options)) : setSelection(doc, sel, options);
            }
            // Set a new selection.
            function setSelection(doc, sel, options) {
                setSelectionNoUndo(doc, sel, options), addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
            }
            function setSelectionNoUndo(doc, sel, options) {
                (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) && (sel = filterSelectionChange(doc, sel, options));
                var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
                setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, !0)), options && options.scroll === !1 || !doc.cm || ensureCursorVisible(doc.cm);
            }
            function setSelectionInner(doc, sel) {
                sel.equals(doc.sel) || (doc.sel = sel, doc.cm && (doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = !0, 
                signalCursorActivity(doc.cm)), signalLater(doc, "cursorActivity", doc));
            }
            // Verify that the selection does not partially select any atomic
            // marked ranges.
            function reCheckSelection(doc) {
                setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, !1), sel_dontScroll);
            }
            // Return a selection that does not partially select any atomic
            // ranges.
            function skipAtomicInSelection(doc, sel, bias, mayClear) {
                for (var out, i = 0; i < sel.ranges.length; i++) {
                    var range = sel.ranges[i], old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i], newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear), newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
                    (out || newAnchor != range.anchor || newHead != range.head) && (out || (out = sel.ranges.slice(0, i)), 
                    out[i] = new Range(newAnchor, newHead));
                }
                return out ? normalizeSelection(out, sel.primIndex) : sel;
            }
            function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
                var line = getLine(doc, pos.line);
                if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
                    var sp = line.markedSpans[i], m = sp.marker;
                    if ((null == sp.from || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (null == sp.to || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                        if (mayClear && (signal(m, "beforeCursorEnter"), m.explicitlyCleared)) {
                            if (line.markedSpans) {
                                --i;
                                continue;
                            }
                            break;
                        }
                        if (!m.atomic) continue;
                        if (oldPos) {
                            var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
                            if ((dir < 0 ? m.inclusiveRight : m.inclusiveLeft) && (near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null)), 
                            near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) return skipAtomicInner(doc, near, pos, dir, mayClear);
                        }
                        var far = m.find(dir < 0 ? -1 : 1);
                        return (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) && (far = movePos(doc, far, dir, far.line == pos.line ? line : null)), 
                        far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
                    }
                }
                return pos;
            }
            // Ensure a given position is not inside an atomic range.
            function skipAtomic(doc, pos, oldPos, bias, mayClear) {
                var dir = bias || 1, found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, !0) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, !0);
                return found ? found : (doc.cantEdit = !0, Pos(doc.first, 0));
            }
            function movePos(doc, pos, dir, line) {
                return dir < 0 && 0 == pos.ch ? pos.line > doc.first ? clipPos(doc, Pos(pos.line - 1)) : null : dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length ? pos.line < doc.first + doc.size - 1 ? Pos(pos.line + 1, 0) : null : new Pos(pos.line, pos.ch + dir);
            }
            function selectAll(cm) {
                cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
            }
            // UPDATING
            // Allow "beforeChange" event handlers to influence a change
            function filterChange(doc, change, update) {
                var obj = {
                    canceled: !1,
                    from: change.from,
                    to: change.to,
                    text: change.text,
                    origin: change.origin,
                    cancel: function() {
                        return obj.canceled = !0;
                    }
                };
                return update && (obj.update = function(from, to, text, origin) {
                    from && (obj.from = clipPos(doc, from)), to && (obj.to = clipPos(doc, to)), text && (obj.text = text), 
                    void 0 !== origin && (obj.origin = origin);
                }), signal(doc, "beforeChange", doc, obj), doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj), 
                obj.canceled ? null : {
                    from: obj.from,
                    to: obj.to,
                    text: obj.text,
                    origin: obj.origin
                };
            }
            // Apply a change to a document, and add it to the document's
            // history, and propagating it to all linked documents.
            function makeChange(doc, change, ignoreReadOnly) {
                if (doc.cm) {
                    if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
                    if (doc.cm.state.suppressEdits) return;
                }
                if (!(hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) || (change = filterChange(doc, change, !0))) {
                    // Possibly split or suppress the update based on the presence
                    // of read-only spans in its range.
                    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
                    if (split) for (var i = split.length - 1; i >= 0; --i) makeChangeInner(doc, {
                        from: split[i].from,
                        to: split[i].to,
                        text: i ? [ "" ] : change.text
                    }); else makeChangeInner(doc, change);
                }
            }
            function makeChangeInner(doc, change) {
                if (1 != change.text.length || "" != change.text[0] || 0 != cmp(change.from, change.to)) {
                    var selAfter = computeSelAfterChange(doc, change);
                    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN), makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
                    var rebased = [];
                    linkedDocs(doc, function(doc, sharedHist) {
                        sharedHist || indexOf(rebased, doc.history) != -1 || (rebaseHist(doc.history, change), 
                        rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
                    });
                }
            }
            // Revert a change stored in a document's history.
            function makeChangeFromHistory(doc, type, allowSelectionOnly) {
                if (!doc.cm || !doc.cm.state.suppressEdits || allowSelectionOnly) {
                    for (var event, hist = doc.history, selAfter = doc.sel, source = "undo" == type ? hist.done : hist.undone, dest = "undo" == type ? hist.undone : hist.done, i = 0; i < source.length && (event = source[i], 
                    allowSelectionOnly ? !event.ranges || event.equals(doc.sel) : event.ranges); i++) ;
                    if (i != source.length) {
                        for (hist.lastOrigin = hist.lastSelOrigin = null; event = source.pop(), event.ranges; ) {
                            if (pushSelectionToHistory(event, dest), allowSelectionOnly && !event.equals(doc.sel)) return void setSelection(doc, event, {
                                clearRedo: !1
                            });
                            selAfter = event;
                        }
                        // Build up a reverse change object to add to the opposite history
                        // stack (redo when undoing, and vice versa).
                        var antiChanges = [];
                        pushSelectionToHistory(selAfter, dest), dest.push({
                            changes: antiChanges,
                            generation: hist.generation
                        }), hist.generation = event.generation || ++hist.maxGeneration;
                        for (var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange"), loop = function(i) {
                            var change = event.changes[i];
                            if (change.origin = type, filter && !filterChange(doc, change, !1)) return source.length = 0, 
                            {};
                            antiChanges.push(historyChangeFromChange(doc, change));
                            var after = i ? computeSelAfterChange(doc, change) : lst(source);
                            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change)), !i && doc.cm && doc.cm.scrollIntoView({
                                from: change.from,
                                to: changeEnd(change)
                            });
                            var rebased = [];
                            // Propagate to the linked documents
                            linkedDocs(doc, function(doc, sharedHist) {
                                sharedHist || indexOf(rebased, doc.history) != -1 || (rebaseHist(doc.history, change), 
                                rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
                            });
                        }, i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
                            var returned = loop(i$1);
                            if (returned) return returned.v;
                        }
                    }
                }
            }
            // Sub-views need their line numbers shifted when text is added
            // above or below them in the parent document.
            function shiftDoc(doc, distance) {
                if (0 != distance && (doc.first += distance, doc.sel = new Selection(map(doc.sel.ranges, function(range) {
                    return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
                }), doc.sel.primIndex), doc.cm)) {
                    regChange(doc.cm, doc.first, doc.first - distance, distance);
                    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) regLineChange(doc.cm, l, "gutter");
                }
            }
            // More lower-level change function, handling only a single document
            // (not linked ones).
            function makeChangeSingleDoc(doc, change, selAfter, spans) {
                if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
                if (change.to.line < doc.first) return void shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
                if (!(change.from.line > doc.lastLine())) {
                    // Clip the change to the size of this doc
                    if (change.from.line < doc.first) {
                        var shift = change.text.length - 1 - (doc.first - change.from.line);
                        shiftDoc(doc, shift), change = {
                            from: Pos(doc.first, 0),
                            to: Pos(change.to.line + shift, change.to.ch),
                            text: [ lst(change.text) ],
                            origin: change.origin
                        };
                    }
                    var last = doc.lastLine();
                    change.to.line > last && (change = {
                        from: change.from,
                        to: Pos(last, getLine(doc, last).text.length),
                        text: [ change.text[0] ],
                        origin: change.origin
                    }), change.removed = getBetween(doc, change.from, change.to), selAfter || (selAfter = computeSelAfterChange(doc, change)), 
                    doc.cm ? makeChangeSingleDocInEditor(doc.cm, change, spans) : updateDoc(doc, change, spans), 
                    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
                }
            }
            // Handle the interaction of a change to a document with the editor
            // that this document is part of.
            function makeChangeSingleDocInEditor(cm, change, spans) {
                var doc = cm.doc, display = cm.display, from = change.from, to = change.to, recomputeMaxLength = !1, checkWidthStart = from.line;
                cm.options.lineWrapping || (checkWidthStart = lineNo(visualLine(getLine(doc, from.line))), 
                doc.iter(checkWidthStart, to.line + 1, function(line) {
                    if (line == display.maxLine) return recomputeMaxLength = !0, !0;
                })), doc.sel.contains(change.from, change.to) > -1 && signalCursorActivity(cm), 
                updateDoc(doc, change, spans, estimateHeight(cm)), cm.options.lineWrapping || (doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
                    var len = lineLength(line);
                    len > display.maxLineLength && (display.maxLine = line, display.maxLineLength = len, 
                    display.maxLineChanged = !0, recomputeMaxLength = !1);
                }), recomputeMaxLength && (cm.curOp.updateMaxLine = !0)), // Adjust frontier, schedule worker
                doc.frontier = Math.min(doc.frontier, from.line), startWorker(cm, 400);
                var lendiff = change.text.length - (to.line - from.line) - 1;
                // Remember that these lines changed, for updating the display
                change.full ? regChange(cm) : from.line != to.line || 1 != change.text.length || isWholeLineUpdate(cm.doc, change) ? regChange(cm, from.line, to.line + 1, lendiff) : regLineChange(cm, from.line, "text");
                var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
                if (changeHandler || changesHandler) {
                    var obj = {
                        from: from,
                        to: to,
                        text: change.text,
                        removed: change.removed,
                        origin: change.origin
                    };
                    changeHandler && signalLater(cm, "change", cm, obj), changesHandler && (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
                }
                cm.display.selForContextMenu = null;
            }
            function replaceRange(doc, code, from, to, origin) {
                if (to || (to = from), cmp(to, from) < 0) {
                    var tmp = to;
                    to = from, from = tmp;
                }
                "string" == typeof code && (code = doc.splitLines(code)), makeChange(doc, {
                    from: from,
                    to: to,
                    text: code,
                    origin: origin
                });
            }
            // Rebasing/resetting history to deal with externally-sourced changes
            function rebaseHistSelSingle(pos, from, to, diff) {
                to < pos.line ? pos.line += diff : from < pos.line && (pos.line = from, pos.ch = 0);
            }
            // Tries to rebase an array of history events given a change in the
            // document. If the change touches the same lines as the event, the
            // event, and everything 'behind' it, is discarded. If the change is
            // before the event, the event's positions are updated. Uses a
            // copy-on-write scheme for the positions, to avoid having to
            // reallocate them all on every rebase, but also avoid problems with
            // shared position objects being unsafely updated.
            function rebaseHistArray(array, from, to, diff) {
                for (var i = 0; i < array.length; ++i) {
                    var sub = array[i], ok = !0;
                    if (sub.ranges) {
                        sub.copied || (sub = array[i] = sub.deepCopy(), sub.copied = !0);
                        for (var j = 0; j < sub.ranges.length; j++) rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff), 
                        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
                    } else {
                        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
                            var cur = sub.changes[j$1];
                            if (to < cur.from.line) cur.from = Pos(cur.from.line + diff, cur.from.ch), cur.to = Pos(cur.to.line + diff, cur.to.ch); else if (from <= cur.to.line) {
                                ok = !1;
                                break;
                            }
                        }
                        ok || (array.splice(0, i + 1), i = 0);
                    }
                }
            }
            function rebaseHist(hist, change) {
                var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
                rebaseHistArray(hist.done, from, to, diff), rebaseHistArray(hist.undone, from, to, diff);
            }
            // Utility for applying a change to a line by handle or number,
            // returning the number and optionally registering the line as
            // changed.
            function changeLine(doc, handle, changeType, op) {
                var no = handle, line = handle;
                return "number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle), 
                null == no ? null : (op(line, no) && doc.cm && regLineChange(doc.cm, no, changeType), 
                line);
            }
            function adjustScrollWhenAboveVisible(cm, line, diff) {
                heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop) && addToScrollPos(cm, null, diff);
            }
            function addLineWidget(doc, handle, node, options) {
                var widget = new LineWidget(doc, node, options), cm = doc.cm;
                return cm && widget.noHScroll && (cm.display.alignWidgets = !0), changeLine(doc, handle, "widget", function(line) {
                    var widgets = line.widgets || (line.widgets = []);
                    if (null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget), 
                    widget.line = line, cm && !lineIsHidden(doc, line)) {
                        var aboveVisible = heightAtLine(line) < doc.scrollTop;
                        updateLineHeight(line, line.height + widgetHeight(widget)), aboveVisible && addToScrollPos(cm, null, widget.height), 
                        cm.curOp.forceUpdate = !0;
                    }
                    return !0;
                }), signalLater(cm, "lineWidgetAdded", cm, widget, "number" == typeof handle ? handle : lineNo(handle)), 
                widget;
            }
            // Create a marker, wire it up to the right lines, and
            function markText(doc, from, to, options, type) {
                // Shared markers (across linked documents) are handled separately
                // (markTextShared will call out to this again, once per
                // document).
                if (options && options.shared) return markTextShared(doc, from, to, options, type);
                // Ensure we are in an operation.
                if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);
                var marker = new TextMarker(doc, type), diff = cmp(from, to);
                // Don't connect empty markers unless clearWhenEmpty is false
                if (options && copyObj(options, marker, !1), diff > 0 || 0 == diff && marker.clearWhenEmpty !== !1) return marker;
                if (marker.replacedWith && (// Showing up as a widget implies collapsed (widget replaces text)
                marker.collapsed = !0, marker.widgetNode = elt("span", [ marker.replacedWith ], "CodeMirror-widget"), 
                marker.widgetNode.setAttribute("role", "presentation"), // hide from accessibility tree
                options.handleMouseEvents || marker.widgetNode.setAttribute("cm-ignore-events", "true"), 
                options.insertLeft && (marker.widgetNode.insertLeft = !0)), marker.collapsed) {
                    if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
                    seeCollapsedSpans();
                }
                marker.addToHistory && addChangeToHistory(doc, {
                    from: from,
                    to: to,
                    origin: "markText"
                }, doc.sel, NaN);
                var updateMaxLine, curLine = from.line, cm = doc.cm;
                if (doc.iter(curLine, to.line + 1, function(line) {
                    cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine && (updateMaxLine = !0), 
                    marker.collapsed && curLine != from.line && updateLineHeight(line, 0), addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null)), 
                    ++curLine;
                }), // lineIsHidden depends on the presence of the spans, so needs a second pass
                marker.collapsed && doc.iter(from.line, to.line + 1, function(line) {
                    lineIsHidden(doc, line) && updateLineHeight(line, 0);
                }), marker.clearOnEnter && on(marker, "beforeCursorEnter", function() {
                    return marker.clear();
                }), marker.readOnly && (seeReadOnlySpans(), (doc.history.done.length || doc.history.undone.length) && doc.clearHistory()), 
                marker.collapsed && (marker.id = ++nextMarkerId, marker.atomic = !0), cm) {
                    if (// Sync editor state
                    updateMaxLine && (cm.curOp.updateMaxLine = !0), marker.collapsed) regChange(cm, from.line, to.line + 1); else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css) for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
                    marker.atomic && reCheckSelection(cm.doc), signalLater(cm, "markerAdded", cm, marker);
                }
                return marker;
            }
            function markTextShared(doc, from, to, options, type) {
                options = copyObj(options), options.shared = !1;
                var markers = [ markText(doc, from, to, options, type) ], primary = markers[0], widget = options.widgetNode;
                return linkedDocs(doc, function(doc) {
                    widget && (options.widgetNode = widget.cloneNode(!0)), markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
                    for (var i = 0; i < doc.linked.length; ++i) if (doc.linked[i].isParent) return;
                    primary = lst(markers);
                }), new SharedTextMarker(markers, primary);
            }
            function findSharedMarkers(doc) {
                return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
                    return m.parent;
                });
            }
            function copySharedMarkers(doc, markers) {
                for (var i = 0; i < markers.length; i++) {
                    var marker = markers[i], pos = marker.find(), mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
                    if (cmp(mFrom, mTo)) {
                        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                        marker.markers.push(subMark), subMark.parent = marker;
                    }
                }
            }
            function detachSharedMarkers(markers) {
                for (var loop = function(i) {
                    var marker = markers[i], linked = [ marker.primary.doc ];
                    linkedDocs(marker.primary.doc, function(d) {
                        return linked.push(d);
                    });
                    for (var j = 0; j < marker.markers.length; j++) {
                        var subMarker = marker.markers[j];
                        indexOf(linked, subMarker.doc) == -1 && (subMarker.parent = null, marker.markers.splice(j--, 1));
                    }
                }, i = 0; i < markers.length; i++) loop(i);
            }
            function onDrop(e) {
                var cm = this;
                if (clearDragCursor(cm), !signalDOMEvent(cm, e) && !eventInWidget(cm.display, e)) {
                    e_preventDefault(e), ie && (lastDrop = +new Date());
                    var pos = posFromMouse(cm, e, !0), files = e.dataTransfer.files;
                    if (pos && !cm.isReadOnly()) // Might be a file drop, in which case we simply extract the text
                    // and insert it.
                    if (files && files.length && window.FileReader && window.File) for (var n = files.length, text = Array(n), read = 0, loadFile = function(file, i) {
                        if (!cm.options.allowDropFileTypes || indexOf(cm.options.allowDropFileTypes, file.type) != -1) {
                            var reader = new FileReader();
                            reader.onload = operation(cm, function() {
                                var content = reader.result;
                                if (/[\x00-\x08\x0e-\x1f]{2}/.test(content) && (content = ""), text[i] = content, 
                                ++read == n) {
                                    pos = clipPos(cm.doc, pos);
                                    var change = {
                                        from: pos,
                                        to: pos,
                                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                                        origin: "paste"
                                    };
                                    makeChange(cm.doc, change), setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
                                }
                            }), reader.readAsText(file);
                        }
                    }, i = 0; i < n; ++i) loadFile(files[i], i); else {
                        // Normal drop
                        // Don't do a replace if the drop happened inside of the selected text.
                        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) // Ensure the editor is re-focused
                        return cm.state.draggingText(e), void setTimeout(function() {
                            return cm.display.input.focus();
                        }, 20);
                        try {
                            var text$1 = e.dataTransfer.getData("Text");
                            if (text$1) {
                                var selected;
                                if (cm.state.draggingText && !cm.state.draggingText.copy && (selected = cm.listSelections()), 
                                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos)), selected) for (var i$1 = 0; i$1 < selected.length; ++i$1) replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                                cm.replaceSelection(text$1, "around", "paste"), cm.display.input.focus();
                            }
                        } catch (e) {}
                    }
                }
            }
            function onDragStart(cm, e) {
                if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) return void e_stop(e);
                if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e) && (e.dataTransfer.setData("Text", cm.getSelection()), 
                e.dataTransfer.effectAllowed = "copyMove", e.dataTransfer.setDragImage && !safari)) {
                    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
                    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", 
                    presto && (img.width = img.height = 1, cm.display.wrapper.appendChild(img), // Force a relayout, or Opera won't use our image for some obscure reason
                    img._top = img.offsetTop), e.dataTransfer.setDragImage(img, 0, 0), presto && img.parentNode.removeChild(img);
                }
            }
            function onDragOver(cm, e) {
                var pos = posFromMouse(cm, e);
                if (pos) {
                    var frag = document.createDocumentFragment();
                    drawSelectionCursor(cm, pos, frag), cm.display.dragCursor || (cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), 
                    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)), 
                    removeChildrenAndAdd(cm.display.dragCursor, frag);
                }
            }
            function clearDragCursor(cm) {
                cm.display.dragCursor && (cm.display.lineSpace.removeChild(cm.display.dragCursor), 
                cm.display.dragCursor = null);
            }
            // These must be handled carefully, because naively registering a
            // handler for each editor will cause the editors to never be
            // garbage collected.
            function forEachCodeMirror(f) {
                if (document.body.getElementsByClassName) for (var byClass = document.body.getElementsByClassName("CodeMirror"), i = 0; i < byClass.length; i++) {
                    var cm = byClass[i].CodeMirror;
                    cm && f(cm);
                }
            }
            function ensureGlobalHandlers() {
                globalsRegistered || (registerGlobalHandlers(), globalsRegistered = !0);
            }
            function registerGlobalHandlers() {
                // When the window resizes, we need to refresh active editors.
                var resizeTimer;
                on(window, "resize", function() {
                    null == resizeTimer && (resizeTimer = setTimeout(function() {
                        resizeTimer = null, forEachCodeMirror(onResize);
                    }, 100));
                }), // When the window loses focus, we want to show the editor as blurred
                on(window, "blur", function() {
                    return forEachCodeMirror(onBlur);
                });
            }
            // Called when the window resizes
            function onResize(cm) {
                var d = cm.display;
                d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth || (// Might be a text scaling operation, clear size caches.
                d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, d.scrollbarsClipped = !1, 
                cm.setSize());
            }
            // KEYMAP DISPATCH
            function normalizeKeyName(name) {
                var parts = name.split(/-(?!$)/);
                name = parts[parts.length - 1];
                for (var alt, ctrl, shift, cmd, i = 0; i < parts.length - 1; i++) {
                    var mod = parts[i];
                    if (/^(cmd|meta|m)$/i.test(mod)) cmd = !0; else if (/^a(lt)?$/i.test(mod)) alt = !0; else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = !0; else {
                        if (!/^s(hift)?$/i.test(mod)) throw new Error("Unrecognized modifier name: " + mod);
                        shift = !0;
                    }
                }
                return alt && (name = "Alt-" + name), ctrl && (name = "Ctrl-" + name), cmd && (name = "Cmd-" + name), 
                shift && (name = "Shift-" + name), name;
            }
            // This is a kludge to keep keymaps mostly working as raw objects
            // (backwards compatibility) while at the same time support features
            // like normalization and multi-stroke key bindings. It compiles a
            // new normalized keymap, and then updates the old object to reflect
            // this.
            function normalizeKeyMap(keymap) {
                var copy = {};
                for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {
                    var value = keymap[keyname];
                    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
                    if ("..." == value) {
                        delete keymap[keyname];
                        continue;
                    }
                    for (var keys = map(keyname.split(" "), normalizeKeyName), i = 0; i < keys.length; i++) {
                        var val = void 0, name = void 0;
                        i == keys.length - 1 ? (name = keys.join(" "), val = value) : (name = keys.slice(0, i + 1).join(" "), 
                        val = "...");
                        var prev = copy[name];
                        if (prev) {
                            if (prev != val) throw new Error("Inconsistent bindings for " + name);
                        } else copy[name] = val;
                    }
                    delete keymap[keyname];
                }
                for (var prop in copy) keymap[prop] = copy[prop];
                return keymap;
            }
            function lookupKey(key, map, handle, context) {
                map = getKeyMap(map);
                var found = map.call ? map.call(key, context) : map[key];
                if (found === !1) return "nothing";
                if ("..." === found) return "multi";
                if (null != found && handle(found)) return "handled";
                if (map.fallthrough) {
                    if ("[object Array]" != Object.prototype.toString.call(map.fallthrough)) return lookupKey(key, map.fallthrough, handle, context);
                    for (var i = 0; i < map.fallthrough.length; i++) {
                        var result = lookupKey(key, map.fallthrough[i], handle, context);
                        if (result) return result;
                    }
                }
            }
            // Modifier key presses don't count as 'real' key presses for the
            // purpose of keymap fallthrough.
            function isModifierKey(value) {
                var name = "string" == typeof value ? value : keyNames[value.keyCode];
                return "Ctrl" == name || "Alt" == name || "Shift" == name || "Mod" == name;
            }
            // Look up the name of a key as indicated by an event object.
            function keyName(event, noShift) {
                if (presto && 34 == event.keyCode && event.char) return !1;
                var base = keyNames[event.keyCode], name = base;
                return null != name && !event.altGraphKey && (event.altKey && "Alt" != base && (name = "Alt-" + name), 
                (flipCtrlCmd ? event.metaKey : event.ctrlKey) && "Ctrl" != base && (name = "Ctrl-" + name), 
                (flipCtrlCmd ? event.ctrlKey : event.metaKey) && "Cmd" != base && (name = "Cmd-" + name), 
                !noShift && event.shiftKey && "Shift" != base && (name = "Shift-" + name), name);
            }
            function getKeyMap(val) {
                return "string" == typeof val ? keyMap[val] : val;
            }
            // Helper for deleting text near the selection(s), used to implement
            // backspace, delete, and similar functionality.
            function deleteNearSelection(cm, compute) {
                // Build up a set of ranges to kill first, merging overlapping
                // ranges.
                for (var ranges = cm.doc.sel.ranges, kill = [], i = 0; i < ranges.length; i++) {
                    for (var toKill = compute(ranges[i]); kill.length && cmp(toKill.from, lst(kill).to) <= 0; ) {
                        var replaced = kill.pop();
                        if (cmp(replaced.from, toKill.from) < 0) {
                            toKill.from = replaced.from;
                            break;
                        }
                    }
                    kill.push(toKill);
                }
                // Next, remove those actual ranges.
                runInOp(cm, function() {
                    for (var i = kill.length - 1; i >= 0; i--) replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
                    ensureCursorVisible(cm);
                });
            }
            function lineStart(cm, lineN) {
                var line = getLine(cm.doc, lineN), visual = visualLine(line);
                return visual != line && (lineN = lineNo(visual)), endOfLine(!0, cm, visual, lineN, 1);
            }
            function lineEnd(cm, lineN) {
                var line = getLine(cm.doc, lineN), visual = visualLineEnd(line);
                return visual != line && (lineN = lineNo(visual)), endOfLine(!0, cm, line, lineN, -1);
            }
            function lineStartSmart(cm, pos) {
                var start = lineStart(cm, pos.line), line = getLine(cm.doc, start.line), order = getOrder(line);
                if (!order || 0 == order[0].level) {
                    var firstNonWS = Math.max(0, line.text.search(/\S/)), inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
                    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
                }
                return start;
            }
            // Run a handler that was bound to a key.
            function doHandleBinding(cm, bound, dropShift) {
                if ("string" == typeof bound && (bound = commands[bound], !bound)) return !1;
                // Ensure previous input has been read, so that the handler sees a
                // consistent view of the document
                cm.display.input.ensurePolled();
                var prevShift = cm.display.shift, done = !1;
                try {
                    cm.isReadOnly() && (cm.state.suppressEdits = !0), dropShift && (cm.display.shift = !1), 
                    done = bound(cm) != Pass;
                } finally {
                    cm.display.shift = prevShift, cm.state.suppressEdits = !1;
                }
                return done;
            }
            function lookupKeyForEditor(cm, name, handle) {
                for (var i = 0; i < cm.state.keyMaps.length; i++) {
                    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
                    if (result) return result;
                }
                return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
            }
            function dispatchKey(cm, name, e, handle) {
                var seq = cm.state.keySeq;
                if (seq) {
                    if (isModifierKey(name)) return "handled";
                    stopSeq.set(50, function() {
                        cm.state.keySeq == seq && (cm.state.keySeq = null, cm.display.input.reset());
                    }), name = seq + " " + name;
                }
                var result = lookupKeyForEditor(cm, name, handle);
                return "multi" == result && (cm.state.keySeq = name), "handled" == result && signalLater(cm, "keyHandled", cm, name, e), 
                "handled" != result && "multi" != result || (e_preventDefault(e), restartBlink(cm)), 
                seq && !result && /\'$/.test(name) ? (e_preventDefault(e), !0) : !!result;
            }
            // Handle a key from the keydown event.
            function handleKeyBinding(cm, e) {
                var name = keyName(e, !0);
                return !!name && (e.shiftKey && !cm.state.keySeq ? dispatchKey(cm, "Shift-" + name, e, function(b) {
                    return doHandleBinding(cm, b, !0);
                }) || dispatchKey(cm, name, e, function(b) {
                    if ("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b);
                }) : dispatchKey(cm, name, e, function(b) {
                    return doHandleBinding(cm, b);
                }));
            }
            // Handle a key from the keypress event
            function handleCharBinding(cm, e, ch) {
                return dispatchKey(cm, "'" + ch + "'", e, function(b) {
                    return doHandleBinding(cm, b, !0);
                });
            }
            function onKeyDown(e) {
                var cm = this;
                if (cm.curOp.focus = activeElt(), !signalDOMEvent(cm, e)) {
                    // IE does strange things with escape.
                    ie && ie_version < 11 && 27 == e.keyCode && (e.returnValue = !1);
                    var code = e.keyCode;
                    cm.display.shift = 16 == code || e.shiftKey;
                    var handled = handleKeyBinding(cm, e);
                    presto && (lastStoppedKey = handled ? code : null, // Opera has no cut event... we try to at least catch the key combo
                    !handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection("", null, "cut")), 
                    // Turn mouse into crosshair when Alt is held on Mac.
                    18 != code || /\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className) || showCrossHair(cm);
                }
            }
            function showCrossHair(cm) {
                function up(e) {
                    18 != e.keyCode && e.altKey || (rmClass(lineDiv, "CodeMirror-crosshair"), off(document, "keyup", up), 
                    off(document, "mouseover", up));
                }
                var lineDiv = cm.display.lineDiv;
                addClass(lineDiv, "CodeMirror-crosshair"), on(document, "keyup", up), on(document, "mouseover", up);
            }
            function onKeyUp(e) {
                16 == e.keyCode && (this.doc.sel.shift = !1), signalDOMEvent(this, e);
            }
            function onKeyPress(e) {
                var cm = this;
                if (!(eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)) {
                    var keyCode = e.keyCode, charCode = e.charCode;
                    if (presto && keyCode == lastStoppedKey) return lastStoppedKey = null, void e_preventDefault(e);
                    if (!presto || e.which && !(e.which < 10) || !handleKeyBinding(cm, e)) {
                        var ch = String.fromCharCode(null == charCode ? keyCode : charCode);
                        // Some browsers fire keypress events for backspace
                        "\b" != ch && (handleCharBinding(cm, e, ch) || cm.display.input.onKeyPress(e));
                    }
                }
            }
            // A mouse down can be a single click, double click, triple click,
            // start of selection drag, start of text drag, new cursor
            // (ctrl-click), rectangle drag (alt-drag), or xwin
            // middle-click-paste. Or it might be a click on something we should
            // not interfere with, such as a scrollbar or widget.
            function onMouseDown(e) {
                var cm = this, display = cm.display;
                if (!(signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch())) {
                    if (display.input.ensurePolled(), display.shift = e.shiftKey, eventInWidget(display, e)) // Briefly turn off draggability, to allow widgets to do
                    // normal dragging things.
                    return void (webkit || (display.scroller.draggable = !1, setTimeout(function() {
                        return display.scroller.draggable = !0;
                    }, 100)));
                    if (!clickInGutter(cm, e)) {
                        var start = posFromMouse(cm, e);
                        switch (window.focus(), e_button(e)) {
                          case 1:
                            // #3261: make sure, that we're not starting a second selection
                            cm.state.selectingText ? cm.state.selectingText(e) : start ? leftButtonDown(cm, e, start) : e_target(e) == display.scroller && e_preventDefault(e);
                            break;

                          case 2:
                            webkit && (cm.state.lastMiddleDown = +new Date()), start && extendSelection(cm.doc, start), 
                            setTimeout(function() {
                                return display.input.focus();
                            }, 20), e_preventDefault(e);
                            break;

                          case 3:
                            captureRightClick ? onContextMenu(cm, e) : delayBlurEvent(cm);
                        }
                    }
                }
            }
            function leftButtonDown(cm, e, start) {
                ie ? setTimeout(bind(ensureFocus, cm), 0) : cm.curOp.focus = activeElt();
                var type, now = +new Date();
                lastDoubleClick && lastDoubleClick.time > now - 400 && 0 == cmp(lastDoubleClick.pos, start) ? type = "triple" : lastClick && lastClick.time > now - 400 && 0 == cmp(lastClick.pos, start) ? (type = "double", 
                lastDoubleClick = {
                    time: now,
                    pos: start
                }) : (type = "single", lastClick = {
                    time: now,
                    pos: start
                });
                var contained, sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;
                cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && "single" == type && (contained = sel.contains(start)) > -1 && (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) && (cmp(contained.to(), start) > 0 || start.xRel < 0) ? leftButtonStartDrag(cm, e, start, modifier) : leftButtonSelect(cm, e, start, type, modifier);
            }
            // Start a text drag. When it ends, see if any dragging actually
            // happen, and treat as a click if it didn't.
            function leftButtonStartDrag(cm, e, start, modifier) {
                var display = cm.display, startTime = +new Date(), dragEnd = operation(cm, function(e2) {
                    webkit && (display.scroller.draggable = !1), cm.state.draggingText = !1, off(document, "mouseup", dragEnd), 
                    off(display.scroller, "drop", dragEnd), Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10 && (e_preventDefault(e2), 
                    !modifier && +new Date() - 200 < startTime && extendSelection(cm.doc, start), // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
                    webkit || ie && 9 == ie_version ? setTimeout(function() {
                        document.body.focus(), display.input.focus();
                    }, 20) : display.input.focus());
                });
                // Let the drag handler handle this.
                webkit && (display.scroller.draggable = !0), cm.state.draggingText = dragEnd, dragEnd.copy = mac ? e.altKey : e.ctrlKey, 
                // IE's approach to draggable
                display.scroller.dragDrop && display.scroller.dragDrop(), on(document, "mouseup", dragEnd), 
                on(display.scroller, "drop", dragEnd);
            }
            // Normal selection, as opposed to text dragging.
            function leftButtonSelect(cm, e, start, type, addNew) {
                function extendTo(pos) {
                    if (0 != cmp(lastPos, pos)) if (lastPos = pos, "rect" == type) {
                        for (var ranges = [], tabSize = cm.options.tabSize, startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize), posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize), left = Math.min(startCol, posCol), right = Math.max(startCol, posCol), line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                            var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                            left == right ? ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) : text.length > leftPos && ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                        }
                        ranges.length || ranges.push(new Range(start, start)), setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                            origin: "*mouse",
                            scroll: !1
                        }), cm.scrollIntoView(pos);
                    } else {
                        var oldRange = ourRange, anchor = oldRange.anchor, head = pos;
                        if ("single" != type) {
                            var range;
                            range = "double" == type ? cm.findWordAt(pos) : new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0))), 
                            cmp(range.anchor, anchor) > 0 ? (head = range.head, anchor = minPos(oldRange.from(), range.anchor)) : (head = range.anchor, 
                            anchor = maxPos(oldRange.to(), range.head));
                        }
                        var ranges$1 = startSel.ranges.slice(0);
                        ranges$1[ourIndex] = new Range(clipPos(doc, anchor), head), setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);
                    }
                }
                function extend(e) {
                    var curCount = ++counter, cur = posFromMouse(cm, e, !0, "rect" == type);
                    if (cur) if (0 != cmp(cur, lastPos)) {
                        cm.curOp.focus = activeElt(), extendTo(cur);
                        var visible = visibleLines(display, doc);
                        (cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm, function() {
                            counter == curCount && extend(e);
                        }), 150);
                    } else {
                        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                        outside && setTimeout(operation(cm, function() {
                            counter == curCount && (display.scroller.scrollTop += outside, extend(e));
                        }), 50);
                    }
                }
                function done(e) {
                    cm.state.selectingText = !1, counter = 1 / 0, e_preventDefault(e), display.input.focus(), 
                    off(document, "mousemove", move), off(document, "mouseup", up), doc.history.lastSelOrigin = null;
                }
                var display = cm.display, doc = cm.doc;
                e_preventDefault(e);
                var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
                if (addNew && !e.shiftKey ? (ourIndex = doc.sel.contains(start), ourRange = ourIndex > -1 ? ranges[ourIndex] : new Range(start, start)) : (ourRange = doc.sel.primary(), 
                ourIndex = doc.sel.primIndex), chromeOS ? e.shiftKey && e.metaKey : e.altKey) type = "rect", 
                addNew || (ourRange = new Range(start, start)), start = posFromMouse(cm, e, !0, !0), 
                ourIndex = -1; else if ("double" == type) {
                    var word = cm.findWordAt(start);
                    ourRange = cm.display.shift || doc.extend ? extendRange(doc, ourRange, word.anchor, word.head) : word;
                } else if ("triple" == type) {
                    var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
                    ourRange = cm.display.shift || doc.extend ? extendRange(doc, ourRange, line.anchor, line.head) : line;
                } else ourRange = extendRange(doc, ourRange, start);
                addNew ? ourIndex == -1 ? (ourIndex = ranges.length, setSelection(doc, normalizeSelection(ranges.concat([ ourRange ]), ourIndex), {
                    scroll: !1,
                    origin: "*mouse"
                })) : ranges.length > 1 && ranges[ourIndex].empty() && "single" == type && !e.shiftKey ? (setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
                    scroll: !1,
                    origin: "*mouse"
                }), startSel = doc.sel) : replaceOneSelection(doc, ourIndex, ourRange, sel_mouse) : (ourIndex = 0, 
                setSelection(doc, new Selection([ ourRange ], 0), sel_mouse), startSel = doc.sel);
                var lastPos = start, editorSize = display.wrapper.getBoundingClientRect(), counter = 0, move = operation(cm, function(e) {
                    e_button(e) ? extend(e) : done(e);
                }), up = operation(cm, done);
                cm.state.selectingText = up, on(document, "mousemove", move), on(document, "mouseup", up);
            }
            // Determines whether an event happened in the gutter, and fires the
            // handlers for the corresponding event.
            function gutterEvent(cm, e, type, prevent) {
                var mX, mY;
                try {
                    mX = e.clientX, mY = e.clientY;
                } catch (e) {
                    return !1;
                }
                if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return !1;
                prevent && e_preventDefault(e);
                var display = cm.display, lineBox = display.lineDiv.getBoundingClientRect();
                if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
                mY -= lineBox.top - display.viewOffset;
                for (var i = 0; i < cm.options.gutters.length; ++i) {
                    var g = display.gutters.childNodes[i];
                    if (g && g.getBoundingClientRect().right >= mX) {
                        var line = lineAtHeight(cm.doc, mY), gutter = cm.options.gutters[i];
                        return signal(cm, type, cm, line, gutter, e), e_defaultPrevented(e);
                    }
                }
            }
            function clickInGutter(cm, e) {
                return gutterEvent(cm, e, "gutterClick", !0);
            }
            // CONTEXT MENU HANDLING
            // To make the context menu work, we need to briefly unhide the
            // textarea (making it as unobtrusive as possible) to let the
            // right-click take effect on it.
            function onContextMenu(cm, e) {
                eventInWidget(cm.display, e) || contextMenuInGutter(cm, e) || signalDOMEvent(cm, e, "contextmenu") || cm.display.input.onContextMenu(e);
            }
            function contextMenuInGutter(cm, e) {
                return !!hasHandler(cm, "gutterContextMenu") && gutterEvent(cm, e, "gutterContextMenu", !1);
            }
            function themeChanged(cm) {
                cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), 
                clearCaches(cm);
            }
            function defineOptions(CodeMirror) {
                function option(name, deflt, handle, notOnInit) {
                    CodeMirror.defaults[name] = deflt, handle && (optionHandlers[name] = notOnInit ? function(cm, val, old) {
                        old != Init && handle(cm, val, old);
                    } : handle);
                }
                var optionHandlers = CodeMirror.optionHandlers;
                CodeMirror.defineOption = option, // Passed to option handlers when there is no old value.
                CodeMirror.Init = Init, // These two are, on init, called from the constructor because they
                // have to be initialized before the editor can start at all.
                option("value", "", function(cm, val) {
                    return cm.setValue(val);
                }, !0), option("mode", null, function(cm, val) {
                    cm.doc.modeOption = val, loadMode(cm);
                }, !0), option("indentUnit", 2, loadMode, !0), option("indentWithTabs", !1), option("smartIndent", !0), 
                option("tabSize", 4, function(cm) {
                    resetModeState(cm), clearCaches(cm), regChange(cm);
                }, !0), option("lineSeparator", null, function(cm, val) {
                    if (cm.doc.lineSep = val, val) {
                        var newBreaks = [], lineNo = cm.doc.first;
                        cm.doc.iter(function(line) {
                            for (var pos = 0; ;) {
                                var found = line.text.indexOf(val, pos);
                                if (found == -1) break;
                                pos = found + val.length, newBreaks.push(Pos(lineNo, found));
                            }
                            lineNo++;
                        });
                        for (var i = newBreaks.length - 1; i >= 0; i--) replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
                    }
                }), option("specialChars", /[\u0000-\u001f\u007f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
                    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g"), 
                    old != Init && cm.refresh();
                }), option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
                    return cm.refresh();
                }, !0), option("electricChars", !0), option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
                    throw new Error("inputStyle can not (yet) be changed in a running editor");
                }, !0), option("spellcheck", !1, function(cm, val) {
                    return cm.getInputField().spellcheck = val;
                }, !0), option("rtlMoveVisually", !windows), option("wholeLineUpdateBefore", !0), 
                option("theme", "default", function(cm) {
                    themeChanged(cm), guttersChanged(cm);
                }, !0), option("keyMap", "default", function(cm, val, old) {
                    var next = getKeyMap(val), prev = old != Init && getKeyMap(old);
                    prev && prev.detach && prev.detach(cm, next), next.attach && next.attach(cm, prev || null);
                }), option("extraKeys", null), option("lineWrapping", !1, wrappingChanged, !0), 
                option("gutters", [], function(cm) {
                    setGuttersForLineNumbers(cm.options), guttersChanged(cm);
                }, !0), option("fixedGutter", !0, function(cm, val) {
                    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0", 
                    cm.refresh();
                }, !0), option("coverGutterNextToScrollbar", !1, function(cm) {
                    return updateScrollbars(cm);
                }, !0), option("scrollbarStyle", "native", function(cm) {
                    initScrollbars(cm), updateScrollbars(cm), cm.display.scrollbars.setScrollTop(cm.doc.scrollTop), 
                    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
                }, !0), option("lineNumbers", !1, function(cm) {
                    setGuttersForLineNumbers(cm.options), guttersChanged(cm);
                }, !0), option("firstLineNumber", 1, guttersChanged, !0), option("lineNumberFormatter", function(integer) {
                    return integer;
                }, guttersChanged, !0), option("showCursorWhenSelecting", !1, updateSelection, !0), 
                option("resetSelectionOnContextMenu", !0), option("lineWiseCopyCut", !0), option("readOnly", !1, function(cm, val) {
                    "nocursor" == val ? (onBlur(cm), cm.display.input.blur(), cm.display.disabled = !0) : cm.display.disabled = !1, 
                    cm.display.input.readOnlyChanged(val);
                }), option("disableInput", !1, function(cm, val) {
                    val || cm.display.input.reset();
                }, !0), option("dragDrop", !0, dragDropChanged), option("allowDropFileTypes", null), 
                option("cursorBlinkRate", 530), option("cursorScrollMargin", 0), option("cursorHeight", 1, updateSelection, !0), 
                option("singleCursorHeightPerLine", !0, updateSelection, !0), option("workTime", 100), 
                option("workDelay", 100), option("flattenSpans", !0, resetModeState, !0), option("addModeClass", !1, resetModeState, !0), 
                option("pollInterval", 100), option("undoDepth", 200, function(cm, val) {
                    return cm.doc.history.undoDepth = val;
                }), option("historyEventDelay", 1250), option("viewportMargin", 10, function(cm) {
                    return cm.refresh();
                }, !0), option("maxHighlightLength", 1e4, resetModeState, !0), option("moveInputWithCursor", !0, function(cm, val) {
                    val || cm.display.input.resetPosition();
                }), option("tabindex", null, function(cm, val) {
                    return cm.display.input.getField().tabIndex = val || "";
                }), option("autofocus", null);
            }
            function guttersChanged(cm) {
                updateGutters(cm), regChange(cm), alignHorizontally(cm);
            }
            function dragDropChanged(cm, value, old) {
                var wasOn = old && old != Init;
                if (!value != !wasOn) {
                    var funcs = cm.display.dragFunctions, toggle = value ? on : off;
                    toggle(cm.display.scroller, "dragstart", funcs.start), toggle(cm.display.scroller, "dragenter", funcs.enter), 
                    toggle(cm.display.scroller, "dragover", funcs.over), toggle(cm.display.scroller, "dragleave", funcs.leave), 
                    toggle(cm.display.scroller, "drop", funcs.drop);
                }
            }
            function wrappingChanged(cm) {
                cm.options.lineWrapping ? (addClass(cm.display.wrapper, "CodeMirror-wrap"), cm.display.sizer.style.minWidth = "", 
                cm.display.sizerWidth = null) : (rmClass(cm.display.wrapper, "CodeMirror-wrap"), 
                findMaxLine(cm)), estimateLineHeights(cm), regChange(cm), clearCaches(cm), setTimeout(function() {
                    return updateScrollbars(cm);
                }, 100);
            }
            // A CodeMirror instance represents an editor. This is the object
            // that user code is usually dealing with.
            function CodeMirror(place, options) {
                var this$1 = this;
                if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);
                this.options = options = options ? copyObj(options) : {}, // Determine effective options based on given values and defaults.
                copyObj(defaults, options, !1), setGuttersForLineNumbers(options);
                var doc = options.value;
                "string" == typeof doc && (doc = new Doc(doc, options.mode, null, options.lineSeparator)), 
                this.doc = doc;
                var input = new CodeMirror.inputStyles[options.inputStyle](this), display = this.display = new Display(place, doc, input);
                display.wrapper.CodeMirror = this, updateGutters(this), themeChanged(this), options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), 
                initScrollbars(this), this.state = {
                    keyMaps: [],
                    // stores maps added by addKeyMap
                    overlays: [],
                    // highlighting overlays, as added by addOverlay
                    modeGen: 0,
                    // bumped when mode/overlay changes, used to invalidate highlighting info
                    overwrite: !1,
                    delayingBlurEvent: !1,
                    focused: !1,
                    suppressEdits: !1,
                    // used to disable editing during key handlers when in readOnly mode
                    pasteIncoming: !1,
                    cutIncoming: !1,
                    // help recognize paste/cut edits in input.poll
                    selectingText: !1,
                    draggingText: !1,
                    highlight: new Delayed(),
                    // stores highlight worker timeout
                    keySeq: null,
                    // Unfinished key sequence
                    specialChars: null
                }, options.autofocus && !mobile && display.input.focus(), // Override magic textarea content restore that IE sometimes does
                // on our hidden textarea on reload
                ie && ie_version < 11 && setTimeout(function() {
                    return this$1.display.input.reset(!0);
                }, 20), registerEventHandlers(this), ensureGlobalHandlers(), startOperation(this), 
                this.curOp.forceUpdate = !0, attachDoc(this, doc), options.autofocus && !mobile || this.hasFocus() ? setTimeout(bind(onFocus, this), 20) : onBlur(this);
                for (var opt in optionHandlers) optionHandlers.hasOwnProperty(opt) && optionHandlers[opt](this$1, options[opt], Init);
                maybeUpdateLineNumberWidth(this), options.finishInit && options.finishInit(this);
                for (var i = 0; i < initHooks.length; ++i) initHooks[i](this$1);
                endOperation(this), // Suppress optimizelegibility in Webkit, since it breaks text
                // measuring on line wrapping boundaries.
                webkit && options.lineWrapping && "optimizelegibility" == getComputedStyle(display.lineDiv).textRendering && (display.lineDiv.style.textRendering = "auto");
            }
            // Attach the necessary event handlers when initializing the editor
            function registerEventHandlers(cm) {
                function finishTouch() {
                    d.activeTouch && (touchFinished = setTimeout(function() {
                        return d.activeTouch = null;
                    }, 1e3), prevTouch = d.activeTouch, prevTouch.end = +new Date());
                }
                function isMouseLikeTouchEvent(e) {
                    if (1 != e.touches.length) return !1;
                    var touch = e.touches[0];
                    return touch.radiusX <= 1 && touch.radiusY <= 1;
                }
                function farAway(touch, other) {
                    if (null == other.left) return !0;
                    var dx = other.left - touch.left, dy = other.top - touch.top;
                    return dx * dx + dy * dy > 400;
                }
                var d = cm.display;
                on(d.scroller, "mousedown", operation(cm, onMouseDown)), // Older IE's will not fire a second mousedown for a double click
                ie && ie_version < 11 ? on(d.scroller, "dblclick", operation(cm, function(e) {
                    if (!signalDOMEvent(cm, e)) {
                        var pos = posFromMouse(cm, e);
                        if (pos && !clickInGutter(cm, e) && !eventInWidget(cm.display, e)) {
                            e_preventDefault(e);
                            var word = cm.findWordAt(pos);
                            extendSelection(cm.doc, word.anchor, word.head);
                        }
                    }
                })) : on(d.scroller, "dblclick", function(e) {
                    return signalDOMEvent(cm, e) || e_preventDefault(e);
                }), // Some browsers fire contextmenu *after* opening the menu, at
                // which point we can't mess with it anymore. Context menu is
                // handled in onMouseDown for these browsers.
                captureRightClick || on(d.scroller, "contextmenu", function(e) {
                    return onContextMenu(cm, e);
                });
                // Used to suppress mouse event handling when a touch happens
                var touchFinished, prevTouch = {
                    end: 0
                };
                on(d.scroller, "touchstart", function(e) {
                    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {
                        d.input.ensurePolled(), clearTimeout(touchFinished);
                        var now = +new Date();
                        d.activeTouch = {
                            start: now,
                            moved: !1,
                            prev: now - prevTouch.end <= 300 ? prevTouch : null
                        }, 1 == e.touches.length && (d.activeTouch.left = e.touches[0].pageX, d.activeTouch.top = e.touches[0].pageY);
                    }
                }), on(d.scroller, "touchmove", function() {
                    d.activeTouch && (d.activeTouch.moved = !0);
                }), on(d.scroller, "touchend", function(e) {
                    var touch = d.activeTouch;
                    if (touch && !eventInWidget(d, e) && null != touch.left && !touch.moved && new Date() - touch.start < 300) {
                        var range, pos = cm.coordsChar(d.activeTouch, "page");
                        range = !touch.prev || farAway(touch, touch.prev) ? new Range(pos, pos) : !touch.prev.prev || farAway(touch, touch.prev.prev) ? cm.findWordAt(pos) : new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))), 
                        cm.setSelection(range.anchor, range.head), cm.focus(), e_preventDefault(e);
                    }
                    finishTouch();
                }), on(d.scroller, "touchcancel", finishTouch), // Sync scrolling between fake scrollbars and real scrollable
                // area, ensure viewport is updated when scrolling.
                on(d.scroller, "scroll", function() {
                    d.scroller.clientHeight && (setScrollTop(cm, d.scroller.scrollTop), setScrollLeft(cm, d.scroller.scrollLeft, !0), 
                    signal(cm, "scroll", cm));
                }), // Listen to wheel events in order to try and update the viewport on time.
                on(d.scroller, "mousewheel", function(e) {
                    return onScrollWheel(cm, e);
                }), on(d.scroller, "DOMMouseScroll", function(e) {
                    return onScrollWheel(cm, e);
                }), // Prevent wrapper from ever scrolling
                on(d.wrapper, "scroll", function() {
                    return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
                }), d.dragFunctions = {
                    enter: function(e) {
                        signalDOMEvent(cm, e) || e_stop(e);
                    },
                    over: function(e) {
                        signalDOMEvent(cm, e) || (onDragOver(cm, e), e_stop(e));
                    },
                    start: function(e) {
                        return onDragStart(cm, e);
                    },
                    drop: operation(cm, onDrop),
                    leave: function(e) {
                        signalDOMEvent(cm, e) || clearDragCursor(cm);
                    }
                };
                var inp = d.input.getField();
                on(inp, "keyup", function(e) {
                    return onKeyUp.call(cm, e);
                }), on(inp, "keydown", operation(cm, onKeyDown)), on(inp, "keypress", operation(cm, onKeyPress)), 
                on(inp, "focus", function(e) {
                    return onFocus(cm, e);
                }), on(inp, "blur", function(e) {
                    return onBlur(cm, e);
                });
            }
            // Indent the given line. The how parameter can be "smart",
            // "add"/null, "subtract", or "prev". When aggressive is false
            // (typically set to true for forced single-line indents), empty
            // lines are not indented, and places where the mode returns Pass
            // are left alone.
            function indentLine(cm, n, how, aggressive) {
                var state, doc = cm.doc;
                null == how && (how = "add"), "smart" == how && (// Fall back to "prev" when the mode doesn't have an indentation
                // method.
                doc.mode.indent ? state = getStateBefore(cm, n) : how = "prev");
                var tabSize = cm.options.tabSize, line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
                line.stateAfter && (line.stateAfter = null);
                var indentation, curSpaceString = line.text.match(/^\s*/)[0];
                if (aggressive || /\S/.test(line.text)) {
                    if ("smart" == how && (indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text), 
                    indentation == Pass || indentation > 150)) {
                        if (!aggressive) return;
                        how = "prev";
                    }
                } else indentation = 0, how = "not";
                "prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how), 
                indentation = Math.max(0, indentation);
                var indentString = "", pos = 0;
                if (cm.options.indentWithTabs) for (var i = Math.floor(indentation / tabSize); i; --i) pos += tabSize, 
                indentString += "\t";
                if (pos < indentation && (indentString += spaceStr(indentation - pos)), indentString != curSpaceString) return replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input"), 
                line.stateAfter = null, !0;
                // Ensure that, if the cursor was in the whitespace at the start
                // of the line, it is moved to the end of that space.
                for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
                    var range = doc.sel.ranges[i$1];
                    if (range.head.line == n && range.head.ch < curSpaceString.length) {
                        var pos$1 = Pos(n, curSpaceString.length);
                        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
                        break;
                    }
                }
            }
            function setLastCopied(newLastCopied) {
                lastCopied = newLastCopied;
            }
            function applyTextInput(cm, inserted, deleted, sel, origin) {
                var doc = cm.doc;
                cm.display.shift = !1, sel || (sel = doc.sel);
                var paste = cm.state.pasteIncoming || "paste" == origin, textLines = splitLinesAuto(inserted), multiPaste = null;
                // When pasing N lines into N selections, insert one line per selection
                if (paste && sel.ranges.length > 1) if (lastCopied && lastCopied.text.join("\n") == inserted) {
                    if (sel.ranges.length % lastCopied.text.length == 0) {
                        multiPaste = [];
                        for (var i = 0; i < lastCopied.text.length; i++) multiPaste.push(doc.splitLines(lastCopied.text[i]));
                    }
                } else textLines.length == sel.ranges.length && (multiPaste = map(textLines, function(l) {
                    return [ l ];
                }));
                // Normal behavior is to insert the new text into every selection
                for (var updateInput, i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
                    var range = sel.ranges[i$1], from = range.from(), to = range.to();
                    range.empty() && (deleted && deleted > 0 ? from = Pos(from.line, from.ch - deleted) : cm.state.overwrite && !paste ? to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) : lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted && (from = to = Pos(from.line, 0))), 
                    updateInput = cm.curOp.updateInput;
                    var changeEvent = {
                        from: from,
                        to: to,
                        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                        origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
                    };
                    makeChange(cm.doc, changeEvent), signalLater(cm, "inputRead", cm, changeEvent);
                }
                inserted && !paste && triggerElectric(cm, inserted), ensureCursorVisible(cm), cm.curOp.updateInput = updateInput, 
                cm.curOp.typing = !0, cm.state.pasteIncoming = cm.state.cutIncoming = !1;
            }
            function handlePaste(e, cm) {
                var pasted = e.clipboardData && e.clipboardData.getData("Text");
                if (pasted) return e.preventDefault(), cm.isReadOnly() || cm.options.disableInput || runInOp(cm, function() {
                    return applyTextInput(cm, pasted, 0, null, "paste");
                }), !0;
            }
            function triggerElectric(cm, inserted) {
                // When an 'electric' character is inserted, immediately trigger a reindent
                if (cm.options.electricChars && cm.options.smartIndent) for (var sel = cm.doc.sel, i = sel.ranges.length - 1; i >= 0; i--) {
                    var range = sel.ranges[i];
                    if (!(range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line)) {
                        var mode = cm.getModeAt(range.head), indented = !1;
                        if (mode.electricChars) {
                            for (var j = 0; j < mode.electricChars.length; j++) if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                                indented = indentLine(cm, range.head.line, "smart");
                                break;
                            }
                        } else mode.electricInput && mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)) && (indented = indentLine(cm, range.head.line, "smart"));
                        indented && signalLater(cm, "electricInput", cm, range.head.line);
                    }
                }
            }
            function copyableRanges(cm) {
                for (var text = [], ranges = [], i = 0; i < cm.doc.sel.ranges.length; i++) {
                    var line = cm.doc.sel.ranges[i].head.line, lineRange = {
                        anchor: Pos(line, 0),
                        head: Pos(line + 1, 0)
                    };
                    ranges.push(lineRange), text.push(cm.getRange(lineRange.anchor, lineRange.head));
                }
                return {
                    text: text,
                    ranges: ranges
                };
            }
            function disableBrowserMagic(field, spellcheck) {
                field.setAttribute("autocorrect", "off"), field.setAttribute("autocapitalize", "off"), 
                field.setAttribute("spellcheck", !!spellcheck);
            }
            function hiddenTextarea() {
                var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"), div = elt("div", [ te ], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
                // The textarea is kept positioned near the cursor to prevent the
                // fact that it'll be scrolled into view on input from scrolling
                // our fake cursor out of view. On webkit, when wrap=off, paste is
                // very slow. So make the area wide instead.
                // If border: 0; -- iOS fails to open keyboard (issue #1287)
                return webkit ? te.style.width = "1000px" : te.setAttribute("wrap", "off"), ios && (te.style.border = "1px solid black"), 
                disableBrowserMagic(te), div;
            }
            // The publicly visible API. Note that methodOp(f) means
            // 'wrap f in an operation, performed on its `this` parameter'.
            // This is not the complete set of editor methods. Most of the
            // methods defined on the Doc type are also injected into
            // CodeMirror.prototype, for backwards compatibility and
            // convenience.
            function addEditorMethods(CodeMirror) {
                var optionHandlers = CodeMirror.optionHandlers, helpers = CodeMirror.helpers = {};
                CodeMirror.prototype = {
                    constructor: CodeMirror,
                    focus: function() {
                        window.focus(), this.display.input.focus();
                    },
                    setOption: function(option, value) {
                        var options = this.options, old = options[option];
                        options[option] == value && "mode" != option || (options[option] = value, optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old), 
                        signal(this, "optionChange", this, option));
                    },
                    getOption: function(option) {
                        return this.options[option];
                    },
                    getDoc: function() {
                        return this.doc;
                    },
                    addKeyMap: function(map, bottom) {
                        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
                    },
                    removeKeyMap: function(map) {
                        for (var maps = this.state.keyMaps, i = 0; i < maps.length; ++i) if (maps[i] == map || maps[i].name == map) return maps.splice(i, 1), 
                        !0;
                    },
                    addOverlay: methodOp(function(spec, options) {
                        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                        if (mode.startState) throw new Error("Overlays may not be stateful.");
                        insertSorted(this.state.overlays, {
                            mode: mode,
                            modeSpec: spec,
                            opaque: options && options.opaque,
                            priority: options && options.priority || 0
                        }, function(overlay) {
                            return overlay.priority;
                        }), this.state.modeGen++, regChange(this);
                    }),
                    removeOverlay: methodOp(function(spec) {
                        for (var this$1 = this, overlays = this.state.overlays, i = 0; i < overlays.length; ++i) {
                            var cur = overlays[i].modeSpec;
                            if (cur == spec || "string" == typeof spec && cur.name == spec) return overlays.splice(i, 1), 
                            this$1.state.modeGen++, void regChange(this$1);
                        }
                    }),
                    indentLine: methodOp(function(n, dir, aggressive) {
                        "string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract"), 
                        isLine(this.doc, n) && indentLine(this, n, dir, aggressive);
                    }),
                    indentSelection: methodOp(function(how) {
                        for (var this$1 = this, ranges = this.doc.sel.ranges, end = -1, i = 0; i < ranges.length; i++) {
                            var range = ranges[i];
                            if (range.empty()) range.head.line > end && (indentLine(this$1, range.head.line, how, !0), 
                            end = range.head.line, i == this$1.doc.sel.primIndex && ensureCursorVisible(this$1)); else {
                                var from = range.from(), to = range.to(), start = Math.max(end, from.line);
                                end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                                for (var j = start; j < end; ++j) indentLine(this$1, j, how);
                                var newRanges = this$1.doc.sel.ranges;
                                0 == from.ch && ranges.length == newRanges.length && newRanges[i].from().ch > 0 && replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                            }
                        }
                    }),
                    // Fetch the parser token for a given character. Useful for hacks
                    // that want to inspect the mode state (say, for completion).
                    getTokenAt: function(pos, precise) {
                        return takeToken(this, pos, precise);
                    },
                    getLineTokens: function(line, precise) {
                        return takeToken(this, Pos(line), precise, !0);
                    },
                    getTokenTypeAt: function(pos) {
                        pos = clipPos(this.doc, pos);
                        var type, styles = getLineStyles(this, getLine(this.doc, pos.line)), before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
                        if (0 == ch) type = styles[2]; else for (;;) {
                            var mid = before + after >> 1;
                            if ((mid ? styles[2 * mid - 1] : 0) >= ch) after = mid; else {
                                if (!(styles[2 * mid + 1] < ch)) {
                                    type = styles[2 * mid + 2];
                                    break;
                                }
                                before = mid + 1;
                            }
                        }
                        var cut = type ? type.indexOf("overlay ") : -1;
                        return cut < 0 ? type : 0 == cut ? null : type.slice(0, cut - 1);
                    },
                    getModeAt: function(pos) {
                        var mode = this.doc.mode;
                        return mode.innerMode ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode : mode;
                    },
                    getHelper: function(pos, type) {
                        return this.getHelpers(pos, type)[0];
                    },
                    getHelpers: function(pos, type) {
                        var this$1 = this, found = [];
                        if (!helpers.hasOwnProperty(type)) return found;
                        var help = helpers[type], mode = this.getModeAt(pos);
                        if ("string" == typeof mode[type]) help[mode[type]] && found.push(help[mode[type]]); else if (mode[type]) for (var i = 0; i < mode[type].length; i++) {
                            var val = help[mode[type][i]];
                            val && found.push(val);
                        } else mode.helperType && help[mode.helperType] ? found.push(help[mode.helperType]) : help[mode.name] && found.push(help[mode.name]);
                        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
                            var cur = help._global[i$1];
                            cur.pred(mode, this$1) && indexOf(found, cur.val) == -1 && found.push(cur.val);
                        }
                        return found;
                    },
                    getStateAfter: function(line, precise) {
                        var doc = this.doc;
                        return line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line), getStateBefore(this, line + 1, precise);
                    },
                    cursorCoords: function(start, mode) {
                        var pos, range = this.doc.sel.primary();
                        return pos = null == start ? range.head : "object" == typeof start ? clipPos(this.doc, start) : start ? range.from() : range.to(), 
                        cursorCoords(this, pos, mode || "page");
                    },
                    charCoords: function(pos, mode) {
                        return charCoords(this, clipPos(this.doc, pos), mode || "page");
                    },
                    coordsChar: function(coords, mode) {
                        return coords = fromCoordSystem(this, coords, mode || "page"), coordsChar(this, coords.left, coords.top);
                    },
                    lineAtHeight: function(height, mode) {
                        return height = fromCoordSystem(this, {
                            top: height,
                            left: 0
                        }, mode || "page").top, lineAtHeight(this.doc, height + this.display.viewOffset);
                    },
                    heightAtLine: function(line, mode, includeWidgets) {
                        var lineObj, end = !1;
                        if ("number" == typeof line) {
                            var last = this.doc.first + this.doc.size - 1;
                            line < this.doc.first ? line = this.doc.first : line > last && (line = last, end = !0), 
                            lineObj = getLine(this.doc, line);
                        } else lineObj = line;
                        return intoCoordSystem(this, lineObj, {
                            top: 0,
                            left: 0
                        }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
                    },
                    defaultTextHeight: function() {
                        return textHeight(this.display);
                    },
                    defaultCharWidth: function() {
                        return charWidth(this.display);
                    },
                    getViewport: function() {
                        return {
                            from: this.display.viewFrom,
                            to: this.display.viewTo
                        };
                    },
                    addWidget: function(pos, node, scroll, vert, horiz) {
                        var display = this.display;
                        pos = cursorCoords(this, clipPos(this.doc, pos));
                        var top = pos.bottom, left = pos.left;
                        if (node.style.position = "absolute", node.setAttribute("cm-ignore-events", "true"), 
                        this.display.input.setUneditable(node), display.sizer.appendChild(node), "over" == vert) top = pos.top; else if ("above" == vert || "near" == vert) {
                            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                            // Default to positioning above (if specified and possible); otherwise default to positioning below
                            ("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom), 
                            left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth);
                        }
                        node.style.top = top + "px", node.style.left = node.style.right = "", "right" == horiz ? (left = display.sizer.clientWidth - node.offsetWidth, 
                        node.style.right = "0px") : ("left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2), 
                        node.style.left = left + "px"), scroll && scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
                    },
                    triggerOnKeyDown: methodOp(onKeyDown),
                    triggerOnKeyPress: methodOp(onKeyPress),
                    triggerOnKeyUp: onKeyUp,
                    execCommand: function(cmd) {
                        if (commands.hasOwnProperty(cmd)) return commands[cmd].call(null, this);
                    },
                    triggerElectric: methodOp(function(text) {
                        triggerElectric(this, text);
                    }),
                    findPosH: function(from, amount, unit, visually) {
                        var this$1 = this, dir = 1;
                        amount < 0 && (dir = -1, amount = -amount);
                        for (var cur = clipPos(this.doc, from), i = 0; i < amount && (cur = findPosH(this$1.doc, cur, dir, unit, visually), 
                        !cur.hitSide); ++i) ;
                        return cur;
                    },
                    moveH: methodOp(function(dir, unit) {
                        var this$1 = this;
                        this.extendSelectionsBy(function(range) {
                            return this$1.display.shift || this$1.doc.extend || range.empty() ? findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) : dir < 0 ? range.from() : range.to();
                        }, sel_move);
                    }),
                    deleteH: methodOp(function(dir, unit) {
                        var sel = this.doc.sel, doc = this.doc;
                        sel.somethingSelected() ? doc.replaceSelection("", null, "+delete") : deleteNearSelection(this, function(range) {
                            var other = findPosH(doc, range.head, dir, unit, !1);
                            return dir < 0 ? {
                                from: other,
                                to: range.head
                            } : {
                                from: range.head,
                                to: other
                            };
                        });
                    }),
                    findPosV: function(from, amount, unit, goalColumn) {
                        var this$1 = this, dir = 1, x = goalColumn;
                        amount < 0 && (dir = -1, amount = -amount);
                        for (var cur = clipPos(this.doc, from), i = 0; i < amount; ++i) {
                            var coords = cursorCoords(this$1, cur, "div");
                            if (null == x ? x = coords.left : coords.left = x, cur = findPosV(this$1, coords, dir, unit), 
                            cur.hitSide) break;
                        }
                        return cur;
                    },
                    moveV: methodOp(function(dir, unit) {
                        var this$1 = this, doc = this.doc, goals = [], collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
                        if (doc.extendSelectionsBy(function(range) {
                            if (collapse) return dir < 0 ? range.from() : range.to();
                            var headPos = cursorCoords(this$1, range.head, "div");
                            null != range.goalColumn && (headPos.left = range.goalColumn), goals.push(headPos.left);
                            var pos = findPosV(this$1, headPos, dir, unit);
                            return "page" == unit && range == doc.sel.primary() && addToScrollPos(this$1, null, charCoords(this$1, pos, "div").top - headPos.top), 
                            pos;
                        }, sel_move), goals.length) for (var i = 0; i < doc.sel.ranges.length; i++) doc.sel.ranges[i].goalColumn = goals[i];
                    }),
                    // Find the word at the given position (as returned by coordsChar).
                    findWordAt: function(pos) {
                        var doc = this.doc, line = getLine(doc, pos.line).text, start = pos.ch, end = pos.ch;
                        if (line) {
                            var helper = this.getHelper(pos, "wordChars");
                            "before" != pos.sticky && end != line.length || !start ? ++end : --start;
                            for (var startChar = line.charAt(start), check = isWordChar(startChar, helper) ? function(ch) {
                                return isWordChar(ch, helper);
                            } : /\s/.test(startChar) ? function(ch) {
                                return /\s/.test(ch);
                            } : function(ch) {
                                return !/\s/.test(ch) && !isWordChar(ch);
                            }; start > 0 && check(line.charAt(start - 1)); ) --start;
                            for (;end < line.length && check(line.charAt(end)); ) ++end;
                        }
                        return new Range(Pos(pos.line, start), Pos(pos.line, end));
                    },
                    toggleOverwrite: function(value) {
                        null != value && value == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? addClass(this.display.cursorDiv, "CodeMirror-overwrite") : rmClass(this.display.cursorDiv, "CodeMirror-overwrite"), 
                        signal(this, "overwriteToggle", this, this.state.overwrite));
                    },
                    hasFocus: function() {
                        return this.display.input.getField() == activeElt();
                    },
                    isReadOnly: function() {
                        return !(!this.options.readOnly && !this.doc.cantEdit);
                    },
                    scrollTo: methodOp(function(x, y) {
                        null == x && null == y || resolveScrollToPos(this), null != x && (this.curOp.scrollLeft = x), 
                        null != y && (this.curOp.scrollTop = y);
                    }),
                    getScrollInfo: function() {
                        var scroller = this.display.scroller;
                        return {
                            left: scroller.scrollLeft,
                            top: scroller.scrollTop,
                            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                            clientHeight: displayHeight(this),
                            clientWidth: displayWidth(this)
                        };
                    },
                    scrollIntoView: methodOp(function(range, margin) {
                        if (null == range ? (range = {
                            from: this.doc.sel.primary().head,
                            to: null
                        }, null == margin && (margin = this.options.cursorScrollMargin)) : "number" == typeof range ? range = {
                            from: Pos(range, 0),
                            to: null
                        } : null == range.from && (range = {
                            from: range,
                            to: null
                        }), range.to || (range.to = range.from), range.margin = margin || 0, null != range.from.line) resolveScrollToPos(this), 
                        this.curOp.scrollToPos = range; else {
                            var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
                            this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
                        }
                    }),
                    setSize: methodOp(function(width, height) {
                        var this$1 = this, interpret = function(val) {
                            return "number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val;
                        };
                        null != width && (this.display.wrapper.style.width = interpret(width)), null != height && (this.display.wrapper.style.height = interpret(height)), 
                        this.options.lineWrapping && clearLineMeasurementCache(this);
                        var lineNo = this.display.viewFrom;
                        this.doc.iter(lineNo, this.display.viewTo, function(line) {
                            if (line.widgets) for (var i = 0; i < line.widgets.length; i++) if (line.widgets[i].noHScroll) {
                                regLineChange(this$1, lineNo, "widget");
                                break;
                            }
                            ++lineNo;
                        }), this.curOp.forceUpdate = !0, signal(this, "refresh", this);
                    }),
                    operation: function(f) {
                        return runInOp(this, f);
                    },
                    refresh: methodOp(function() {
                        var oldHeight = this.display.cachedTextHeight;
                        regChange(this), this.curOp.forceUpdate = !0, clearCaches(this), this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop), 
                        updateGutterSpace(this), (null == oldHeight || Math.abs(oldHeight - textHeight(this.display)) > .5) && estimateLineHeights(this), 
                        signal(this, "refresh", this);
                    }),
                    swapDoc: methodOp(function(doc) {
                        var old = this.doc;
                        return old.cm = null, attachDoc(this, doc), clearCaches(this), this.display.input.reset(), 
                        this.scrollTo(doc.scrollLeft, doc.scrollTop), this.curOp.forceScroll = !0, signalLater(this, "swapDoc", this, old), 
                        old;
                    }),
                    getInputField: function() {
                        return this.display.input.getField();
                    },
                    getWrapperElement: function() {
                        return this.display.wrapper;
                    },
                    getScrollerElement: function() {
                        return this.display.scroller;
                    },
                    getGutterElement: function() {
                        return this.display.gutters;
                    }
                }, eventMixin(CodeMirror), CodeMirror.registerHelper = function(type, name, value) {
                    helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {
                        _global: []
                    }), helpers[type][name] = value;
                }, CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
                    CodeMirror.registerHelper(type, name, value), helpers[type]._global.push({
                        pred: predicate,
                        val: value
                    });
                };
            }
            // Used for horizontal relative motion. Dir is -1 or 1 (left or
            // right), unit can be "char", "column" (like char, but doesn't
            // cross line boundaries), "word" (across next word), or "group" (to
            // the start of next group of word or non-word-non-whitespace
            // chars). The visually param controls whether, in right-to-left
            // text, direction 1 means to move towards the next index in the
            // string, or towards the character to the right of the current
            // position. The resulting position will have a hitSide=true
            // property if it reached the end of the document.
            function findPosH(doc, pos, dir, unit, visually) {
                function findNextLine() {
                    var l = pos.line + dir;
                    return !(l < doc.first || l >= doc.first + doc.size) && (pos = new Pos(l, pos.ch, pos.sticky), 
                    lineObj = getLine(doc, l));
                }
                function moveOnce(boundToLine) {
                    var next;
                    if (next = visually ? moveVisually(doc.cm, lineObj, pos, dir) : moveLogically(lineObj, pos, dir), 
                    null == next) {
                        if (boundToLine || !findNextLine()) return !1;
                        pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir);
                    } else pos = next;
                    return !0;
                }
                var oldPos = pos, origDir = dir, lineObj = getLine(doc, pos.line);
                if ("char" == unit) moveOnce(); else if ("column" == unit) moveOnce(!0); else if ("word" == unit || "group" == unit) for (var sawType = null, group = "group" == unit, helper = doc.cm && doc.cm.getHelper(pos, "wordChars"), first = !0; !(dir < 0) || moveOnce(!first); first = !1) {
                    var cur = lineObj.text.charAt(pos.ch) || "\n", type = isWordChar(cur, helper) ? "w" : group && "\n" == cur ? "n" : !group || /\s/.test(cur) ? null : "p";
                    if (!group || first || type || (type = "s"), sawType && sawType != type) {
                        dir < 0 && (dir = 1, moveOnce(), pos.sticky = "after");
                        break;
                    }
                    if (type && (sawType = type), dir > 0 && !moveOnce(!first)) break;
                }
                var result = skipAtomic(doc, pos, oldPos, origDir, !0);
                return equalCursorPos(oldPos, result) && (result.hitSide = !0), result;
            }
            // For relative vertical movement. Dir may be -1 or 1. Unit can be
            // "page" or "line". The resulting position will have a hitSide=true
            // property if it reached the end of the document.
            function findPosV(cm, pos, dir, unit) {
                var y, doc = cm.doc, x = pos.left;
                if ("page" == unit) {
                    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
                    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
                } else "line" == unit && (y = dir > 0 ? pos.bottom + 3 : pos.top - 3);
                for (var target; target = coordsChar(cm, x, y), target.outside; ) {
                    if (dir < 0 ? y <= 0 : y >= doc.height) {
                        target.hitSide = !0;
                        break;
                    }
                    y += 5 * dir;
                }
                return target;
            }
            function posToDOM(cm, pos) {
                var view = findViewForLine(cm, pos.line);
                if (!view || view.hidden) return null;
                var line = getLine(cm.doc, pos.line), info = mapFromLineView(view, line, pos.line), order = getOrder(line), side = "left";
                if (order) {
                    var partPos = getBidiPartAt(order, pos.ch);
                    side = partPos % 2 ? "right" : "left";
                }
                var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
                return result.offset = "right" == result.collapse ? result.end : result.start, result;
            }
            function badPos(pos, bad) {
                return bad && (pos.bad = !0), pos;
            }
            function domTextBetween(cm, from, to, fromLine, toLine) {
                function recognizeMarker(id) {
                    return function(marker) {
                        return marker.id == id;
                    };
                }
                function walk(node) {
                    if (1 == node.nodeType) {
                        var cmText = node.getAttribute("cm-text");
                        if (null != cmText) return void (text += "" == cmText ? node.textContent.replace(/\u200b/g, "") : cmText);
                        var range, markerID = node.getAttribute("cm-marker");
                        if (markerID) {
                            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                            return void (found.length && (range = found[0].find()) && (text += getBetween(cm.doc, range.from, range.to).join(lineSep)));
                        }
                        if ("false" == node.getAttribute("contenteditable")) return;
                        for (var i = 0; i < node.childNodes.length; i++) walk(node.childNodes[i]);
                        /^(pre|div|p)$/i.test(node.nodeName) && (closing = !0);
                    } else if (3 == node.nodeType) {
                        var val = node.nodeValue;
                        if (!val) return;
                        closing && (text += lineSep, closing = !1), text += val;
                    }
                }
                for (var text = "", closing = !1, lineSep = cm.doc.lineSeparator(); walk(from), 
                from != to; ) from = from.nextSibling;
                return text;
            }
            function domToPos(cm, node, offset) {
                var lineNode;
                if (node == cm.display.lineDiv) {
                    if (lineNode = cm.display.lineDiv.childNodes[offset], !lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), !0);
                    node = null, offset = 0;
                } else for (lineNode = node; ;lineNode = lineNode.parentNode) {
                    if (!lineNode || lineNode == cm.display.lineDiv) return null;
                    if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;
                }
                for (var i = 0; i < cm.display.view.length; i++) {
                    var lineView = cm.display.view[i];
                    if (lineView.node == lineNode) return locateNodeInLineView(lineView, node, offset);
                }
            }
            function locateNodeInLineView(lineView, node, offset) {
                function find(textNode, topNode, offset) {
                    for (var i = -1; i < (maps ? maps.length : 0); i++) for (var map = i < 0 ? measure.map : maps[i], j = 0; j < map.length; j += 3) {
                        var curNode = map[j + 2];
                        if (curNode == textNode || curNode == topNode) {
                            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]), ch = map[j] + offset;
                            return (offset < 0 || curNode != textNode) && (ch = map[j + (offset ? 1 : 0)]), 
                            Pos(line, ch);
                        }
                    }
                }
                var wrapper = lineView.text.firstChild, bad = !1;
                if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), !0);
                if (node == wrapper && (bad = !0, node = wrapper.childNodes[offset], offset = 0, 
                !node)) {
                    var line = lineView.rest ? lst(lineView.rest) : lineView.line;
                    return badPos(Pos(lineNo(line), line.text.length), bad);
                }
                var textNode = 3 == node.nodeType ? node : null, topNode = node;
                for (textNode || 1 != node.childNodes.length || 3 != node.firstChild.nodeType || (textNode = node.firstChild, 
                offset && (offset = textNode.nodeValue.length)); topNode.parentNode != wrapper; ) topNode = topNode.parentNode;
                var measure = lineView.measure, maps = measure.maps, found = find(textNode, topNode, offset);
                if (found) return badPos(found, bad);
                // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
                for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
                    if (found = find(after, after.firstChild, 0)) return badPos(Pos(found.line, found.ch - dist), bad);
                    dist += after.textContent.length;
                }
                for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
                    if (found = find(before, before.firstChild, -1)) return badPos(Pos(found.line, found.ch + dist$1), bad);
                    dist$1 += before.textContent.length;
                }
            }
            function fromTextArea(textarea, options) {
                function save() {
                    textarea.value = cm.getValue();
                }
                // Set autofocus to true if this textarea is focused, or if it has
                // autofocus and no other element is focused.
                if (options = options ? copyObj(options) : {}, options.value = textarea.value, !options.tabindex && textarea.tabIndex && (options.tabindex = textarea.tabIndex), 
                !options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder), 
                null == options.autofocus) {
                    var hasFocus = activeElt();
                    options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body;
                }
                var realSubmit;
                if (textarea.form && (on(textarea.form, "submit", save), !options.leaveSubmitMethodAlone)) {
                    var form = textarea.form;
                    realSubmit = form.submit;
                    try {
                        var wrappedSubmit = form.submit = function() {
                            save(), form.submit = realSubmit, form.submit(), form.submit = wrappedSubmit;
                        };
                    } catch (e) {}
                }
                options.finishInit = function(cm) {
                    cm.save = save, cm.getTextArea = function() {
                        return textarea;
                    }, cm.toTextArea = function() {
                        cm.toTextArea = isNaN, // Prevent this from being ran twice
                        save(), textarea.parentNode.removeChild(cm.getWrapperElement()), textarea.style.display = "", 
                        textarea.form && (off(textarea.form, "submit", save), "function" == typeof textarea.form.submit && (textarea.form.submit = realSubmit));
                    };
                }, textarea.style.display = "none";
                var cm = CodeMirror(function(node) {
                    return textarea.parentNode.insertBefore(node, textarea.nextSibling);
                }, options);
                return cm;
            }
            function addLegacyProps(CodeMirror) {
                CodeMirror.off = off, CodeMirror.on = on, CodeMirror.wheelEventPixels = wheelEventPixels, 
                CodeMirror.Doc = Doc, CodeMirror.splitLines = splitLinesAuto, CodeMirror.countColumn = countColumn, 
                CodeMirror.findColumn = findColumn, CodeMirror.isWordChar = isWordCharBasic, CodeMirror.Pass = Pass, 
                CodeMirror.signal = signal, CodeMirror.Line = Line, CodeMirror.changeEnd = changeEnd, 
                CodeMirror.scrollbarModel = scrollbarModel, CodeMirror.Pos = Pos, CodeMirror.cmpPos = cmp, 
                CodeMirror.modes = modes, CodeMirror.mimeModes = mimeModes, CodeMirror.resolveMode = resolveMode, 
                CodeMirror.getMode = getMode, CodeMirror.modeExtensions = modeExtensions, CodeMirror.extendMode = extendMode, 
                CodeMirror.copyState = copyState, CodeMirror.startState = startState, CodeMirror.innerMode = innerMode, 
                CodeMirror.commands = commands, CodeMirror.keyMap = keyMap, CodeMirror.keyName = keyName, 
                CodeMirror.isModifierKey = isModifierKey, CodeMirror.lookupKey = lookupKey, CodeMirror.normalizeKeyMap = normalizeKeyMap, 
                CodeMirror.StringStream = StringStream, CodeMirror.SharedTextMarker = SharedTextMarker, 
                CodeMirror.TextMarker = TextMarker, CodeMirror.LineWidget = LineWidget, CodeMirror.e_preventDefault = e_preventDefault, 
                CodeMirror.e_stopPropagation = e_stopPropagation, CodeMirror.e_stop = e_stop, CodeMirror.addClass = addClass, 
                CodeMirror.contains = contains, CodeMirror.rmClass = rmClass, CodeMirror.keyNames = keyNames;
            }
            // Kludges for bugs and behavior differences that can't be feature
            // detected are enabled based on userAgent etc sniffing.
            var userAgent = navigator.userAgent, platform = navigator.platform, gecko = /gecko\/\d/i.test(userAgent), ie_upto10 = /MSIE \d/.test(userAgent), ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent), edge = /Edge\/(\d+)/.exec(userAgent), ie = ie_upto10 || ie_11up || edge, ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]), webkit = !edge && /WebKit\//.test(userAgent), qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent), chrome = !edge && /Chrome\//.test(userAgent), presto = /Opera\//.test(userAgent), safari = /Apple Computer/.test(navigator.vendor), mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent), phantom = /PhantomJS/.test(userAgent), ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent), mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent), mac = ios || /Mac/.test(platform), chromeOS = /\bCrOS\b/.test(userAgent), windows = /win/i.test(platform), presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
            presto_version && (presto_version = Number(presto_version[1])), presto_version && presto_version >= 15 && (presto = !1, 
            webkit = !0);
            // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
            var range, flipCtrlCmd = mac && (qtwebkit || presto && (null == presto_version || presto_version < 12.11)), captureRightClick = gecko || ie && ie_version >= 9, rmClass = function(node, cls) {
                var current = node.className, match = classTest(cls).exec(current);
                if (match) {
                    var after = current.slice(match.index + match[0].length);
                    node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
                }
            };
            range = document.createRange ? function(node, start, end, endNode) {
                var r = document.createRange();
                return r.setEnd(endNode || node, end), r.setStart(node, start), r;
            } : function(node, start, end) {
                var r = document.body.createTextRange();
                try {
                    r.moveToElementText(node.parentNode);
                } catch (e) {
                    return r;
                }
                return r.collapse(!0), r.moveEnd("character", end), r.moveStart("character", start), 
                r;
            };
            var selectInput = function(node) {
                node.select();
            };
            ios ? selectInput = function(node) {
                node.selectionStart = 0, node.selectionEnd = node.value.length;
            } : ie && (selectInput = function(node) {
                try {
                    node.select();
                } catch (_e) {}
            });
            var Delayed = function() {
                this.id = null;
            };
            Delayed.prototype.set = function(ms, f) {
                clearTimeout(this.id), this.id = setTimeout(f, ms);
            };
            // Number of pixels added to scroller and sizer to hide scrollbar
            var zwspSupported, badBidiRects, scrollerGap = 30, Pass = {
                toString: function() {
                    return "CodeMirror.Pass";
                }
            }, sel_dontScroll = {
                scroll: !1
            }, sel_mouse = {
                origin: "*mouse"
            }, sel_move = {
                origin: "+move"
            }, spaceStrs = [ "" ], nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/, extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/, sawReadOnlySpans = !1, sawCollapsedSpans = !1, bidiOther = null, bidiOrdering = function() {
                function charType(code) {
                    return code <= 247 ? lowTypes.charAt(code) : 1424 <= code && code <= 1524 ? "R" : 1536 <= code && code <= 1785 ? arabicTypes.charAt(code - 1536) : 1774 <= code && code <= 2220 ? "r" : 8192 <= code && code <= 8203 ? "w" : 8204 == code ? "b" : "L";
                }
                function BidiSpan(level, from, to) {
                    this.level = level, this.from = from, this.to = to;
                }
                // Character types for codepoints 0 to 0xff
                var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111", bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/, outerType = "L";
                return function(str) {
                    if (!bidiRE.test(str)) return !1;
                    for (var len = str.length, types = [], i = 0; i < len; ++i) types.push(charType(str.charCodeAt(i)));
                    // W1. Examine each non-spacing mark (NSM) in the level run, and
                    // change the type of the NSM to the type of the previous
                    // character. If the NSM is at the start of the level run, it will
                    // get the type of sor.
                    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
                        var type = types[i$1];
                        "m" == type ? types[i$1] = prev : prev = type;
                    }
                    // W2. Search backwards from each instance of a European number
                    // until the first strong type (R, L, AL, or sor) is found. If an
                    // AL is found, change the type of the European number to Arabic
                    // number.
                    // W3. Change all ALs to R.
                    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
                        var type$1 = types[i$2];
                        "1" == type$1 && "r" == cur ? types[i$2] = "n" : isStrong.test(type$1) && (cur = type$1, 
                        "r" == type$1 && (types[i$2] = "R"));
                    }
                    // W4. A single European separator between two European numbers
                    // changes to a European number. A single common separator between
                    // two numbers of the same type changes to that type.
                    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
                        var type$2 = types[i$3];
                        "+" == type$2 && "1" == prev$1 && "1" == types[i$3 + 1] ? types[i$3] = "1" : "," != type$2 || prev$1 != types[i$3 + 1] || "1" != prev$1 && "n" != prev$1 || (types[i$3] = prev$1), 
                        prev$1 = type$2;
                    }
                    // W5. A sequence of European terminators adjacent to European
                    // numbers changes to all European numbers.
                    // W6. Otherwise, separators and terminators change to Other
                    // Neutral.
                    for (var i$4 = 0; i$4 < len; ++i$4) {
                        var type$3 = types[i$4];
                        if ("," == type$3) types[i$4] = "N"; else if ("%" == type$3) {
                            var end = void 0;
                            for (end = i$4 + 1; end < len && "%" == types[end]; ++end) ;
                            for (var replace = i$4 && "!" == types[i$4 - 1] || end < len && "1" == types[end] ? "1" : "N", j = i$4; j < end; ++j) types[j] = replace;
                            i$4 = end - 1;
                        }
                    }
                    // W7. Search backwards from each instance of a European number
                    // until the first strong type (R, L, or sor) is found. If an L is
                    // found, then change the type of the European number to L.
                    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
                        var type$4 = types[i$5];
                        "L" == cur$1 && "1" == type$4 ? types[i$5] = "L" : isStrong.test(type$4) && (cur$1 = type$4);
                    }
                    // N1. A sequence of neutrals takes the direction of the
                    // surrounding strong text if the text on both sides has the same
                    // direction. European and Arabic numbers act as if they were R in
                    // terms of their influence on neutrals. Start-of-level-run (sor)
                    // and end-of-level-run (eor) are used at level run boundaries.
                    // N2. Any remaining neutrals take the embedding direction.
                    for (var i$6 = 0; i$6 < len; ++i$6) if (isNeutral.test(types[i$6])) {
                        var end$1 = void 0;
                        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) ;
                        for (var before = "L" == (i$6 ? types[i$6 - 1] : outerType), after = "L" == (end$1 < len ? types[end$1] : outerType), replace$1 = before || after ? "L" : "R", j$1 = i$6; j$1 < end$1; ++j$1) types[j$1] = replace$1;
                        i$6 = end$1 - 1;
                    }
                    for (var m, order = [], i$7 = 0; i$7 < len; ) if (countsAsLeft.test(types[i$7])) {
                        var start = i$7;
                        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) ;
                        order.push(new BidiSpan(0, start, i$7));
                    } else {
                        var pos = i$7, at = order.length;
                        for (++i$7; i$7 < len && "L" != types[i$7]; ++i$7) ;
                        for (var j$2 = pos; j$2 < i$7; ) if (countsAsNum.test(types[j$2])) {
                            pos < j$2 && order.splice(at, 0, new BidiSpan(1, pos, j$2));
                            var nstart = j$2;
                            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) ;
                            order.splice(at, 0, new BidiSpan(2, nstart, j$2)), pos = j$2;
                        } else ++j$2;
                        pos < i$7 && order.splice(at, 0, new BidiSpan(1, pos, i$7));
                    }
                    return 1 == order[0].level && (m = str.match(/^\s+/)) && (order[0].from = m[0].length, 
                    order.unshift(new BidiSpan(0, 0, m[0].length))), 1 == lst(order).level && (m = str.match(/\s+$/)) && (lst(order).to -= m[0].length, 
                    order.push(new BidiSpan(0, len - m[0].length, len))), order;
                };
            }(), noHandlers = [], on = function(emitter, type, f) {
                if (emitter.addEventListener) emitter.addEventListener(type, f, !1); else if (emitter.attachEvent) emitter.attachEvent("on" + type, f); else {
                    var map = emitter._handlers || (emitter._handlers = {});
                    map[type] = (map[type] || noHandlers).concat(f);
                }
            }, dragAndDrop = function() {
                // There is *some* kind of drag-and-drop support in IE6-8, but I
                // couldn't get it to work yet.
                if (ie && ie_version < 9) return !1;
                var div = elt("div");
                return "draggable" in div || "dragDrop" in div;
            }(), splitLinesAuto = 3 != "\n\nb".split(/\n/).length ? function(string) {
                for (var pos = 0, result = [], l = string.length; pos <= l; ) {
                    var nl = string.indexOf("\n", pos);
                    nl == -1 && (nl = string.length);
                    var line = string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl), rt = line.indexOf("\r");
                    rt != -1 ? (result.push(line.slice(0, rt)), pos += rt + 1) : (result.push(line), 
                    pos = nl + 1);
                }
                return result;
            } : function(string) {
                return string.split(/\r\n?|\n/);
            }, hasSelection = window.getSelection ? function(te) {
                try {
                    return te.selectionStart != te.selectionEnd;
                } catch (e) {
                    return !1;
                }
            } : function(te) {
                var range;
                try {
                    range = te.ownerDocument.selection.createRange();
                } catch (e) {}
                return !(!range || range.parentElement() != te) && 0 != range.compareEndPoints("StartToEnd", range);
            }, hasCopyEvent = function() {
                var e = elt("div");
                return "oncopy" in e || (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy);
            }(), badZoomedRects = null, modes = {}, mimeModes = {}, modeExtensions = {}, StringStream = function(string, tabSize) {
                this.pos = this.start = 0, this.string = string, this.tabSize = tabSize || 8, this.lastColumnPos = this.lastColumnValue = 0, 
                this.lineStart = 0;
            };
            StringStream.prototype.eol = function() {
                return this.pos >= this.string.length;
            }, StringStream.prototype.sol = function() {
                return this.pos == this.lineStart;
            }, StringStream.prototype.peek = function() {
                return this.string.charAt(this.pos) || void 0;
            }, StringStream.prototype.next = function() {
                if (this.pos < this.string.length) return this.string.charAt(this.pos++);
            }, StringStream.prototype.eat = function(match) {
                var ok, ch = this.string.charAt(this.pos);
                if (ok = "string" == typeof match ? ch == match : ch && (match.test ? match.test(ch) : match(ch))) return ++this.pos, 
                ch;
            }, StringStream.prototype.eatWhile = function(match) {
                for (var start = this.pos; this.eat(match); ) ;
                return this.pos > start;
            }, StringStream.prototype.eatSpace = function() {
                for (var this$1 = this, start = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); ) ++this$1.pos;
                return this.pos > start;
            }, StringStream.prototype.skipToEnd = function() {
                this.pos = this.string.length;
            }, StringStream.prototype.skipTo = function(ch) {
                var found = this.string.indexOf(ch, this.pos);
                if (found > -1) return this.pos = found, !0;
            }, StringStream.prototype.backUp = function(n) {
                this.pos -= n;
            }, StringStream.prototype.column = function() {
                return this.lastColumnPos < this.start && (this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), 
                this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
            }, StringStream.prototype.indentation = function() {
                return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
            }, StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
                if ("string" != typeof pattern) {
                    var match = this.string.slice(this.pos).match(pattern);
                    return match && match.index > 0 ? null : (match && consume !== !1 && (this.pos += match[0].length), 
                    match);
                }
                var cased = function(str) {
                    return caseInsensitive ? str.toLowerCase() : str;
                }, substr = this.string.substr(this.pos, pattern.length);
                if (cased(substr) == cased(pattern)) return consume !== !1 && (this.pos += pattern.length), 
                !0;
            }, StringStream.prototype.current = function() {
                return this.string.slice(this.start, this.pos);
            }, StringStream.prototype.hideFirstChars = function(n, inner) {
                this.lineStart += n;
                try {
                    return inner();
                } finally {
                    this.lineStart -= n;
                }
            };
            // LINE DATA STRUCTURE
            // Line objects. These hold state related to a line, including
            // highlighting info (the styles array).
            var Line = function(text, markedSpans, estimateHeight) {
                this.text = text, attachMarkedSpans(this, markedSpans), this.height = estimateHeight ? estimateHeight(this) : 1;
            };
            Line.prototype.lineNo = function() {
                return lineNo(this);
            }, eventMixin(Line);
            // Convert a style as returned by a mode (either null, or a string
            // containing one or more styles) to a CSS style. This is cached,
            // and also looks for line-wide styles.
            var measureText, styleToClassCache = {}, styleToClassCacheWithMode = {}, operationGroup = null, orphanDelayedCallbacks = null, nullRect = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, wheelSamples = 0, wheelPixelsPerUnit = null;
            // Fill in a browser-detected starting value on browsers where we
            // know one. These don't have to be accurate -- the result of them
            // being wrong would just be a slight flicker on the first wheel
            // scroll (if it is large enough).
            ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);
            var NativeScrollbars = function(place, scroll, cm) {
                this.cm = cm;
                var vert = this.vert = elt("div", [ elt("div", null, null, "min-width: 1px") ], "CodeMirror-vscrollbar"), horiz = this.horiz = elt("div", [ elt("div", null, null, "height: 100%; min-height: 1px") ], "CodeMirror-hscrollbar");
                place(vert), place(horiz), on(vert, "scroll", function() {
                    vert.clientHeight && scroll(vert.scrollTop, "vertical");
                }), on(horiz, "scroll", function() {
                    horiz.clientWidth && scroll(horiz.scrollLeft, "horizontal");
                }), this.checkedZeroWidth = !1, // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
                ie && ie_version < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
            };
            NativeScrollbars.prototype.update = function(measure) {
                var needsH = measure.scrollWidth > measure.clientWidth + 1, needsV = measure.scrollHeight > measure.clientHeight + 1, sWidth = measure.nativeBarWidth;
                if (needsV) {
                    this.vert.style.display = "block", this.vert.style.bottom = needsH ? sWidth + "px" : "0";
                    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
                    // A bug in IE8 can cause this value to be negative, so guard it.
                    this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
                } else this.vert.style.display = "", this.vert.firstChild.style.height = "0";
                if (needsH) {
                    this.horiz.style.display = "block", this.horiz.style.right = needsV ? sWidth + "px" : "0", 
                    this.horiz.style.left = measure.barLeft + "px";
                    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
                    this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
                } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
                return !this.checkedZeroWidth && measure.clientHeight > 0 && (0 == sWidth && this.zeroWidthHack(), 
                this.checkedZeroWidth = !0), {
                    right: needsV ? sWidth : 0,
                    bottom: needsH ? sWidth : 0
                };
            }, NativeScrollbars.prototype.setScrollLeft = function(pos) {
                this.horiz.scrollLeft != pos && (this.horiz.scrollLeft = pos), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz);
            }, NativeScrollbars.prototype.setScrollTop = function(pos) {
                this.vert.scrollTop != pos && (this.vert.scrollTop = pos), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert);
            }, NativeScrollbars.prototype.zeroWidthHack = function() {
                var w = mac && !mac_geMountainLion ? "12px" : "18px";
                this.horiz.style.height = this.vert.style.width = w, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", 
                this.disableHoriz = new Delayed(), this.disableVert = new Delayed();
            }, NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay) {
                function maybeDisable() {
                    // To find out whether the scrollbar is still visible, we
                    // check whether the element under the pixel in the bottom
                    // left corner of the scrollbar box is the scrollbar box
                    // itself (when the bar is still visible) or its filler child
                    // (when the bar is hidden). If it is still visible, we keep
                    // it enabled, if it's hidden, we disable pointer events.
                    var box = bar.getBoundingClientRect(), elt = document.elementFromPoint(box.left + 1, box.bottom - 1);
                    elt != bar ? bar.style.pointerEvents = "none" : delay.set(1e3, maybeDisable);
                }
                bar.style.pointerEvents = "auto", delay.set(1e3, maybeDisable);
            }, NativeScrollbars.prototype.clear = function() {
                var parent = this.horiz.parentNode;
                parent.removeChild(this.horiz), parent.removeChild(this.vert);
            };
            var NullScrollbars = function() {};
            NullScrollbars.prototype.update = function() {
                return {
                    bottom: 0,
                    right: 0
                };
            }, NullScrollbars.prototype.setScrollLeft = function() {}, NullScrollbars.prototype.setScrollTop = function() {}, 
            NullScrollbars.prototype.clear = function() {};
            var scrollbarModel = {
                native: NativeScrollbars,
                null: NullScrollbars
            }, nextOpId = 0, DisplayUpdate = function(cm, viewport, force) {
                var display = cm.display;
                this.viewport = viewport, // Store some values that we'll need later (but don't want to force a relayout for)
                this.visible = visibleLines(display, cm.doc, viewport), this.editorIsHidden = !display.wrapper.offsetWidth, 
                this.wrapperHeight = display.wrapper.clientHeight, this.wrapperWidth = display.wrapper.clientWidth, 
                this.oldDisplayWidth = displayWidth(cm), this.force = force, this.dims = getDimensions(cm), 
                this.events = [];
            };
            DisplayUpdate.prototype.signal = function(emitter, type) {
                hasHandler(emitter, type) && this.events.push(arguments);
            }, DisplayUpdate.prototype.finish = function() {
                for (var this$1 = this, i = 0; i < this.events.length; i++) signal.apply(null, this$1.events[i]);
            };
            // Selection objects are immutable. A new one is created every time
            // the selection changes. A selection is one or more non-overlapping
            // (and non-touching) ranges, sorted, and an integer that indicates
            // which one is the primary selection (the one that's scrolled into
            // view, that getCursor returns, etc).
            var Selection = function(ranges, primIndex) {
                this.ranges = ranges, this.primIndex = primIndex;
            };
            Selection.prototype.primary = function() {
                return this.ranges[this.primIndex];
            }, Selection.prototype.equals = function(other) {
                var this$1 = this;
                if (other == this) return !0;
                if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return !1;
                for (var i = 0; i < this.ranges.length; i++) {
                    var here = this$1.ranges[i], there = other.ranges[i];
                    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) return !1;
                }
                return !0;
            }, Selection.prototype.deepCopy = function() {
                for (var this$1 = this, out = [], i = 0; i < this.ranges.length; i++) out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
                return new Selection(out, this.primIndex);
            }, Selection.prototype.somethingSelected = function() {
                for (var this$1 = this, i = 0; i < this.ranges.length; i++) if (!this$1.ranges[i].empty()) return !0;
                return !1;
            }, Selection.prototype.contains = function(pos, end) {
                var this$1 = this;
                end || (end = pos);
                for (var i = 0; i < this.ranges.length; i++) {
                    var range = this$1.ranges[i];
                    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) return i;
                }
                return -1;
            };
            var Range = function(anchor, head) {
                this.anchor = anchor, this.head = head;
            };
            Range.prototype.from = function() {
                return minPos(this.anchor, this.head);
            }, Range.prototype.to = function() {
                return maxPos(this.anchor, this.head);
            }, Range.prototype.empty = function() {
                return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
            };
            // The document is represented as a BTree consisting of leaves, with
            // chunk of lines in them, and branches, with up to ten leaves or
            // other branch nodes below them. The top node is always a branch
            // node, and is the document object itself (meaning it has
            // additional methods and properties).
            //
            // All nodes have parent links. The tree is used both to go from
            // line numbers to line objects, and to go from objects to numbers.
            // It also indexes by height, and is used to convert between height
            // and line object, and to find the total height of the document.
            //
            // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html
            var LeafChunk = function(lines) {
                var this$1 = this;
                this.lines = lines, this.parent = null;
                for (var height = 0, i = 0; i < lines.length; ++i) lines[i].parent = this$1, height += lines[i].height;
                this.height = height;
            };
            LeafChunk.prototype.chunkSize = function() {
                return this.lines.length;
            }, // Remove the n lines at offset 'at'.
            LeafChunk.prototype.removeInner = function(at, n) {
                for (var this$1 = this, i = at, e = at + n; i < e; ++i) {
                    var line = this$1.lines[i];
                    this$1.height -= line.height, cleanUpLine(line), signalLater(line, "delete");
                }
                this.lines.splice(at, n);
            }, // Helper used to collapse a small branch into a single leaf.
            LeafChunk.prototype.collapse = function(lines) {
                lines.push.apply(lines, this.lines);
            }, // Insert the given array of lines at offset 'at', count them as
            // having the given height.
            LeafChunk.prototype.insertInner = function(at, lines, height) {
                var this$1 = this;
                this.height += height, this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
                for (var i = 0; i < lines.length; ++i) lines[i].parent = this$1;
            }, // Used to iterate over a part of the tree.
            LeafChunk.prototype.iterN = function(at, n, op) {
                for (var this$1 = this, e = at + n; at < e; ++at) if (op(this$1.lines[at])) return !0;
            };
            var BranchChunk = function(children) {
                var this$1 = this;
                this.children = children;
                for (var size = 0, height = 0, i = 0; i < children.length; ++i) {
                    var ch = children[i];
                    size += ch.chunkSize(), height += ch.height, ch.parent = this$1;
                }
                this.size = size, this.height = height, this.parent = null;
            };
            BranchChunk.prototype.chunkSize = function() {
                return this.size;
            }, BranchChunk.prototype.removeInner = function(at, n) {
                var this$1 = this;
                this.size -= n;
                for (var i = 0; i < this.children.length; ++i) {
                    var child = this$1.children[i], sz = child.chunkSize();
                    if (at < sz) {
                        var rm = Math.min(n, sz - at), oldHeight = child.height;
                        if (child.removeInner(at, rm), this$1.height -= oldHeight - child.height, sz == rm && (this$1.children.splice(i--, 1), 
                        child.parent = null), 0 == (n -= rm)) break;
                        at = 0;
                    } else at -= sz;
                }
                // If the result is smaller than 25 lines, ensure that it is a
                // single leaf node.
                if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                    var lines = [];
                    this.collapse(lines), this.children = [ new LeafChunk(lines) ], this.children[0].parent = this;
                }
            }, BranchChunk.prototype.collapse = function(lines) {
                for (var this$1 = this, i = 0; i < this.children.length; ++i) this$1.children[i].collapse(lines);
            }, BranchChunk.prototype.insertInner = function(at, lines, height) {
                var this$1 = this;
                this.size += lines.length, this.height += height;
                for (var i = 0; i < this.children.length; ++i) {
                    var child = this$1.children[i], sz = child.chunkSize();
                    if (at <= sz) {
                        if (child.insertInner(at, lines, height), child.lines && child.lines.length > 50) {
                            for (var remaining = child.lines.length % 25 + 25, pos = remaining; pos < child.lines.length; ) {
                                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                                child.height -= leaf.height, this$1.children.splice(++i, 0, leaf), leaf.parent = this$1;
                            }
                            child.lines = child.lines.slice(0, remaining), this$1.maybeSpill();
                        }
                        break;
                    }
                    at -= sz;
                }
            }, // When a node has grown, check whether it should be split.
            BranchChunk.prototype.maybeSpill = function() {
                if (!(this.children.length <= 10)) {
                    var me = this;
                    do {
                        var spilled = me.children.splice(me.children.length - 5, 5), sibling = new BranchChunk(spilled);
                        if (me.parent) {
                            me.size -= sibling.size, me.height -= sibling.height;
                            var myIndex = indexOf(me.parent.children, me);
                            me.parent.children.splice(myIndex + 1, 0, sibling);
                        } else {
                            // Become the parent node
                            var copy = new BranchChunk(me.children);
                            copy.parent = me, me.children = [ copy, sibling ], me = copy;
                        }
                        sibling.parent = me.parent;
                    } while (me.children.length > 10);
                    me.parent.maybeSpill();
                }
            }, BranchChunk.prototype.iterN = function(at, n, op) {
                for (var this$1 = this, i = 0; i < this.children.length; ++i) {
                    var child = this$1.children[i], sz = child.chunkSize();
                    if (at < sz) {
                        var used = Math.min(n, sz - at);
                        if (child.iterN(at, used, op)) return !0;
                        if (0 == (n -= used)) break;
                        at = 0;
                    } else at -= sz;
                }
            };
            // Line widgets are block elements displayed above or below a line.
            var LineWidget = function(doc, node, options) {
                var this$1 = this;
                if (options) for (var opt in options) options.hasOwnProperty(opt) && (this$1[opt] = options[opt]);
                this.doc = doc, this.node = node;
            };
            LineWidget.prototype.clear = function() {
                var this$1 = this, cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
                if (null != no && ws) {
                    for (var i = 0; i < ws.length; ++i) ws[i] == this$1 && ws.splice(i--, 1);
                    ws.length || (line.widgets = null);
                    var height = widgetHeight(this);
                    updateLineHeight(line, Math.max(0, line.height - height)), cm && (runInOp(cm, function() {
                        adjustScrollWhenAboveVisible(cm, line, -height), regLineChange(cm, no, "widget");
                    }), signalLater(cm, "lineWidgetCleared", cm, this, no));
                }
            }, LineWidget.prototype.changed = function() {
                var this$1 = this, oldH = this.height, cm = this.doc.cm, line = this.line;
                this.height = null;
                var diff = widgetHeight(this) - oldH;
                diff && (updateLineHeight(line, line.height + diff), cm && runInOp(cm, function() {
                    cm.curOp.forceUpdate = !0, adjustScrollWhenAboveVisible(cm, line, diff), signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
                }));
            }, eventMixin(LineWidget);
            // TEXTMARKERS
            // Created with markText and setBookmark methods. A TextMarker is a
            // handle that can be used to clear or find a marked position in the
            // document. Line objects hold arrays (markedSpans) containing
            // {from, to, marker} object pointing to such marker objects, and
            // indicating that such a marker is present on that line. Multiple
            // lines may point to the same marker when it spans across lines.
            // The spans will have null for their from/to properties when the
            // marker continues beyond the start/end of the line. Markers have
            // links back to the lines they currently touch.
            // Collapsed markers have unique ids, in order to be able to order
            // them, which is needed for uniquely determining an outer marker
            // when they overlap (they may nest, but not partially overlap).
            var nextMarkerId = 0, TextMarker = function(doc, type) {
                this.lines = [], this.type = type, this.doc = doc, this.id = ++nextMarkerId;
            };
            // Clear the marker.
            TextMarker.prototype.clear = function() {
                var this$1 = this;
                if (!this.explicitlyCleared) {
                    var cm = this.doc.cm, withOp = cm && !cm.curOp;
                    if (withOp && startOperation(cm), hasHandler(this, "clear")) {
                        var found = this.find();
                        found && signalLater(this, "clear", found.from, found.to);
                    }
                    for (var min = null, max = null, i = 0; i < this.lines.length; ++i) {
                        var line = this$1.lines[i], span = getMarkedSpanFor(line.markedSpans, this$1);
                        cm && !this$1.collapsed ? regLineChange(cm, lineNo(line), "text") : cm && (null != span.to && (max = lineNo(line)), 
                        null != span.from && (min = lineNo(line))), line.markedSpans = removeMarkedSpan(line.markedSpans, span), 
                        null == span.from && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm && updateLineHeight(line, textHeight(cm.display));
                    }
                    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
                        var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);
                        len > cm.display.maxLineLength && (cm.display.maxLine = visual, cm.display.maxLineLength = len, 
                        cm.display.maxLineChanged = !0);
                    }
                    null != min && cm && this.collapsed && regChange(cm, min, max + 1), this.lines.length = 0, 
                    this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, 
                    cm && reCheckSelection(cm.doc)), cm && signalLater(cm, "markerCleared", cm, this, min, max), 
                    withOp && endOperation(cm), this.parent && this.parent.clear();
                }
            }, // Find the position of the marker in the document. Returns a {from,
            // to} object by default. Side can be passed to get a specific side
            // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
            // Pos objects returned contain a line object, rather than a line
            // number (used to prevent looking up the same line twice).
            TextMarker.prototype.find = function(side, lineObj) {
                var this$1 = this;
                null == side && "bookmark" == this.type && (side = 1);
                for (var from, to, i = 0; i < this.lines.length; ++i) {
                    var line = this$1.lines[i], span = getMarkedSpanFor(line.markedSpans, this$1);
                    if (null != span.from && (from = Pos(lineObj ? line : lineNo(line), span.from), 
                    side == -1)) return from;
                    if (null != span.to && (to = Pos(lineObj ? line : lineNo(line), span.to), 1 == side)) return to;
                }
                return from && {
                    from: from,
                    to: to
                };
            }, // Signals that the marker's widget changed, and surrounding layout
            // should be recomputed.
            TextMarker.prototype.changed = function() {
                var this$1 = this, pos = this.find(-1, !0), widget = this, cm = this.doc.cm;
                pos && cm && runInOp(cm, function() {
                    var line = pos.line, lineN = lineNo(pos.line), view = findViewForLine(cm, lineN);
                    if (view && (clearLineMeasurementCacheFor(view), cm.curOp.selectionChanged = cm.curOp.forceUpdate = !0), 
                    cm.curOp.updateMaxLine = !0, !lineIsHidden(widget.doc, line) && null != widget.height) {
                        var oldHeight = widget.height;
                        widget.height = null;
                        var dHeight = widgetHeight(widget) - oldHeight;
                        dHeight && updateLineHeight(line, line.height + dHeight);
                    }
                    signalLater(cm, "markerChanged", cm, this$1);
                });
            }, TextMarker.prototype.attachLine = function(line) {
                if (!this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    op.maybeHiddenMarkers && indexOf(op.maybeHiddenMarkers, this) != -1 || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
                }
                this.lines.push(line);
            }, TextMarker.prototype.detachLine = function(line) {
                if (this.lines.splice(indexOf(this.lines, line), 1), !this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
                }
            }, eventMixin(TextMarker);
            // SHARED TEXTMARKERS
            // A shared marker spans multiple linked documents. It is
            // implemented as a meta-marker-object controlling multiple normal
            // markers.
            var SharedTextMarker = function(markers, primary) {
                var this$1 = this;
                this.markers = markers, this.primary = primary;
                for (var i = 0; i < markers.length; ++i) markers[i].parent = this$1;
            };
            SharedTextMarker.prototype.clear = function() {
                var this$1 = this;
                if (!this.explicitlyCleared) {
                    this.explicitlyCleared = !0;
                    for (var i = 0; i < this.markers.length; ++i) this$1.markers[i].clear();
                    signalLater(this, "clear");
                }
            }, SharedTextMarker.prototype.find = function(side, lineObj) {
                return this.primary.find(side, lineObj);
            }, eventMixin(SharedTextMarker);
            var nextDocId = 0, Doc = function(text, mode, firstLine, lineSep) {
                if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);
                null == firstLine && (firstLine = 0), BranchChunk.call(this, [ new LeafChunk([ new Line("", null) ]) ]), 
                this.first = firstLine, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, 
                this.cleanGeneration = 1, this.frontier = firstLine;
                var start = Pos(firstLine, 0);
                this.sel = simpleSelection(start), this.history = new History(null), this.id = ++nextDocId, 
                this.modeOption = mode, this.lineSep = lineSep, this.extend = !1, "string" == typeof text && (text = this.splitLines(text)), 
                updateDoc(this, {
                    from: start,
                    to: start,
                    text: text
                }), setSelection(this, simpleSelection(start), sel_dontScroll);
            };
            Doc.prototype = createObj(BranchChunk.prototype, {
                constructor: Doc,
                // Iterate over the document. Supports two forms -- with only one
                // argument, it calls that for each line in the document. With
                // three, it iterates over the range given by the first two (with
                // the second being non-inclusive).
                iter: function(from, to, op) {
                    op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from);
                },
                // Non-public interface for adding and removing lines.
                insert: function(at, lines) {
                    for (var height = 0, i = 0; i < lines.length; ++i) height += lines[i].height;
                    this.insertInner(at - this.first, lines, height);
                },
                remove: function(at, n) {
                    this.removeInner(at - this.first, n);
                },
                // From here, the methods are part of the public interface. Most
                // are also available from CodeMirror (editor) instances.
                getValue: function(lineSep) {
                    var lines = getLines(this, this.first, this.first + this.size);
                    return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator());
                },
                setValue: docMethodOp(function(code) {
                    var top = Pos(this.first, 0), last = this.first + this.size - 1;
                    makeChange(this, {
                        from: top,
                        to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code),
                        origin: "setValue",
                        full: !0
                    }, !0), setSelection(this, simpleSelection(top));
                }),
                replaceRange: function(code, from, to, origin) {
                    from = clipPos(this, from), to = to ? clipPos(this, to) : from, replaceRange(this, code, from, to, origin);
                },
                getRange: function(from, to, lineSep) {
                    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
                    return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator());
                },
                getLine: function(line) {
                    var l = this.getLineHandle(line);
                    return l && l.text;
                },
                getLineHandle: function(line) {
                    if (isLine(this, line)) return getLine(this, line);
                },
                getLineNumber: function(line) {
                    return lineNo(line);
                },
                getLineHandleVisualStart: function(line) {
                    return "number" == typeof line && (line = getLine(this, line)), visualLine(line);
                },
                lineCount: function() {
                    return this.size;
                },
                firstLine: function() {
                    return this.first;
                },
                lastLine: function() {
                    return this.first + this.size - 1;
                },
                clipPos: function(pos) {
                    return clipPos(this, pos);
                },
                getCursor: function(start) {
                    var pos, range = this.sel.primary();
                    return pos = null == start || "head" == start ? range.head : "anchor" == start ? range.anchor : "end" == start || "to" == start || start === !1 ? range.to() : range.from();
                },
                listSelections: function() {
                    return this.sel.ranges;
                },
                somethingSelected: function() {
                    return this.sel.somethingSelected();
                },
                setCursor: docMethodOp(function(line, ch, options) {
                    setSimpleSelection(this, clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line), null, options);
                }),
                setSelection: docMethodOp(function(anchor, head, options) {
                    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
                }),
                extendSelection: docMethodOp(function(head, other, options) {
                    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
                }),
                extendSelections: docMethodOp(function(heads, options) {
                    extendSelections(this, clipPosArray(this, heads), options);
                }),
                extendSelectionsBy: docMethodOp(function(f, options) {
                    var heads = map(this.sel.ranges, f);
                    extendSelections(this, clipPosArray(this, heads), options);
                }),
                setSelections: docMethodOp(function(ranges, primary, options) {
                    var this$1 = this;
                    if (ranges.length) {
                        for (var out = [], i = 0; i < ranges.length; i++) out[i] = new Range(clipPos(this$1, ranges[i].anchor), clipPos(this$1, ranges[i].head));
                        null == primary && (primary = Math.min(ranges.length - 1, this.sel.primIndex)), 
                        setSelection(this, normalizeSelection(out, primary), options);
                    }
                }),
                addSelection: docMethodOp(function(anchor, head, options) {
                    var ranges = this.sel.ranges.slice(0);
                    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor))), setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
                }),
                getSelection: function(lineSep) {
                    for (var lines, this$1 = this, ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
                        lines = lines ? lines.concat(sel) : sel;
                    }
                    return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator());
                },
                getSelections: function(lineSep) {
                    for (var this$1 = this, parts = [], ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
                        lineSep !== !1 && (sel = sel.join(lineSep || this$1.lineSeparator())), parts[i] = sel;
                    }
                    return parts;
                },
                replaceSelection: function(code, collapse, origin) {
                    for (var dup = [], i = 0; i < this.sel.ranges.length; i++) dup[i] = code;
                    this.replaceSelections(dup, collapse, origin || "+input");
                },
                replaceSelections: docMethodOp(function(code, collapse, origin) {
                    for (var this$1 = this, changes = [], sel = this.sel, i = 0; i < sel.ranges.length; i++) {
                        var range = sel.ranges[i];
                        changes[i] = {
                            from: range.from(),
                            to: range.to(),
                            text: this$1.splitLines(code[i]),
                            origin: origin
                        };
                    }
                    for (var newSel = collapse && "end" != collapse && computeReplacedSel(this, changes, collapse), i$1 = changes.length - 1; i$1 >= 0; i$1--) makeChange(this$1, changes[i$1]);
                    newSel ? setSelectionReplaceHistory(this, newSel) : this.cm && ensureCursorVisible(this.cm);
                }),
                undo: docMethodOp(function() {
                    makeChangeFromHistory(this, "undo");
                }),
                redo: docMethodOp(function() {
                    makeChangeFromHistory(this, "redo");
                }),
                undoSelection: docMethodOp(function() {
                    makeChangeFromHistory(this, "undo", !0);
                }),
                redoSelection: docMethodOp(function() {
                    makeChangeFromHistory(this, "redo", !0);
                }),
                setExtending: function(val) {
                    this.extend = val;
                },
                getExtending: function() {
                    return this.extend;
                },
                historySize: function() {
                    for (var hist = this.history, done = 0, undone = 0, i = 0; i < hist.done.length; i++) hist.done[i].ranges || ++done;
                    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) hist.undone[i$1].ranges || ++undone;
                    return {
                        undo: done,
                        redo: undone
                    };
                },
                clearHistory: function() {
                    this.history = new History(this.history.maxGeneration);
                },
                markClean: function() {
                    this.cleanGeneration = this.changeGeneration(!0);
                },
                changeGeneration: function(forceSplit) {
                    return forceSplit && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), 
                    this.history.generation;
                },
                isClean: function(gen) {
                    return this.history.generation == (gen || this.cleanGeneration);
                },
                getHistory: function() {
                    return {
                        done: copyHistoryArray(this.history.done),
                        undone: copyHistoryArray(this.history.undone)
                    };
                },
                setHistory: function(histData) {
                    var hist = this.history = new History(this.history.maxGeneration);
                    hist.done = copyHistoryArray(histData.done.slice(0), null, !0), hist.undone = copyHistoryArray(histData.undone.slice(0), null, !0);
                },
                setGutterMarker: docMethodOp(function(line, gutterID, value) {
                    return changeLine(this, line, "gutter", function(line) {
                        var markers = line.gutterMarkers || (line.gutterMarkers = {});
                        return markers[gutterID] = value, !value && isEmpty(markers) && (line.gutterMarkers = null), 
                        !0;
                    });
                }),
                clearGutter: docMethodOp(function(gutterID) {
                    var this$1 = this;
                    this.iter(function(line) {
                        line.gutterMarkers && line.gutterMarkers[gutterID] && changeLine(this$1, line, "gutter", function() {
                            return line.gutterMarkers[gutterID] = null, isEmpty(line.gutterMarkers) && (line.gutterMarkers = null), 
                            !0;
                        });
                    });
                }),
                lineInfo: function(line) {
                    var n;
                    if ("number" == typeof line) {
                        if (!isLine(this, line)) return null;
                        if (n = line, line = getLine(this, line), !line) return null;
                    } else if (n = lineNo(line), null == n) return null;
                    return {
                        line: n,
                        handle: line,
                        text: line.text,
                        gutterMarkers: line.gutterMarkers,
                        textClass: line.textClass,
                        bgClass: line.bgClass,
                        wrapClass: line.wrapClass,
                        widgets: line.widgets
                    };
                },
                addLineClass: docMethodOp(function(handle, where, cls) {
                    return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                        var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
                        if (line[prop]) {
                            if (classTest(cls).test(line[prop])) return !1;
                            line[prop] += " " + cls;
                        } else line[prop] = cls;
                        return !0;
                    });
                }),
                removeLineClass: docMethodOp(function(handle, where, cls) {
                    return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                        var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass", cur = line[prop];
                        if (!cur) return !1;
                        if (null == cls) line[prop] = null; else {
                            var found = cur.match(classTest(cls));
                            if (!found) return !1;
                            var end = found.index + found[0].length;
                            line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null;
                        }
                        return !0;
                    });
                }),
                addLineWidget: docMethodOp(function(handle, node, options) {
                    return addLineWidget(this, handle, node, options);
                }),
                removeLineWidget: function(widget) {
                    widget.clear();
                },
                markText: function(from, to, options) {
                    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
                },
                setBookmark: function(pos, options) {
                    var realOpts = {
                        replacedWith: options && (null == options.nodeType ? options.widget : options),
                        insertLeft: options && options.insertLeft,
                        clearWhenEmpty: !1,
                        shared: options && options.shared,
                        handleMouseEvents: options && options.handleMouseEvents
                    };
                    return pos = clipPos(this, pos), markText(this, pos, pos, realOpts, "bookmark");
                },
                findMarksAt: function(pos) {
                    pos = clipPos(this, pos);
                    var markers = [], spans = getLine(this, pos.line).markedSpans;
                    if (spans) for (var i = 0; i < spans.length; ++i) {
                        var span = spans[i];
                        (null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker);
                    }
                    return markers;
                },
                findMarks: function(from, to, filter) {
                    from = clipPos(this, from), to = clipPos(this, to);
                    var found = [], lineNo = from.line;
                    return this.iter(from.line, to.line + 1, function(line) {
                        var spans = line.markedSpans;
                        if (spans) for (var i = 0; i < spans.length; i++) {
                            var span = spans[i];
                            null != span.to && lineNo == from.line && from.ch >= span.to || null == span.from && lineNo != from.line || null != span.from && lineNo == to.line && span.from >= to.ch || filter && !filter(span.marker) || found.push(span.marker.parent || span.marker);
                        }
                        ++lineNo;
                    }), found;
                },
                getAllMarks: function() {
                    var markers = [];
                    return this.iter(function(line) {
                        var sps = line.markedSpans;
                        if (sps) for (var i = 0; i < sps.length; ++i) null != sps[i].from && markers.push(sps[i].marker);
                    }), markers;
                },
                posFromIndex: function(off) {
                    var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
                    return this.iter(function(line) {
                        var sz = line.text.length + sepSize;
                        return sz > off ? (ch = off, !0) : (off -= sz, void ++lineNo);
                    }), clipPos(this, Pos(lineNo, ch));
                },
                indexFromPos: function(coords) {
                    coords = clipPos(this, coords);
                    var index = coords.ch;
                    if (coords.line < this.first || coords.ch < 0) return 0;
                    var sepSize = this.lineSeparator().length;
                    return this.iter(this.first, coords.line, function(line) {
                        // iter aborts when callback returns a truthy value
                        index += line.text.length + sepSize;
                    }), index;
                },
                copy: function(copyHistory) {
                    var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep);
                    return doc.scrollTop = this.scrollTop, doc.scrollLeft = this.scrollLeft, doc.sel = this.sel, 
                    doc.extend = !1, copyHistory && (doc.history.undoDepth = this.history.undoDepth, 
                    doc.setHistory(this.getHistory())), doc;
                },
                linkedDoc: function(options) {
                    options || (options = {});
                    var from = this.first, to = this.first + this.size;
                    null != options.from && options.from > from && (from = options.from), null != options.to && options.to < to && (to = options.to);
                    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);
                    return options.sharedHist && (copy.history = this.history), (this.linked || (this.linked = [])).push({
                        doc: copy,
                        sharedHist: options.sharedHist
                    }), copy.linked = [ {
                        doc: this,
                        isParent: !0,
                        sharedHist: options.sharedHist
                    } ], copySharedMarkers(copy, findSharedMarkers(this)), copy;
                },
                unlinkDoc: function(other) {
                    var this$1 = this;
                    if (other instanceof CodeMirror && (other = other.doc), this.linked) for (var i = 0; i < this.linked.length; ++i) {
                        var link = this$1.linked[i];
                        if (link.doc == other) {
                            this$1.linked.splice(i, 1), other.unlinkDoc(this$1), detachSharedMarkers(findSharedMarkers(this$1));
                            break;
                        }
                    }
                    // If the histories were shared, split them again
                    if (other.history == this.history) {
                        var splitIds = [ other.id ];
                        linkedDocs(other, function(doc) {
                            return splitIds.push(doc.id);
                        }, !0), other.history = new History(null), other.history.done = copyHistoryArray(this.history.done, splitIds), 
                        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
                    }
                },
                iterLinkedDocs: function(f) {
                    linkedDocs(this, f);
                },
                getMode: function() {
                    return this.mode;
                },
                getEditor: function() {
                    return this.cm;
                },
                splitLines: function(str) {
                    return this.lineSep ? str.split(this.lineSep) : splitLinesAuto(str);
                },
                lineSeparator: function() {
                    return this.lineSep || "\n";
                }
            }), // Public alias.
            Doc.prototype.eachLine = Doc.prototype.iter;
            // Number keys
            for (var lastDrop = 0, globalsRegistered = !1, keyNames = {
                3: "Enter",
                8: "Backspace",
                9: "Tab",
                13: "Enter",
                16: "Shift",
                17: "Ctrl",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Esc",
                32: "Space",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "Left",
                38: "Up",
                39: "Right",
                40: "Down",
                44: "PrintScrn",
                45: "Insert",
                46: "Delete",
                59: ";",
                61: "=",
                91: "Mod",
                92: "Mod",
                93: "Mod",
                106: "*",
                107: "=",
                109: "-",
                110: ".",
                111: "/",
                127: "Delete",
                173: "-",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'",
                63232: "Up",
                63233: "Down",
                63234: "Left",
                63235: "Right",
                63272: "Delete",
                63273: "Home",
                63275: "End",
                63276: "PageUp",
                63277: "PageDown",
                63302: "Insert"
            }, i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
            // Alphabetic keys
            for (var i$1 = 65; i$1 <= 90; i$1++) keyNames[i$1] = String.fromCharCode(i$1);
            // Function keys
            for (var i$2 = 1; i$2 <= 12; i$2++) keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
            var keyMap = {};
            keyMap.basic = {
                Left: "goCharLeft",
                Right: "goCharRight",
                Up: "goLineUp",
                Down: "goLineDown",
                End: "goLineEnd",
                Home: "goLineStartSmart",
                PageUp: "goPageUp",
                PageDown: "goPageDown",
                Delete: "delCharAfter",
                Backspace: "delCharBefore",
                "Shift-Backspace": "delCharBefore",
                Tab: "defaultTab",
                "Shift-Tab": "indentAuto",
                Enter: "newlineAndIndent",
                Insert: "toggleOverwrite",
                Esc: "singleSelection"
            }, // Note that the save and find-related commands aren't defined by
            // default. User code or addons can define them. Unknown commands
            // are simply ignored.
            keyMap.pcDefault = {
                "Ctrl-A": "selectAll",
                "Ctrl-D": "deleteLine",
                "Ctrl-Z": "undo",
                "Shift-Ctrl-Z": "redo",
                "Ctrl-Y": "redo",
                "Ctrl-Home": "goDocStart",
                "Ctrl-End": "goDocEnd",
                "Ctrl-Up": "goLineUp",
                "Ctrl-Down": "goLineDown",
                "Ctrl-Left": "goGroupLeft",
                "Ctrl-Right": "goGroupRight",
                "Alt-Left": "goLineStart",
                "Alt-Right": "goLineEnd",
                "Ctrl-Backspace": "delGroupBefore",
                "Ctrl-Delete": "delGroupAfter",
                "Ctrl-S": "save",
                "Ctrl-F": "find",
                "Ctrl-G": "findNext",
                "Shift-Ctrl-G": "findPrev",
                "Shift-Ctrl-F": "replace",
                "Shift-Ctrl-R": "replaceAll",
                "Ctrl-[": "indentLess",
                "Ctrl-]": "indentMore",
                "Ctrl-U": "undoSelection",
                "Shift-Ctrl-U": "redoSelection",
                "Alt-U": "redoSelection",
                fallthrough: "basic"
            }, // Very basic readline/emacs-style bindings, which are standard on Mac.
            keyMap.emacsy = {
                "Ctrl-F": "goCharRight",
                "Ctrl-B": "goCharLeft",
                "Ctrl-P": "goLineUp",
                "Ctrl-N": "goLineDown",
                "Alt-F": "goWordRight",
                "Alt-B": "goWordLeft",
                "Ctrl-A": "goLineStart",
                "Ctrl-E": "goLineEnd",
                "Ctrl-V": "goPageDown",
                "Shift-Ctrl-V": "goPageUp",
                "Ctrl-D": "delCharAfter",
                "Ctrl-H": "delCharBefore",
                "Alt-D": "delWordAfter",
                "Alt-Backspace": "delWordBefore",
                "Ctrl-K": "killLine",
                "Ctrl-T": "transposeChars",
                "Ctrl-O": "openLine"
            }, keyMap.macDefault = {
                "Cmd-A": "selectAll",
                "Cmd-D": "deleteLine",
                "Cmd-Z": "undo",
                "Shift-Cmd-Z": "redo",
                "Cmd-Y": "redo",
                "Cmd-Home": "goDocStart",
                "Cmd-Up": "goDocStart",
                "Cmd-End": "goDocEnd",
                "Cmd-Down": "goDocEnd",
                "Alt-Left": "goGroupLeft",
                "Alt-Right": "goGroupRight",
                "Cmd-Left": "goLineLeft",
                "Cmd-Right": "goLineRight",
                "Alt-Backspace": "delGroupBefore",
                "Ctrl-Alt-Backspace": "delGroupAfter",
                "Alt-Delete": "delGroupAfter",
                "Cmd-S": "save",
                "Cmd-F": "find",
                "Cmd-G": "findNext",
                "Shift-Cmd-G": "findPrev",
                "Cmd-Alt-F": "replace",
                "Shift-Cmd-Alt-F": "replaceAll",
                "Cmd-[": "indentLess",
                "Cmd-]": "indentMore",
                "Cmd-Backspace": "delWrappedLineLeft",
                "Cmd-Delete": "delWrappedLineRight",
                "Cmd-U": "undoSelection",
                "Shift-Cmd-U": "redoSelection",
                "Ctrl-Up": "goDocStart",
                "Ctrl-Down": "goDocEnd",
                fallthrough: [ "basic", "emacsy" ]
            }, keyMap.default = mac ? keyMap.macDefault : keyMap.pcDefault;
            // Commands are parameter-less actions that can be performed on an
            // editor, mostly used for keybindings.
            var lastClick, lastDoubleClick, commands = {
                selectAll: selectAll,
                singleSelection: function(cm) {
                    return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
                },
                killLine: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        if (range.empty()) {
                            var len = getLine(cm.doc, range.head.line).text.length;
                            return range.head.ch == len && range.head.line < cm.lastLine() ? {
                                from: range.head,
                                to: Pos(range.head.line + 1, 0)
                            } : {
                                from: range.head,
                                to: Pos(range.head.line, len)
                            };
                        }
                        return {
                            from: range.from(),
                            to: range.to()
                        };
                    });
                },
                deleteLine: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        return {
                            from: Pos(range.from().line, 0),
                            to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                        };
                    });
                },
                delLineLeft: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        return {
                            from: Pos(range.from().line, 0),
                            to: range.from()
                        };
                    });
                },
                delWrappedLineLeft: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5, leftPos = cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div");
                        return {
                            from: leftPos,
                            to: range.from()
                        };
                    });
                },
                delWrappedLineRight: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5, rightPos = cm.coordsChar({
                            left: cm.display.lineDiv.offsetWidth + 100,
                            top: top
                        }, "div");
                        return {
                            from: range.from(),
                            to: rightPos
                        };
                    });
                },
                undo: function(cm) {
                    return cm.undo();
                },
                redo: function(cm) {
                    return cm.redo();
                },
                undoSelection: function(cm) {
                    return cm.undoSelection();
                },
                redoSelection: function(cm) {
                    return cm.redoSelection();
                },
                goDocStart: function(cm) {
                    return cm.extendSelection(Pos(cm.firstLine(), 0));
                },
                goDocEnd: function(cm) {
                    return cm.extendSelection(Pos(cm.lastLine()));
                },
                goLineStart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineStart(cm, range.head.line);
                    }, {
                        origin: "+move",
                        bias: 1
                    });
                },
                goLineStartSmart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineStartSmart(cm, range.head);
                    }, {
                        origin: "+move",
                        bias: 1
                    });
                },
                goLineEnd: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineEnd(cm, range.head.line);
                    }, {
                        origin: "+move",
                        bias: -1
                    });
                },
                goLineRight: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5;
                        return cm.coordsChar({
                            left: cm.display.lineDiv.offsetWidth + 100,
                            top: top
                        }, "div");
                    }, sel_move);
                },
                goLineLeft: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5;
                        return cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div");
                    }, sel_move);
                },
                goLineLeftSmart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5, pos = cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div");
                        return pos.ch < cm.getLine(pos.line).search(/\S/) ? lineStartSmart(cm, range.head) : pos;
                    }, sel_move);
                },
                goLineUp: function(cm) {
                    return cm.moveV(-1, "line");
                },
                goLineDown: function(cm) {
                    return cm.moveV(1, "line");
                },
                goPageUp: function(cm) {
                    return cm.moveV(-1, "page");
                },
                goPageDown: function(cm) {
                    return cm.moveV(1, "page");
                },
                goCharLeft: function(cm) {
                    return cm.moveH(-1, "char");
                },
                goCharRight: function(cm) {
                    return cm.moveH(1, "char");
                },
                goColumnLeft: function(cm) {
                    return cm.moveH(-1, "column");
                },
                goColumnRight: function(cm) {
                    return cm.moveH(1, "column");
                },
                goWordLeft: function(cm) {
                    return cm.moveH(-1, "word");
                },
                goGroupRight: function(cm) {
                    return cm.moveH(1, "group");
                },
                goGroupLeft: function(cm) {
                    return cm.moveH(-1, "group");
                },
                goWordRight: function(cm) {
                    return cm.moveH(1, "word");
                },
                delCharBefore: function(cm) {
                    return cm.deleteH(-1, "char");
                },
                delCharAfter: function(cm) {
                    return cm.deleteH(1, "char");
                },
                delWordBefore: function(cm) {
                    return cm.deleteH(-1, "word");
                },
                delWordAfter: function(cm) {
                    return cm.deleteH(1, "word");
                },
                delGroupBefore: function(cm) {
                    return cm.deleteH(-1, "group");
                },
                delGroupAfter: function(cm) {
                    return cm.deleteH(1, "group");
                },
                indentAuto: function(cm) {
                    return cm.indentSelection("smart");
                },
                indentMore: function(cm) {
                    return cm.indentSelection("add");
                },
                indentLess: function(cm) {
                    return cm.indentSelection("subtract");
                },
                insertTab: function(cm) {
                    return cm.replaceSelection("\t");
                },
                insertSoftTab: function(cm) {
                    for (var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize, i = 0; i < ranges.length; i++) {
                        var pos = ranges[i].from(), col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                        spaces.push(spaceStr(tabSize - col % tabSize));
                    }
                    cm.replaceSelections(spaces);
                },
                defaultTab: function(cm) {
                    cm.somethingSelected() ? cm.indentSelection("add") : cm.execCommand("insertTab");
                },
                // Swap the two chars left and right of each selection's head.
                // Move cursor behind the two swapped characters afterwards.
                //
                // Doesn't consider line feeds a character.
                // Doesn't scan more than one line above to find a character.
                // Doesn't do anything on an empty line.
                // Doesn't do anything with non-empty selections.
                transposeChars: function(cm) {
                    return runInOp(cm, function() {
                        for (var ranges = cm.listSelections(), newSel = [], i = 0; i < ranges.length; i++) if (ranges[i].empty()) {
                            var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
                            if (line) if (cur.ch == line.length && (cur = new Pos(cur.line, cur.ch - 1)), cur.ch > 0) cur = new Pos(cur.line, cur.ch + 1), 
                            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose"); else if (cur.line > cm.doc.first) {
                                var prev = getLine(cm.doc, cur.line - 1).text;
                                prev && (cur = new Pos(cur.line, 1), cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose"));
                            }
                            newSel.push(new Range(cur, cur));
                        }
                        cm.setSelections(newSel);
                    });
                },
                newlineAndIndent: function(cm) {
                    return runInOp(cm, function() {
                        for (var sels = cm.listSelections(), i = sels.length - 1; i >= 0; i--) cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
                        sels = cm.listSelections();
                        for (var i$1 = 0; i$1 < sels.length; i$1++) cm.indentLine(sels[i$1].from().line, null, !0);
                        ensureCursorVisible(cm);
                    });
                },
                openLine: function(cm) {
                    return cm.replaceSelection("\n", "start");
                },
                toggleOverwrite: function(cm) {
                    return cm.toggleOverwrite();
                }
            }, stopSeq = new Delayed(), lastStoppedKey = null, Init = {
                toString: function() {
                    return "CodeMirror.Init";
                }
            }, defaults = {}, optionHandlers = {};
            // The default configuration options.
            CodeMirror.defaults = defaults, // Functions to run when options are changed.
            CodeMirror.optionHandlers = optionHandlers;
            var initHooks = [];
            CodeMirror.defineInitHook = function(f) {
                return initHooks.push(f);
            };
            // This will be set to a {lineWise: bool, text: [string]} object, so
            // that, when pasting, we know what kind of selections the copied
            // text was made out of.
            var lastCopied = null, ContentEditableInput = function(cm) {
                this.cm = cm, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, 
                this.polling = new Delayed(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null;
            };
            ContentEditableInput.prototype.init = function(display) {
                function onCopyCut(e) {
                    if (!signalDOMEvent(cm, e)) {
                        if (cm.somethingSelected()) setLastCopied({
                            lineWise: !1,
                            text: cm.getSelections()
                        }), "cut" == e.type && cm.replaceSelection("", null, "cut"); else {
                            if (!cm.options.lineWiseCopyCut) return;
                            var ranges = copyableRanges(cm);
                            setLastCopied({
                                lineWise: !0,
                                text: ranges.text
                            }), "cut" == e.type && cm.operation(function() {
                                cm.setSelections(ranges.ranges, 0, sel_dontScroll), cm.replaceSelection("", null, "cut");
                            });
                        }
                        if (e.clipboardData) {
                            e.clipboardData.clearData();
                            var content = lastCopied.text.join("\n");
                            if (// iOS exposes the clipboard API, but seems to discard content inserted into it
                            e.clipboardData.setData("Text", content), e.clipboardData.getData("Text") == content) return void e.preventDefault();
                        }
                        // Old-fashioned briefly-focus-a-textarea hack
                        var kludge = hiddenTextarea(), te = kludge.firstChild;
                        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild), te.value = lastCopied.text.join("\n");
                        var hadFocus = document.activeElement;
                        selectInput(te), setTimeout(function() {
                            cm.display.lineSpace.removeChild(kludge), hadFocus.focus(), hadFocus == div && input.showPrimarySelection();
                        }, 50);
                    }
                }
                var this$1 = this, input = this, cm = input.cm, div = input.div = display.lineDiv;
                disableBrowserMagic(div, cm.options.spellcheck), on(div, "paste", function(e) {
                    signalDOMEvent(cm, e) || handlePaste(e, cm) || // IE doesn't fire input events, so we schedule a read for the pasted content in this way
                    ie_version <= 11 && setTimeout(operation(cm, function() {
                        input.pollContent() || regChange(cm);
                    }), 20);
                }), on(div, "compositionstart", function(e) {
                    this$1.composing = {
                        data: e.data,
                        done: !1
                    };
                }), on(div, "compositionupdate", function(e) {
                    this$1.composing || (this$1.composing = {
                        data: e.data,
                        done: !1
                    });
                }), on(div, "compositionend", function(e) {
                    this$1.composing && (e.data != this$1.composing.data && this$1.readFromDOMSoon(), 
                    this$1.composing.done = !0);
                }), on(div, "touchstart", function() {
                    return input.forceCompositionEnd();
                }), on(div, "input", function() {
                    this$1.composing || this$1.readFromDOMSoon();
                }), on(div, "copy", onCopyCut), on(div, "cut", onCopyCut);
            }, ContentEditableInput.prototype.prepareSelection = function() {
                var result = prepareSelection(this.cm, !1);
                return result.focus = this.cm.state.focused, result;
            }, ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
                info && this.cm.display.view.length && ((info.focus || takeFocus) && this.showPrimarySelection(), 
                this.showMultipleSelections(info));
            }, ContentEditableInput.prototype.showPrimarySelection = function() {
                var sel = window.getSelection(), prim = this.cm.doc.sel.primary(), curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset), curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
                if (!curAnchor || curAnchor.bad || !curFocus || curFocus.bad || 0 != cmp(minPos(curAnchor, curFocus), prim.from()) || 0 != cmp(maxPos(curAnchor, curFocus), prim.to())) {
                    var start = posToDOM(this.cm, prim.from()), end = posToDOM(this.cm, prim.to());
                    if (start || end) {
                        var view = this.cm.display.view, old = sel.rangeCount && sel.getRangeAt(0);
                        if (start) {
                            if (!end) {
                                // FIXME dangerously hacky
                                var measure = view[view.length - 1].measure, map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
                                end = {
                                    node: map[map.length - 1],
                                    offset: map[map.length - 2] - map[map.length - 3]
                                };
                            }
                        } else start = {
                            node: view[0].measure.map[2],
                            offset: 0
                        };
                        var rng;
                        try {
                            rng = range(start.node, start.offset, end.offset, end.node);
                        } catch (e) {}
                        // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
                        rng && (!gecko && this.cm.state.focused ? (sel.collapse(start.node, start.offset), 
                        rng.collapsed || (sel.removeAllRanges(), sel.addRange(rng))) : (sel.removeAllRanges(), 
                        sel.addRange(rng)), old && null == sel.anchorNode ? sel.addRange(old) : gecko && this.startGracePeriod()), 
                        this.rememberSelection();
                    }
                }
            }, ContentEditableInput.prototype.startGracePeriod = function() {
                var this$1 = this;
                clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
                    this$1.gracePeriod = !1, this$1.selectionChanged() && this$1.cm.operation(function() {
                        return this$1.cm.curOp.selectionChanged = !0;
                    });
                }, 20);
            }, ContentEditableInput.prototype.showMultipleSelections = function(info) {
                removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors), removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
            }, ContentEditableInput.prototype.rememberSelection = function() {
                var sel = window.getSelection();
                this.lastAnchorNode = sel.anchorNode, this.lastAnchorOffset = sel.anchorOffset, 
                this.lastFocusNode = sel.focusNode, this.lastFocusOffset = sel.focusOffset;
            }, ContentEditableInput.prototype.selectionInEditor = function() {
                var sel = window.getSelection();
                if (!sel.rangeCount) return !1;
                var node = sel.getRangeAt(0).commonAncestorContainer;
                return contains(this.div, node);
            }, ContentEditableInput.prototype.focus = function() {
                "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0), 
                this.div.focus());
            }, ContentEditableInput.prototype.blur = function() {
                this.div.blur();
            }, ContentEditableInput.prototype.getField = function() {
                return this.div;
            }, ContentEditableInput.prototype.supportsTouch = function() {
                return !0;
            }, ContentEditableInput.prototype.receivedFocus = function() {
                function poll() {
                    input.cm.state.focused && (input.pollSelection(), input.polling.set(input.cm.options.pollInterval, poll));
                }
                var input = this;
                this.selectionInEditor() ? this.pollSelection() : runInOp(this.cm, function() {
                    return input.cm.curOp.selectionChanged = !0;
                }), this.polling.set(this.cm.options.pollInterval, poll);
            }, ContentEditableInput.prototype.selectionChanged = function() {
                var sel = window.getSelection();
                return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
            }, ContentEditableInput.prototype.pollSelection = function() {
                if (!this.composing && null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
                    var sel = window.getSelection(), cm = this.cm;
                    this.rememberSelection();
                    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset), head = domToPos(cm, sel.focusNode, sel.focusOffset);
                    anchor && head && runInOp(cm, function() {
                        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll), (anchor.bad || head.bad) && (cm.curOp.selectionChanged = !0);
                    });
                }
            }, ContentEditableInput.prototype.pollContent = function() {
                null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
                var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary(), from = sel.from(), to = sel.to();
                if (0 == from.ch && from.line > cm.firstLine() && (from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length)), 
                to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine() && (to = Pos(to.line + 1, 0)), 
                from.line < display.viewFrom || to.line > display.viewTo - 1) return !1;
                var fromIndex, fromLine, fromNode;
                from.line == display.viewFrom || 0 == (fromIndex = findViewIndex(cm, from.line)) ? (fromLine = lineNo(display.view[0].line), 
                fromNode = display.view[0].node) : (fromLine = lineNo(display.view[fromIndex].line), 
                fromNode = display.view[fromIndex - 1].node.nextSibling);
                var toLine, toNode, toIndex = findViewIndex(cm, to.line);
                if (toIndex == display.view.length - 1 ? (toLine = display.viewTo - 1, toNode = display.lineDiv.lastChild) : (toLine = lineNo(display.view[toIndex + 1].line) - 1, 
                toNode = display.view[toIndex + 1].node.previousSibling), !fromNode) return !1;
                for (var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine)), oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length)); newText.length > 1 && oldText.length > 1; ) if (lst(newText) == lst(oldText)) newText.pop(), 
                oldText.pop(), toLine--; else {
                    if (newText[0] != oldText[0]) break;
                    newText.shift(), oldText.shift(), fromLine++;
                }
                for (var cutFront = 0, cutEnd = 0, newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length); cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront); ) ++cutFront;
                for (var newBot = lst(newText), oldBot = lst(oldText), maxCutEnd = Math.min(newBot.length - (1 == newText.length ? cutFront : 0), oldBot.length - (1 == oldText.length ? cutFront : 0)); cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1); ) ++cutEnd;
                newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, ""), 
                newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
                var chFrom = Pos(fromLine, cutFront), chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
                return newText.length > 1 || newText[0] || cmp(chFrom, chTo) ? (replaceRange(cm.doc, newText, chFrom, chTo, "+input"), 
                !0) : void 0;
            }, ContentEditableInput.prototype.ensurePolled = function() {
                this.forceCompositionEnd();
            }, ContentEditableInput.prototype.reset = function() {
                this.forceCompositionEnd();
            }, ContentEditableInput.prototype.forceCompositionEnd = function() {
                this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.pollContent() || regChange(this.cm), 
                this.div.blur(), this.div.focus());
            }, ContentEditableInput.prototype.readFromDOMSoon = function() {
                var this$1 = this;
                null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function() {
                    if (this$1.readDOMTimeout = null, this$1.composing) {
                        if (!this$1.composing.done) return;
                        this$1.composing = null;
                    }
                    !this$1.cm.isReadOnly() && this$1.pollContent() || runInOp(this$1.cm, function() {
                        return regChange(this$1.cm);
                    });
                }, 80));
            }, ContentEditableInput.prototype.setUneditable = function(node) {
                node.contentEditable = "false";
            }, ContentEditableInput.prototype.onKeyPress = function(e) {
                0 != e.charCode && (e.preventDefault(), this.cm.isReadOnly() || operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0));
            }, ContentEditableInput.prototype.readOnlyChanged = function(val) {
                this.div.contentEditable = String("nocursor" != val);
            }, ContentEditableInput.prototype.onContextMenu = function() {}, ContentEditableInput.prototype.resetPosition = function() {}, 
            ContentEditableInput.prototype.needsContentAttribute = !0;
            // TEXTAREA INPUT STYLE
            var TextareaInput = function(cm) {
                this.cm = cm, // See input.poll and input.reset
                this.prevInput = "", // Flag that indicates whether we expect input to appear real soon
                // now (after some event like 'keypress' or 'input') and are
                // polling intensively.
                this.pollingFast = !1, // Self-resetting timeout for the poller
                this.polling = new Delayed(), // Tracks when input.reset has punted to just putting a short
                // string into the textarea instead of the full selection.
                this.inaccurateSelection = !1, // Used to work around IE issue with selection being forgotten when focus moves away from textarea
                this.hasSelection = !1, this.composing = null;
            };
            TextareaInput.prototype.init = function(display) {
                function prepareCopyCut(e) {
                    if (!signalDOMEvent(cm, e)) {
                        if (cm.somethingSelected()) setLastCopied({
                            lineWise: !1,
                            text: cm.getSelections()
                        }), input.inaccurateSelection && (input.prevInput = "", input.inaccurateSelection = !1, 
                        te.value = lastCopied.text.join("\n"), selectInput(te)); else {
                            if (!cm.options.lineWiseCopyCut) return;
                            var ranges = copyableRanges(cm);
                            setLastCopied({
                                lineWise: !0,
                                text: ranges.text
                            }), "cut" == e.type ? cm.setSelections(ranges.ranges, null, sel_dontScroll) : (input.prevInput = "", 
                            te.value = ranges.text.join("\n"), selectInput(te));
                        }
                        "cut" == e.type && (cm.state.cutIncoming = !0);
                    }
                }
                var this$1 = this, input = this, cm = this.cm, div = this.wrapper = hiddenTextarea(), te = this.textarea = div.firstChild;
                display.wrapper.insertBefore(div, display.wrapper.firstChild), // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
                ios && (te.style.width = "0px"), on(te, "input", function() {
                    ie && ie_version >= 9 && this$1.hasSelection && (this$1.hasSelection = null), input.poll();
                }), on(te, "paste", function(e) {
                    signalDOMEvent(cm, e) || handlePaste(e, cm) || (cm.state.pasteIncoming = !0, input.fastPoll());
                }), on(te, "cut", prepareCopyCut), on(te, "copy", prepareCopyCut), on(display.scroller, "paste", function(e) {
                    eventInWidget(display, e) || signalDOMEvent(cm, e) || (cm.state.pasteIncoming = !0, 
                    input.focus());
                }), // Prevent normal selection in the editor (we handle our own)
                on(display.lineSpace, "selectstart", function(e) {
                    eventInWidget(display, e) || e_preventDefault(e);
                }), on(te, "compositionstart", function() {
                    var start = cm.getCursor("from");
                    input.composing && input.composing.range.clear(), input.composing = {
                        start: start,
                        range: cm.markText(start, cm.getCursor("to"), {
                            className: "CodeMirror-composing"
                        })
                    };
                }), on(te, "compositionend", function() {
                    input.composing && (input.poll(), input.composing.range.clear(), input.composing = null);
                });
            }, TextareaInput.prototype.prepareSelection = function() {
                // Redraw the selection and/or cursor
                var cm = this.cm, display = cm.display, doc = cm.doc, result = prepareSelection(cm);
                // Move the hidden textarea near the cursor to prevent scrolling artifacts
                if (cm.options.moveInputWithCursor) {
                    var headPos = cursorCoords(cm, doc.sel.primary().head, "div"), wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
                    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)), 
                    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
                }
                return result;
            }, TextareaInput.prototype.showSelection = function(drawn) {
                var cm = this.cm, display = cm.display;
                removeChildrenAndAdd(display.cursorDiv, drawn.cursors), removeChildrenAndAdd(display.selectionDiv, drawn.selection), 
                null != drawn.teTop && (this.wrapper.style.top = drawn.teTop + "px", this.wrapper.style.left = drawn.teLeft + "px");
            }, // Reset the input to correspond to the selection (or to be empty,
            // when not typing and nothing is selected)
            TextareaInput.prototype.reset = function(typing) {
                if (!this.contextMenuPending) {
                    var minimal, selected, cm = this.cm, doc = cm.doc;
                    if (cm.somethingSelected()) {
                        this.prevInput = "";
                        var range = doc.sel.primary();
                        minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1e3);
                        var content = minimal ? "-" : selected || cm.getSelection();
                        this.textarea.value = content, cm.state.focused && selectInput(this.textarea), ie && ie_version >= 9 && (this.hasSelection = content);
                    } else typing || (this.prevInput = this.textarea.value = "", ie && ie_version >= 9 && (this.hasSelection = null));
                    this.inaccurateSelection = minimal;
                }
            }, TextareaInput.prototype.getField = function() {
                return this.textarea;
            }, TextareaInput.prototype.supportsTouch = function() {
                return !1;
            }, TextareaInput.prototype.focus = function() {
                if ("nocursor" != this.cm.options.readOnly && (!mobile || activeElt() != this.textarea)) try {
                    this.textarea.focus();
                } catch (e) {}
            }, TextareaInput.prototype.blur = function() {
                this.textarea.blur();
            }, TextareaInput.prototype.resetPosition = function() {
                this.wrapper.style.top = this.wrapper.style.left = 0;
            }, TextareaInput.prototype.receivedFocus = function() {
                this.slowPoll();
            }, // Poll for input changes, using the normal rate of polling. This
            // runs as long as the editor is focused.
            TextareaInput.prototype.slowPoll = function() {
                var this$1 = this;
                this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
                    this$1.poll(), this$1.cm.state.focused && this$1.slowPoll();
                });
            }, // When an event has just come in that is likely to add or change
            // something in the input textarea, we poll faster, to ensure that
            // the change appears on the screen quickly.
            TextareaInput.prototype.fastPoll = function() {
                function p() {
                    var changed = input.poll();
                    changed || missed ? (input.pollingFast = !1, input.slowPoll()) : (missed = !0, input.polling.set(60, p));
                }
                var missed = !1, input = this;
                input.pollingFast = !0, input.polling.set(20, p);
            }, // Read input from the textarea, and update the document to match.
            // When something is selected, it is present in the textarea, and
            // selected (unless it is huge, in which case a placeholder is
            // used). When nothing is selected, the cursor sits after previously
            // seen text (can be empty), which is stored in prevInput (we must
            // not reset the textarea when typing, because that breaks IME).
            TextareaInput.prototype.poll = function() {
                var this$1 = this, cm = this.cm, input = this.textarea, prevInput = this.prevInput;
                // Since this is called a *lot*, try to bail out as cheaply as
                // possible when it is clear that nothing happened. hasSelection
                // will be the case when there is a lot of text in the textarea,
                // in which case reading its value would be expensive.
                if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) return !1;
                var text = input.value;
                // If nothing changed, bail.
                if (text == prevInput && !cm.somethingSelected()) return !1;
                // Work around nonsensical selection resetting in IE9/10, and
                // inexplicable appearance of private area unicode characters on
                // some key combos in Mac (#2689).
                if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) return cm.display.input.reset(), 
                !1;
                if (cm.doc.sel == cm.display.selForContextMenu) {
                    var first = text.charCodeAt(0);
                    if (8203 != first || prevInput || (prevInput = ""), 8666 == first) return this.reset(), 
                    this.cm.execCommand("undo");
                }
                for (// Find the part of the input that is actually new
                var same = 0, l = Math.min(prevInput.length, text.length); same < l && prevInput.charCodeAt(same) == text.charCodeAt(same); ) ++same;
                return runInOp(cm, function() {
                    applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null), 
                    // Don't leave long text in the textarea, since it makes further polling slow
                    text.length > 1e3 || text.indexOf("\n") > -1 ? input.value = this$1.prevInput = "" : this$1.prevInput = text, 
                    this$1.composing && (this$1.composing.range.clear(), this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
                        className: "CodeMirror-composing"
                    }));
                }), !0;
            }, TextareaInput.prototype.ensurePolled = function() {
                this.pollingFast && this.poll() && (this.pollingFast = !1);
            }, TextareaInput.prototype.onKeyPress = function() {
                ie && ie_version >= 9 && (this.hasSelection = null), this.fastPoll();
            }, TextareaInput.prototype.onContextMenu = function(e) {
                // Select-all will be greyed out if there's nothing to select, so
                // this adds a zero-width space so that we can later check whether
                // it got selected.
                function prepareSelectAllHack() {
                    if (null != te.selectionStart) {
                        var selected = cm.somethingSelected(), extval = "" + (selected ? te.value : "");
                        te.value = "", // Used to catch context-menu undo
                        te.value = extval, input.prevInput = selected ? "" : "", te.selectionStart = 1, 
                        te.selectionEnd = extval.length, // Re-set this, in case some other handler touched the
                        // selection in the meantime.
                        display.selForContextMenu = cm.doc.sel;
                    }
                }
                function rehide() {
                    // Try to detect the user choosing select-all
                    if (input.contextMenuPending = !1, input.wrapper.style.cssText = oldWrapperCSS, 
                    te.style.cssText = oldCSS, ie && ie_version < 9 && display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos), 
                    null != te.selectionStart) {
                        (!ie || ie && ie_version < 9) && prepareSelectAllHack();
                        var i = 0, poll = function() {
                            display.selForContextMenu == cm.doc.sel && 0 == te.selectionStart && te.selectionEnd > 0 && "" == input.prevInput ? operation(cm, selectAll)(cm) : i++ < 10 ? display.detectingSelectAll = setTimeout(poll, 500) : (display.selForContextMenu = null, 
                            display.input.reset());
                        };
                        display.detectingSelectAll = setTimeout(poll, 200);
                    }
                }
                var input = this, cm = input.cm, display = cm.display, te = input.textarea, pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
                if (pos && !presto) {
                    // Opera is difficult.
                    // Reset the current text selection only if the click is done outside of the selection
                    // and 'resetSelectionOnContextMenu' option is true.
                    var reset = cm.options.resetSelectionOnContextMenu;
                    reset && cm.doc.sel.contains(pos) == -1 && operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
                    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
                    input.wrapper.style.cssText = "position: absolute";
                    var wrapperBox = input.wrapper.getBoundingClientRect();
                    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
                    var oldScrollY;
                    if (webkit && (oldScrollY = window.scrollY), // Work around Chrome issue (#2712)
                    display.input.focus(), webkit && window.scrollTo(null, oldScrollY), display.input.reset(), 
                    // Adds "Select all" to context menu in FF
                    cm.somethingSelected() || (te.value = input.prevInput = " "), input.contextMenuPending = !0, 
                    display.selForContextMenu = cm.doc.sel, clearTimeout(display.detectingSelectAll), 
                    ie && ie_version >= 9 && prepareSelectAllHack(), captureRightClick) {
                        e_stop(e);
                        var mouseup = function() {
                            off(window, "mouseup", mouseup), setTimeout(rehide, 20);
                        };
                        on(window, "mouseup", mouseup);
                    } else setTimeout(rehide, 50);
                }
            }, TextareaInput.prototype.readOnlyChanged = function(val) {
                val || this.reset();
            }, TextareaInput.prototype.setUneditable = function() {}, TextareaInput.prototype.needsContentAttribute = !1, 
            // EDITOR CONSTRUCTOR
            defineOptions(CodeMirror), addEditorMethods(CodeMirror);
            // Set up methods on CodeMirror's prototype to redirect to the editor's document.
            var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
            for (var prop in Doc.prototype) Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror.prototype[prop] = function(method) {
                return function() {
                    return method.apply(this.doc, arguments);
                };
            }(Doc.prototype[prop]));
            // INPUT HANDLING
            // MODE DEFINITION AND QUERYING
            // Extra arguments are stored as the mode's dependencies, which is
            // used by (legacy) mechanisms like loadmode.js to automatically
            // load a mode. (Preferred mechanism is the require/define calls.)
            // Minimal default mode.
            // EXTENSIONS
            return eventMixin(Doc), CodeMirror.inputStyles = {
                textarea: TextareaInput,
                contenteditable: ContentEditableInput
            }, CodeMirror.defineMode = function(name) {
                CodeMirror.defaults.mode || "null" == name || (CodeMirror.defaults.mode = name), 
                defineMode.apply(this, arguments);
            }, CodeMirror.defineMIME = defineMIME, CodeMirror.defineMode("null", function() {
                return {
                    token: function(stream) {
                        return stream.skipToEnd();
                    }
                };
            }), CodeMirror.defineMIME("text/plain", "null"), CodeMirror.defineExtension = function(name, func) {
                CodeMirror.prototype[name] = func;
            }, CodeMirror.defineDocExtension = function(name, func) {
                Doc.prototype[name] = func;
            }, CodeMirror.fromTextArea = fromTextArea, addLegacyProps(CodeMirror), CodeMirror.version = "5.24.2", 
            CodeMirror;
        });
    }, /* 114 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.withTheme = exports.ThemeProvider = exports.injectGlobal = exports.keyframes = exports.css = void 0;
        var _generateAlphabeticName = __webpack_require__(115), _generateAlphabeticName2 = _interopRequireDefault(_generateAlphabeticName), _css = __webpack_require__(116), _css2 = _interopRequireDefault(_css), _injectGlobal = __webpack_require__(124), _injectGlobal2 = _interopRequireDefault(_injectGlobal), _StyledComponent = __webpack_require__(154), _StyledComponent2 = _interopRequireDefault(_StyledComponent), _styled2 = __webpack_require__(161), _styled3 = _interopRequireDefault(_styled2), _keyframes2 = __webpack_require__(163), _keyframes3 = _interopRequireDefault(_keyframes2), _ComponentStyle2 = __webpack_require__(165), _ComponentStyle3 = _interopRequireDefault(_ComponentStyle2), _ThemeProvider = __webpack_require__(158), _ThemeProvider2 = _interopRequireDefault(_ThemeProvider), _withTheme = __webpack_require__(187), _withTheme2 = _interopRequireDefault(_withTheme), keyframes = (0, 
        _keyframes3.default)(_generateAlphabeticName2.default), styled = (0, _styled3.default)((0, 
        _StyledComponent2.default)((0, _ComponentStyle3.default)(_generateAlphabeticName2.default)));
        /* Export everything */
        exports.default = styled, exports.css = _css2.default, exports.keyframes = keyframes, 
        exports.injectGlobal = _injectGlobal2.default, exports.ThemeProvider = _ThemeProvider2.default, 
        exports.withTheme = _withTheme2.default;
    }, /* 115 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split(""), generateAlphabeticName = function generateAlphabeticName(code) {
            var lastDigit = chars[code % chars.length];
            return code > chars.length ? "" + generateAlphabeticName(Math.floor(code / chars.length)) + lastDigit : lastDigit;
        };
        exports.default = generateAlphabeticName, module.exports = exports.default;
    }, /* 116 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _interleave = __webpack_require__(117), _interleave2 = _interopRequireDefault(_interleave), _flatten = __webpack_require__(119), _flatten2 = _interopRequireDefault(_flatten);
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_RuleSet || __webpack_require__(109).PropTypes.any, 
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_Interpolation || __webpack_require__(109).PropTypes.any;
        exports.default = function(strings) {
            for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
            return (0, _flatten2.default)((0, _interleave2.default)(strings, interpolations));
        }, module.exports = exports.default;
    }, /* 117 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_Interpolation || __webpack_require__(109).PropTypes.any;
        exports.default = function(strings, interpolations) {
            return interpolations.reduce(function(array, interp, i) {
                return array.concat(interp, strings[i + 1]);
            }, [ strings[0] ]);
        }, module.exports = exports.default;
    }, /* 118 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        /* todo: I want this to actually be an array of Function | string but that causes errors */
        Object.defineProperty(module.exports, "babelPluginFlowReactPropTypes_proptype_GlamorRule", {
            value: __webpack_require__(109).PropTypes.shape({
                cssText: __webpack_require__(109).PropTypes.string.isRequired
            })
        });
    }, /* 119 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                return arr2;
            }
            return Array.from(arr);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.objToCss = void 0;
        var _hyphenateStyleName = __webpack_require__(120), _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName), _isPlainObject = __webpack_require__(122), _isPlainObject2 = _interopRequireDefault(_isPlainObject), objToCss = (__webpack_require__(118).babelPluginFlowReactPropTypes_proptype_Interpolation || __webpack_require__(109).PropTypes.any, 
        exports.objToCss = function objToCss(obj, prevKey) {
            var css = Object.keys(obj).map(function(key) {
                return (0, _isPlainObject2.default)(obj[key]) ? objToCss(obj[key], key) : (0, _hyphenateStyleName2.default)(key) + ": " + obj[key] + ";";
            }).join(" ");
            return prevKey ? prevKey + " {\n  " + css + "\n}" : css;
        }), flatten = function flatten(chunks, executionContext) {
            return chunks.reduce(function(ruleSet, chunk) {
                /* Remove falsey values */
                /* Remove falsey values */
                /* Flatten ruleSet */
                /* Either execute or defer the function */
                return void 0 === chunk || null === chunk || chunk === !1 || "" === chunk ? ruleSet : Array.isArray(chunk) ? [].concat(_toConsumableArray(ruleSet), _toConsumableArray(flatten(chunk, executionContext))) : "function" == typeof chunk ? executionContext ? ruleSet.concat.apply(ruleSet, _toConsumableArray(flatten([ chunk(executionContext) ], executionContext))) : ruleSet.concat(chunk) : ruleSet.concat((0, 
                _isPlainObject2.default)(chunk) ? objToCss(chunk) : chunk.toString());
            }, []);
        };
        exports.default = flatten;
    }, /* 120 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
        "use strict";
        /**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
        function hyphenateStyleName(string) {
            return hyphenate(string).replace(msPattern, "-ms-");
        }
        var hyphenate = __webpack_require__(121), msPattern = /^ms-/;
        module.exports = hyphenateStyleName;
    }, /* 121 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
        function hyphenate(string) {
            return string.replace(_uppercasePattern, "-$1").toLowerCase();
        }
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
        var _uppercasePattern = /([A-Z])/g;
        module.exports = hyphenate;
    }, /* 122 */
    /***/
    function(module, exports, __webpack_require__) {
        /*!
	 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
        "use strict";
        function isObjectObject(o) {
            return isObject(o) === !0 && "[object Object]" === Object.prototype.toString.call(o);
        }
        var isObject = __webpack_require__(123);
        module.exports = function(o) {
            var ctor, prot;
            // If has modified constructor
            // If has modified prototype
            return isObjectObject(o) !== !1 && (ctor = o.constructor, "function" == typeof ctor && (prot = ctor.prototype, 
            isObjectObject(prot) !== !1 && prot.hasOwnProperty("isPrototypeOf") !== !1));
        };
    }, /* 123 */
    /***/
    function(module, exports) {
        /*!
	 * isobject <https://github.com/jonschlinkert/isobject>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
        "use strict";
        module.exports = function(val) {
            return null != val && "object" == typeof val && !Array.isArray(val);
        };
    }, /* 124 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _css = __webpack_require__(116), _css2 = _interopRequireDefault(_css), _GlobalStyle = __webpack_require__(125), _GlobalStyle2 = _interopRequireDefault(_GlobalStyle), injectGlobal = (__webpack_require__(118).babelPluginFlowReactPropTypes_proptype_Interpolation || __webpack_require__(109).PropTypes.any, 
        function(strings) {
            for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
            var globalStyle = new _GlobalStyle2.default(_css2.default.apply(void 0, [ strings ].concat(interpolations)));
            globalStyle.generateAndInject();
        });
        exports.default = injectGlobal, module.exports = exports.default;
    }, /* 125 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _parse = __webpack_require__(126), _parse2 = _interopRequireDefault(_parse), _postcssNested = __webpack_require__(150), _postcssNested2 = _interopRequireDefault(_postcssNested), _flatten = __webpack_require__(119), _flatten2 = _interopRequireDefault(_flatten), _StyleSheet = __webpack_require__(151), _StyleSheet2 = _interopRequireDefault(_StyleSheet), ComponentStyle = (__webpack_require__(118).babelPluginFlowReactPropTypes_proptype_RuleSet || __webpack_require__(109).PropTypes.any, 
        function() {
            function ComponentStyle(rules, selector) {
                _classCallCheck(this, ComponentStyle), this.rules = rules, this.selector = selector;
            }
            return _createClass(ComponentStyle, [ {
                key: "generateAndInject",
                value: function() {
                    _StyleSheet2.default.injected || _StyleSheet2.default.inject();
                    var flatCSS = (0, _flatten2.default)(this.rules).join("");
                    this.selector && (flatCSS = this.selector + " {" + flatCSS + "\n}");
                    var root = (0, _parse2.default)(flatCSS);
                    (0, _postcssNested2.default)(root), _StyleSheet2.default.insert(root.toResult().css, {
                        global: !0
                    });
                }
            } ]), ComponentStyle;
        }());
        exports.default = ComponentStyle, module.exports = exports.default;
    }, /* 126 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function safeParse(css, opts) {
            var input = new _input2.default(css, opts), parser = new _safeParser2.default(input);
            return parser.tokenize(), parser.loop(), parser.root;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = safeParse;
        var _input = __webpack_require__(127), _input2 = _interopRequireDefault(_input), _safeParser = __webpack_require__(149), _safeParser2 = _interopRequireDefault(_safeParser);
        module.exports = exports.default;
    }, /* 127 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        // break cyclical dependency deadlock  #87
        __webpack_require__(128);
        var _cssSyntaxError = __webpack_require__(137), _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError), sequence = 0, Input = function() {
            /**
	     * @param {string} css    - input CSS source
	     * @param {object} [opts] - {@link Processor#process} options
	     */
            function Input(css) {
                var opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                _classCallCheck(this, Input), /**
	         * @member {string} - input CSS source
	         *
	         * @example
	         * const input = postcss.parse('a{}', { from: file }).input;
	         * input.css //=> "a{}";
	         */
                this.css = css.toString(), "\ufeff" !== this.css[0] && "" !== this.css[0] || (this.css = this.css.slice(1)), 
                opts.from && (/^\w+:\/\//.test(opts.from) ? /**
	                 * @member {string} - The absolute path to the CSS source file
	                 *                    defined with the `from` option.
	                 *
	                 * @example
	                 * const root = postcss.parse(css, { from: 'a.css' });
	                 * root.source.input.file //=> '/home/ai/a.css'
	                 */
                this.file = opts.from : this.file = path.resolve(opts.from)), /*
	                let map = new PreviousMap(this.css, opts);
	                if ( map.text ) {
	                    /!**
	                     * @member {PreviousMap} - The input source map passed from
	                     *                         a compilation step before PostCSS
	                     *                         (for example, from Sass compiler).
	                     *
	                     * @example
	                     * root.source.input.map.consumer().sources //=> ['a.sass']
	                     *!/
	                    this.map = map;
	                    let file = map.consumer().file;
	                    if ( !this.file && file ) this.file = this.mapResolve(file);
	                }
	        */
                this.file || (sequence += 1, /**
	             * @member {string} - The unique ID of the CSS source. It will be
	             *                    created if `from` option is not provided
	             *                    (because PostCSS does not know the file path).
	             *
	             * @example
	             * const root = postcss.parse(css);
	             * root.source.input.file //=> undefined
	             * root.source.input.id   //=> "<input css 1>"
	             */
                this.id = "<input css " + sequence + ">"), this.map && (this.map.file = this.from);
            }
            return _createClass(Input, [ {
                key: "error",
                value: function(message, line, column) {
                    var opts = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, result = void 0, origin = this.origin(line, column);
                    return result = origin ? new _cssSyntaxError2.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin) : new _cssSyntaxError2.default(message, line, column, this.css, this.file, opts.plugin), 
                    result.input = {
                        line: line,
                        column: column,
                        source: this.css
                    }, this.file && (result.input.file = this.file), result;
                }
            }, {
                key: "origin",
                value: function(line, column) {
                    if (!this.map) return !1;
                    var consumer = this.map.consumer(), from = consumer.originalPositionFor({
                        line: line,
                        column: column
                    });
                    if (!from.source) return !1;
                    var result = {
                        file: this.mapResolve(from.source),
                        line: from.line,
                        column: from.column
                    }, source = consumer.sourceContentFor(from.source);
                    return source && (result.source = source), result;
                }
            }, {
                key: "mapResolve",
                value: function(file) {
                    return /^\w+:\/\//.test(file) ? file : path.resolve(this.map.consumer().sourceRoot || ".", file);
                }
            }, {
                key: "from",
                get: function() {
                    return this.file || this.id;
                }
            } ]), Input;
        }();
        exports.default = Input, module.exports = exports.default;
    }, /* 128 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _get = function get(object, property, receiver) {
            null === object && (object = Function.prototype);
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (void 0 === desc) {
                var parent = Object.getPrototypeOf(object);
                return null === parent ? void 0 : get(parent, property, receiver);
            }
            if ("value" in desc) return desc.value;
            var getter = desc.get;
            if (void 0 !== getter) return getter.call(receiver);
        };
        __webpack_require__(129);
        var _container = __webpack_require__(131), _container2 = _interopRequireDefault(_container), _lazyResult = __webpack_require__(145), _lazyResult2 = _interopRequireDefault(_lazyResult), _processor = __webpack_require__(148), _processor2 = _interopRequireDefault(_processor), _warnOnce = __webpack_require__(135), _warnOnce2 = _interopRequireDefault(_warnOnce), Root = function(_Container) {
            function Root(defaults) {
                _classCallCheck(this, Root);
                var _this = _possibleConstructorReturn(this, (Root.__proto__ || Object.getPrototypeOf(Root)).call(this, defaults));
                return _this.type = "root", _this.nodes || (_this.nodes = []), _this;
            }
            return _inherits(Root, _Container), _createClass(Root, [ {
                key: "removeChild",
                value: function(child) {
                    return child = this.index(child), 0 === child && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[child].raws.before), 
                    _get(Root.prototype.__proto__ || Object.getPrototypeOf(Root.prototype), "removeChild", this).call(this, child);
                }
            }, {
                key: "normalize",
                value: function(child, sample, type) {
                    var nodes = _get(Root.prototype.__proto__ || Object.getPrototypeOf(Root.prototype), "normalize", this).call(this, child);
                    return sample && ("prepend" === type ? this.nodes.length > 1 ? sample.raws.before = this.nodes[1].raws.before : delete sample.raws.before : this.first !== sample && nodes.forEach(function(node) {
                        node.raws.before = sample.raws.before;
                    })), nodes;
                }
            }, {
                key: "toResult",
                value: function() {
                    var opts = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, lazy = new _lazyResult2.default(new _processor2.default(), this, opts);
                    return lazy.stringify();
                }
            }, {
                key: "remove",
                value: function(child) {
                    (0, _warnOnce2.default)("Root#remove is deprecated. Use Root#removeChild"), this.removeChild(child);
                }
            }, {
                key: "prevMap",
                value: function() {
                    return (0, _warnOnce2.default)("Root#prevMap is deprecated. Use Root#source.input.map"), 
                    this.source.input.map;
                }
            } ]), Root;
        }(_container2.default);
        exports.default = Root, module.exports = exports.default;
    }, /* 129 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        __webpack_require__(130);
        var _container = __webpack_require__(131), _container2 = _interopRequireDefault(_container), _warnOnce = __webpack_require__(135), _warnOnce2 = _interopRequireDefault(_warnOnce), _list = __webpack_require__(144), _list2 = _interopRequireDefault(_list), Rule = function(_Container) {
            function Rule(defaults) {
                _classCallCheck(this, Rule);
                var _this = _possibleConstructorReturn(this, (Rule.__proto__ || Object.getPrototypeOf(Rule)).call(this, defaults));
                return _this.type = "rule", _this.nodes || (_this.nodes = []), _this;
            }
            /**
	     * An array containing the rules individual selectors.
	     * Groups of selectors are split at commas.
	     *
	     * @type {string[]}
	     *
	     * @example
	     * const root = postcss.parse('a, b { }');
	     * const rule = root.first;
	     *
	     * rule.selector  //=> 'a, b'
	     * rule.selectors //=> ['a', 'b']
	     *
	     * rule.selectors = ['a', 'strong'];
	     * rule.selector //=> 'a, strong'
	     */
            return _inherits(Rule, _Container), _createClass(Rule, [ {
                key: "selectors",
                get: function() {
                    return _list2.default.comma(this.selector);
                },
                set: function(values) {
                    var match = this.selector ? this.selector.match(/,\s*/) : null, sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
                    this.selector = values.join(sep);
                }
            }, {
                key: "_selector",
                get: function() {
                    return (0, _warnOnce2.default)("Rule#_selector is deprecated. Use Rule#raws.selector"), 
                    this.raws.selector;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("Rule#_selector is deprecated. Use Rule#raws.selector"), 
                    this.raws.selector = val;
                }
            } ]), Rule;
        }(_container2.default);
        exports.default = Rule, module.exports = exports.default;
    }, /* 130 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _get = function get(object, property, receiver) {
            null === object && (object = Function.prototype);
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (void 0 === desc) {
                var parent = Object.getPrototypeOf(object);
                return null === parent ? void 0 : get(parent, property, receiver);
            }
            if ("value" in desc) return desc.value;
            var getter = desc.get;
            if (void 0 !== getter) return getter.call(receiver);
        }, _container = __webpack_require__(131), _container2 = _interopRequireDefault(_container), _warnOnce = __webpack_require__(135), _warnOnce2 = _interopRequireDefault(_warnOnce), AtRule = function(_Container) {
            function AtRule(defaults) {
                _classCallCheck(this, AtRule);
                var _this = _possibleConstructorReturn(this, (AtRule.__proto__ || Object.getPrototypeOf(AtRule)).call(this, defaults));
                return _this.type = "atrule", _this;
            }
            return _inherits(AtRule, _Container), _createClass(AtRule, [ {
                key: "append",
                value: function() {
                    var _get2;
                    this.nodes || (this.nodes = []);
                    for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) children[_key] = arguments[_key];
                    return (_get2 = _get(AtRule.prototype.__proto__ || Object.getPrototypeOf(AtRule.prototype), "append", this)).call.apply(_get2, [ this ].concat(children));
                }
            }, {
                key: "prepend",
                value: function() {
                    var _get3;
                    this.nodes || (this.nodes = []);
                    for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) children[_key2] = arguments[_key2];
                    return (_get3 = _get(AtRule.prototype.__proto__ || Object.getPrototypeOf(AtRule.prototype), "prepend", this)).call.apply(_get3, [ this ].concat(children));
                }
            }, {
                key: "afterName",
                get: function() {
                    return (0, _warnOnce2.default)("AtRule#afterName was deprecated. Use AtRule#raws.afterName"), 
                    this.raws.afterName;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("AtRule#afterName was deprecated. Use AtRule#raws.afterName"), 
                    this.raws.afterName = val;
                }
            }, {
                key: "_params",
                get: function() {
                    return (0, _warnOnce2.default)("AtRule#_params was deprecated. Use AtRule#raws.params"), 
                    this.raws.params;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("AtRule#_params was deprecated. Use AtRule#raws.params"), 
                    this.raws.params = val;
                }
            } ]), AtRule;
        }(_container2.default);
        exports.default = AtRule, module.exports = exports.default;
    }, /* 131 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        function cleanSource(nodes) {
            return nodes.map(function(i) {
                return i.nodes && (i.nodes = cleanSource(i.nodes)), delete i.source, i;
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _get = function get(object, property, receiver) {
            null === object && (object = Function.prototype);
            var desc = Object.getOwnPropertyDescriptor(object, property);
            if (void 0 === desc) {
                var parent = Object.getPrototypeOf(object);
                return null === parent ? void 0 : get(parent, property, receiver);
            }
            if ("value" in desc) return desc.value;
            var getter = desc.get;
            if (void 0 !== getter) return getter.call(receiver);
        }, _parse = __webpack_require__(132), _parse2 = _interopRequireDefault(_parse), _root = __webpack_require__(128), _root2 = _interopRequireDefault(_root), _rule = __webpack_require__(129), _rule2 = _interopRequireDefault(_rule), _atRule = __webpack_require__(130), _atRule2 = _interopRequireDefault(_atRule), _declaration = __webpack_require__(134), _declaration2 = _interopRequireDefault(_declaration), _warnOnce = __webpack_require__(135), _warnOnce2 = _interopRequireDefault(_warnOnce), _comment = __webpack_require__(143), _comment2 = _interopRequireDefault(_comment), _node = __webpack_require__(136), _node2 = _interopRequireDefault(_node), Container = function(_Node) {
            function Container() {
                return _classCallCheck(this, Container), _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));
            }
            return _inherits(Container, _Node), _createClass(Container, [ {
                key: "push",
                value: function(child) {
                    return child.parent = this, this.nodes.push(child), this;
                }
            }, {
                key: "each",
                value: function(callback) {
                    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
                    var id = this.lastEach;
                    if (this.indexes[id] = 0, this.nodes) {
                        for (var index = void 0, result = void 0; this.indexes[id] < this.nodes.length && (index = this.indexes[id], 
                        result = callback(this.nodes[index], index), result !== !1); ) this.indexes[id] += 1;
                        return delete this.indexes[id], result;
                    }
                }
            }, {
                key: "walk",
                value: function(callback) {
                    return this.each(function(child, i) {
                        var result = callback(child, i);
                        return result !== !1 && child.walk && (result = child.walk(callback)), result;
                    });
                }
            }, {
                key: "walkDecls",
                value: function(prop, callback) {
                    return callback ? prop instanceof RegExp ? this.walk(function(child, i) {
                        if ("decl" === child.type && prop.test(child.prop)) return callback(child, i);
                    }) : this.walk(function(child, i) {
                        if ("decl" === child.type && child.prop === prop) return callback(child, i);
                    }) : (callback = prop, this.walk(function(child, i) {
                        if ("decl" === child.type) return callback(child, i);
                    }));
                }
            }, {
                key: "walkRules",
                value: function(selector, callback) {
                    return callback ? selector instanceof RegExp ? this.walk(function(child, i) {
                        if ("rule" === child.type && selector.test(child.selector)) return callback(child, i);
                    }) : this.walk(function(child, i) {
                        if ("rule" === child.type && child.selector === selector) return callback(child, i);
                    }) : (callback = selector, this.walk(function(child, i) {
                        if ("rule" === child.type) return callback(child, i);
                    }));
                }
            }, {
                key: "walkAtRules",
                value: function(name, callback) {
                    return callback ? name instanceof RegExp ? this.walk(function(child, i) {
                        if ("atrule" === child.type && name.test(child.name)) return callback(child, i);
                    }) : this.walk(function(child, i) {
                        if ("atrule" === child.type && child.name === name) return callback(child, i);
                    }) : (callback = name, this.walk(function(child, i) {
                        if ("atrule" === child.type) return callback(child, i);
                    }));
                }
            }, {
                key: "walkComments",
                value: function(callback) {
                    return this.walk(function(child, i) {
                        if ("comment" === child.type) return callback(child, i);
                    });
                }
            }, {
                key: "append",
                value: function() {
                    for (var _this2 = this, _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) children[_key] = arguments[_key];
                    return children.forEach(function(child) {
                        var nodes = _this2.normalize(child, _this2.last);
                        nodes.forEach(function(node) {
                            return _this2.nodes.push(node);
                        });
                    }), this;
                }
            }, {
                key: "prepend",
                value: function() {
                    for (var _this3 = this, _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) children[_key2] = arguments[_key2];
                    return children = children.reverse(), children.forEach(function(child) {
                        var nodes = _this3.normalize(child, _this3.first, "prepend").reverse();
                        nodes.forEach(function(node) {
                            return _this3.nodes.unshift(node);
                        });
                        for (var id in _this3.indexes) _this3.indexes[id] = _this3.indexes[id] + nodes.length;
                    }), this;
                }
            }, {
                key: "cleanRaws",
                value: function(keepBetween) {
                    _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), "cleanRaws", this).call(this, keepBetween), 
                    this.nodes && this.nodes.forEach(function(node) {
                        return node.cleanRaws(keepBetween);
                    });
                }
            }, {
                key: "insertBefore",
                value: function(exist, add) {
                    var _this4 = this;
                    exist = this.index(exist);
                    var type = 0 === exist && "prepend", nodes = this.normalize(add, this.nodes[exist], type).reverse();
                    nodes.forEach(function(node) {
                        return _this4.nodes.splice(exist, 0, node);
                    });
                    var index = void 0;
                    for (var id in this.indexes) index = this.indexes[id], exist <= index && (this.indexes[id] = index + nodes.length);
                    return this;
                }
            }, {
                key: "insertAfter",
                value: function(exist, add) {
                    var _this5 = this;
                    exist = this.index(exist);
                    var nodes = this.normalize(add, this.nodes[exist]).reverse();
                    nodes.forEach(function(node) {
                        return _this5.nodes.splice(exist + 1, 0, node);
                    });
                    var index = void 0;
                    for (var id in this.indexes) index = this.indexes[id], exist < index && (this.indexes[id] = index + nodes.length);
                    return this;
                }
            }, {
                key: "remove",
                value: function(child) {
                    return "undefined" != typeof child ? ((0, _warnOnce2.default)("Container#remove is deprecated. Use Container#removeChild"), 
                    this.removeChild(child)) : _get(Container.prototype.__proto__ || Object.getPrototypeOf(Container.prototype), "remove", this).call(this), 
                    this;
                }
            }, {
                key: "removeChild",
                value: function(child) {
                    child = this.index(child), this.nodes[child].parent = void 0, this.nodes.splice(child, 1);
                    var index = void 0;
                    for (var id in this.indexes) index = this.indexes[id], index >= child && (this.indexes[id] = index - 1);
                    return this;
                }
            }, {
                key: "removeAll",
                value: function() {
                    return this.nodes.forEach(function(node) {
                        return node.parent = void 0;
                    }), this.nodes = [], this;
                }
            }, {
                key: "replaceValues",
                value: function(pattern, opts, callback) {
                    return callback || (callback = opts, opts = {}), this.walkDecls(function(decl) {
                        opts.props && opts.props.indexOf(decl.prop) === -1 || opts.fast && decl.value.indexOf(opts.fast) === -1 || (decl.value = decl.value.replace(pattern, callback));
                    }), this;
                }
            }, {
                key: "every",
                value: function(condition) {
                    return this.nodes.every(condition);
                }
            }, {
                key: "some",
                value: function(condition) {
                    return this.nodes.some(condition);
                }
            }, {
                key: "index",
                value: function(child) {
                    return "number" == typeof child ? child : this.nodes.indexOf(child);
                }
            }, {
                key: "normalize",
                value: function(nodes, sample) {
                    var _this6 = this;
                    if ("string" == typeof nodes) nodes = cleanSource((0, _parse2.default)(nodes).nodes); else if (!Array.isArray(nodes)) if ("root" === nodes.type) nodes = nodes.nodes; else if (nodes.type) nodes = [ nodes ]; else if (nodes.prop) {
                        if ("undefined" == typeof nodes.value) throw new Error("Value field is missed in node creation");
                        "string" != typeof nodes.value && (nodes.value = String(nodes.value)), nodes = [ new _declaration2.default(nodes) ];
                    } else if (nodes.selector) nodes = [ new _rule2.default(nodes) ]; else if (nodes.name) nodes = [ new _atRule2.default(nodes) ]; else {
                        if (!nodes.text) throw new Error("Unknown node type in node creation");
                        nodes = [ new _comment2.default(nodes) ];
                    }
                    var processed = nodes.map(function(i) {
                        return "undefined" == typeof i.raws && (i = _this6.rebuild(i)), i.parent && (i = i.clone()), 
                        "undefined" == typeof i.raws.before && sample && "undefined" != typeof sample.raws.before && (i.raws.before = sample.raws.before.replace(/[^\s]/g, "")), 
                        i.parent = _this6, i;
                    });
                    return processed;
                }
            }, {
                key: "rebuild",
                value: function(node, parent) {
                    var _this7 = this, fix = void 0;
                    "root" === node.type ? fix = new _root2.default() : "atrule" === node.type ? fix = new _atRule2.default() : "rule" === node.type ? fix = new _rule2.default() : "decl" === node.type ? fix = new _declaration2.default() : "comment" === node.type && (fix = new _comment2.default());
                    for (var i in node) "nodes" === i ? fix.nodes = node.nodes.map(function(j) {
                        return _this7.rebuild(j, fix);
                    }) : "parent" === i && parent ? fix.parent = parent : node.hasOwnProperty(i) && (fix[i] = node[i]);
                    return fix;
                }
            }, {
                key: "eachInside",
                value: function(callback) {
                    return (0, _warnOnce2.default)("Container#eachInside is deprecated. Use Container#walk instead."), 
                    this.walk(callback);
                }
            }, {
                key: "eachDecl",
                value: function(prop, callback) {
                    return (0, _warnOnce2.default)("Container#eachDecl is deprecated. Use Container#walkDecls instead."), 
                    this.walkDecls(prop, callback);
                }
            }, {
                key: "eachRule",
                value: function(selector, callback) {
                    return (0, _warnOnce2.default)("Container#eachRule is deprecated. Use Container#walkRules instead."), 
                    this.walkRules(selector, callback);
                }
            }, {
                key: "eachAtRule",
                value: function(name, callback) {
                    return (0, _warnOnce2.default)("Container#eachAtRule is deprecated. Use Container#walkAtRules instead."), 
                    this.walkAtRules(name, callback);
                }
            }, {
                key: "eachComment",
                value: function(callback) {
                    return (0, _warnOnce2.default)("Container#eachComment is deprecated. Use Container#walkComments instead."), 
                    this.walkComments(callback);
                }
            }, {
                key: "first",
                get: function() {
                    if (this.nodes) return this.nodes[0];
                }
            }, {
                key: "last",
                get: function() {
                    if (this.nodes) return this.nodes[this.nodes.length - 1];
                }
            }, {
                key: "semicolon",
                get: function() {
                    return (0, _warnOnce2.default)("Node#semicolon is deprecated. Use Node#raws.semicolon"), 
                    this.raws.semicolon;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("Node#semicolon is deprecated. Use Node#raws.semicolon"), 
                    this.raws.semicolon = val;
                }
            }, {
                key: "after",
                get: function() {
                    return (0, _warnOnce2.default)("Node#after is deprecated. Use Node#raws.after"), 
                    this.raws.after;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("Node#after is deprecated. Use Node#raws.after"), this.raws.after = val;
                }
            } ]), Container;
        }(_node2.default);
        exports.default = Container, module.exports = exports.default;
    }, /* 132 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function parse(css, opts) {
            if (opts && opts.safe) throw new Error('Option safe was removed. Use parser: require("postcss-safe-parser")');
            var input = new _input2.default(css, opts), parser = new _parser2.default(input);
            try {
                parser.tokenize(), parser.loop();
            } catch (e) {
                throw "CssSyntaxError" === e.name && opts && opts.from && (/\.scss$/i.test(opts.from) ? e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser" : /\.less$/i.test(opts.from) && (e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser")), 
                e;
            }
            return parser.root;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = parse;
        var _parser = __webpack_require__(133), _parser2 = _interopRequireDefault(_parser), _input = __webpack_require__(127), _input2 = _interopRequireDefault(_input);
        module.exports = exports.default;
    }, /* 133 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _declaration = __webpack_require__(134), _declaration2 = _interopRequireDefault(_declaration), _tokenize = __webpack_require__(140), _tokenize2 = _interopRequireDefault(_tokenize), _comment = __webpack_require__(143), _comment2 = _interopRequireDefault(_comment), _atRule = __webpack_require__(130), _atRule2 = _interopRequireDefault(_atRule), _root = __webpack_require__(128), _root2 = _interopRequireDefault(_root), _rule = __webpack_require__(129), _rule2 = _interopRequireDefault(_rule), Parser = function() {
            function Parser(input) {
                _classCallCheck(this, Parser), this.input = input, this.pos = 0, this.root = new _root2.default(), 
                this.current = this.root, this.spaces = "", this.semicolon = !1, this.root.source = {
                    input: input,
                    start: {
                        line: 1,
                        column: 1
                    }
                };
            }
            return _createClass(Parser, [ {
                key: "tokenize",
                value: function() {
                    this.tokens = (0, _tokenize2.default)(this.input);
                }
            }, {
                key: "loop",
                value: function() {
                    for (var token = void 0; this.pos < this.tokens.length; ) {
                        switch (token = this.tokens[this.pos], token[0]) {
                          case "space":
                          case ";":
                            this.spaces += token[1];
                            break;

                          case "}":
                            this.end(token);
                            break;

                          case "comment":
                            this.comment(token);
                            break;

                          case "at-word":
                            this.atrule(token);
                            break;

                          case "{":
                            this.emptyRule(token);
                            break;

                          default:
                            this.other();
                        }
                        this.pos += 1;
                    }
                    this.endFile();
                }
            }, {
                key: "comment",
                value: function(token) {
                    var node = new _comment2.default();
                    this.init(node, token[2], token[3]), node.source.end = {
                        line: token[4],
                        column: token[5]
                    };
                    var text = token[1].slice(2, -2);
                    if (/^\s*$/.test(text)) node.text = "", node.raws.left = text, node.raws.right = ""; else {
                        var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
                        node.text = match[2], node.raws.left = match[1], node.raws.right = match[3];
                    }
                }
            }, {
                key: "emptyRule",
                value: function(token) {
                    var node = new _rule2.default();
                    this.init(node, token[2], token[3]), node.selector = "", node.raws.between = "", 
                    this.current = node;
                }
            }, {
                key: "other",
                value: function() {
                    for (var token = void 0, end = !1, type = null, colon = !1, bracket = null, brackets = [], start = this.pos; this.pos < this.tokens.length; ) {
                        if (token = this.tokens[this.pos], type = token[0], "(" === type || "[" === type) bracket || (bracket = token), 
                        brackets.push("(" === type ? ")" : "]"); else if (0 === brackets.length) {
                            if (";" === type) {
                                if (colon) return void this.decl(this.tokens.slice(start, this.pos + 1));
                                break;
                            }
                            if ("{" === type) return void this.rule(this.tokens.slice(start, this.pos + 1));
                            if ("}" === type) {
                                this.pos -= 1, end = !0;
                                break;
                            }
                            ":" === type && (colon = !0);
                        } else type === brackets[brackets.length - 1] && (brackets.pop(), 0 === brackets.length && (bracket = null));
                        this.pos += 1;
                    }
                    if (this.pos === this.tokens.length && (this.pos -= 1, end = !0), brackets.length > 0 && this.unclosedBracket(bracket), 
                    end && colon) {
                        for (;this.pos > start && (token = this.tokens[this.pos][0], "space" === token || "comment" === token); ) this.pos -= 1;
                        return void this.decl(this.tokens.slice(start, this.pos + 1));
                    }
                    this.unknownWord(start);
                }
            }, {
                key: "rule",
                value: function(tokens) {
                    tokens.pop();
                    var node = new _rule2.default();
                    this.init(node, tokens[0][2], tokens[0][3]), node.raws.between = this.spacesFromEnd(tokens), 
                    this.raw(node, "selector", tokens), this.current = node;
                }
            }, {
                key: "decl",
                value: function(tokens) {
                    var node = new _declaration2.default();
                    this.init(node);
                    var last = tokens[tokens.length - 1];
                    for (";" === last[0] && (this.semicolon = !0, tokens.pop()), last[4] ? node.source.end = {
                        line: last[4],
                        column: last[5]
                    } : node.source.end = {
                        line: last[2],
                        column: last[3]
                    }; "word" !== tokens[0][0]; ) node.raws.before += tokens.shift()[1];
                    for (node.source.start = {
                        line: tokens[0][2],
                        column: tokens[0][3]
                    }, node.prop = ""; tokens.length; ) {
                        var type = tokens[0][0];
                        if (":" === type || "space" === type || "comment" === type) break;
                        node.prop += tokens.shift()[1];
                    }
                    node.raws.between = "";
                    for (var token = void 0; tokens.length; ) {
                        if (token = tokens.shift(), ":" === token[0]) {
                            node.raws.between += token[1];
                            break;
                        }
                        node.raws.between += token[1];
                    }
                    "_" !== node.prop[0] && "*" !== node.prop[0] || (node.raws.before += node.prop[0], 
                    node.prop = node.prop.slice(1)), node.raws.between += this.spacesFromStart(tokens), 
                    this.precheckMissedSemicolon(tokens);
                    for (var i = tokens.length - 1; i > 0; i--) {
                        if (token = tokens[i], "!important" === token[1]) {
                            node.important = !0;
                            var string = this.stringFrom(tokens, i);
                            string = this.spacesFromEnd(tokens) + string, " !important" !== string && (node.raws.important = string);
                            break;
                        }
                        if ("important" === token[1]) {
                            for (var cache = tokens.slice(0), str = "", j = i; j > 0; j--) {
                                var _type = cache[j][0];
                                if (0 === str.trim().indexOf("!") && "space" !== _type) break;
                                str = cache.pop()[1] + str;
                            }
                            0 === str.trim().indexOf("!") && (node.important = !0, node.raws.important = str, 
                            tokens = cache);
                        }
                        if ("space" !== token[0] && "comment" !== token[0]) break;
                    }
                    this.raw(node, "value", tokens), node.value.indexOf(":") !== -1 && this.checkMissedSemicolon(tokens);
                }
            }, {
                key: "atrule",
                value: function(token) {
                    var node = new _atRule2.default();
                    node.name = token[1].slice(1), "" === node.name && this.unnamedAtrule(node, token), 
                    this.init(node, token[2], token[3]);
                    var last = !1, open = !1, params = [];
                    for (this.pos += 1; this.pos < this.tokens.length; ) {
                        if (token = this.tokens[this.pos], ";" === token[0]) {
                            node.source.end = {
                                line: token[2],
                                column: token[3]
                            }, this.semicolon = !0;
                            break;
                        }
                        if ("{" === token[0]) {
                            open = !0;
                            break;
                        }
                        if ("}" === token[0]) {
                            this.end(token);
                            break;
                        }
                        params.push(token), this.pos += 1;
                    }
                    this.pos === this.tokens.length && (last = !0), node.raws.between = this.spacesFromEnd(params), 
                    params.length ? (node.raws.afterName = this.spacesFromStart(params), this.raw(node, "params", params), 
                    last && (token = params[params.length - 1], node.source.end = {
                        line: token[4],
                        column: token[5]
                    }, this.spaces = node.raws.between, node.raws.between = "")) : (node.raws.afterName = "", 
                    node.params = ""), open && (node.nodes = [], this.current = node);
                }
            }, {
                key: "end",
                value: function(token) {
                    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), 
                    this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, 
                    this.spaces = "", this.current.parent ? (this.current.source.end = {
                        line: token[2],
                        column: token[3]
                    }, this.current = this.current.parent) : this.unexpectedClose(token);
                }
            }, {
                key: "endFile",
                value: function() {
                    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), 
                    this.current.raws.after = (this.current.raws.after || "") + this.spaces;
                }
            }, {
                key: "init",
                value: function(node, line, column) {
                    this.current.push(node), node.source = {
                        start: {
                            line: line,
                            column: column
                        },
                        input: this.input
                    }, node.raws.before = this.spaces, this.spaces = "", "comment" !== node.type && (this.semicolon = !1);
                }
            }, {
                key: "raw",
                value: function raw(node, prop, tokens) {
                    for (var token = void 0, type = void 0, length = tokens.length, value = "", clean = !0, i = 0; i < length; i += 1) token = tokens[i], 
                    type = token[0], "comment" === type || "space" === type && i === length - 1 ? clean = !1 : value += token[1];
                    if (!clean) {
                        var raw = tokens.reduce(function(all, i) {
                            return all + i[1];
                        }, "");
                        node.raws[prop] = {
                            value: value,
                            raw: raw
                        };
                    }
                    node[prop] = value;
                }
            }, {
                key: "spacesFromEnd",
                value: function(tokens) {
                    for (var lastTokenType = void 0, spaces = ""; tokens.length && (lastTokenType = tokens[tokens.length - 1][0], 
                    "space" === lastTokenType || "comment" === lastTokenType); ) spaces = tokens.pop()[1] + spaces;
                    return spaces;
                }
            }, {
                key: "spacesFromStart",
                value: function(tokens) {
                    for (var next = void 0, spaces = ""; tokens.length && (next = tokens[0][0], "space" === next || "comment" === next); ) spaces += tokens.shift()[1];
                    return spaces;
                }
            }, {
                key: "stringFrom",
                value: function(tokens, from) {
                    for (var result = "", i = from; i < tokens.length; i++) result += tokens[i][1];
                    return tokens.splice(from, tokens.length - from), result;
                }
            }, {
                key: "colon",
                value: function(tokens) {
                    for (var brackets = 0, token = void 0, type = void 0, prev = void 0, i = 0; i < tokens.length; i++) {
                        if (token = tokens[i], type = token[0], "(" === type) brackets += 1; else if (")" === type) brackets -= 1; else if (0 === brackets && ":" === type) {
                            if (prev) {
                                if ("word" === prev[0] && "progid" === prev[1]) continue;
                                return i;
                            }
                            this.doubleColon(token);
                        }
                        prev = token;
                    }
                    return !1;
                }
            }, {
                key: "unclosedBracket",
                value: function(bracket) {
                    throw this.input.error("Unclosed bracket", bracket[2], bracket[3]);
                }
            }, {
                key: "unknownWord",
                value: function(start) {
                    var token = this.tokens[start];
                    throw this.input.error("Unknown word", token[2], token[3]);
                }
            }, {
                key: "unexpectedClose",
                value: function(token) {
                    throw this.input.error("Unexpected }", token[2], token[3]);
                }
            }, {
                key: "unclosedBlock",
                value: function() {
                    var pos = this.current.source.start;
                    throw this.input.error("Unclosed block", pos.line, pos.column);
                }
            }, {
                key: "doubleColon",
                value: function(token) {
                    throw this.input.error("Double colon", token[2], token[3]);
                }
            }, {
                key: "unnamedAtrule",
                value: function(node, token) {
                    throw this.input.error("At-rule without name", token[2], token[3]);
                }
            }, {
                key: "precheckMissedSemicolon",
                value: function(tokens) {}
            }, {
                key: "checkMissedSemicolon",
                value: function(tokens) {
                    var colon = this.colon(tokens);
                    if (colon !== !1) {
                        for (var founded = 0, token = void 0, j = colon - 1; j >= 0 && (token = tokens[j], 
                        "space" === token[0] || (founded += 1, 2 !== founded)); j--) ;
                        throw this.input.error("Missed semicolon", token[2], token[3]);
                    }
                }
            } ]), Parser;
        }();
        exports.default = Parser, module.exports = exports.default;
    }, /* 134 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _warnOnce = __webpack_require__(135), _warnOnce2 = _interopRequireDefault(_warnOnce), _node = __webpack_require__(136), _node2 = _interopRequireDefault(_node), Declaration = function(_Node) {
            function Declaration(defaults) {
                _classCallCheck(this, Declaration);
                var _this = _possibleConstructorReturn(this, (Declaration.__proto__ || Object.getPrototypeOf(Declaration)).call(this, defaults));
                return _this.type = "decl", _this;
            }
            return _inherits(Declaration, _Node), _createClass(Declaration, [ {
                key: "_value",
                get: function() {
                    return (0, _warnOnce2.default)("Node#_value was deprecated. Use Node#raws.value"), 
                    this.raws.value;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("Node#_value was deprecated. Use Node#raws.value"), this.raws.value = val;
                }
            }, {
                key: "_important",
                get: function() {
                    return (0, _warnOnce2.default)("Node#_important was deprecated. Use Node#raws.important"), 
                    this.raws.important;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("Node#_important was deprecated. Use Node#raws.important"), 
                    this.raws.important = val;
                }
            } ]), Declaration;
        }(_node2.default);
        exports.default = Declaration, module.exports = exports.default;
    }, /* 135 */
    /***/
    function(module, exports) {
        "use strict";
        function warnOnce(message) {
            printed[message] || (printed[message] = !0, "undefined" != typeof console && console.warn && console.warn(message));
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = warnOnce;
        var printed = {};
        module.exports = exports.default;
    }, /* 136 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _cssSyntaxError = __webpack_require__(137), _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError), _stringifier = __webpack_require__(141), _stringifier2 = _interopRequireDefault(_stringifier), _stringify = __webpack_require__(142), _stringify2 = _interopRequireDefault(_stringify), _warnOnce = __webpack_require__(135), _warnOnce2 = _interopRequireDefault(_warnOnce), cloneNode = function cloneNode(obj, parent) {
            var cloned = new obj.constructor();
            for (var i in obj) if (obj.hasOwnProperty(i)) {
                var value = obj[i], type = "undefined" == typeof value ? "undefined" : _typeof(value);
                "parent" === i && "object" === type ? parent && (cloned[i] = parent) : "source" === i ? cloned[i] = value : value instanceof Array ? cloned[i] = value.map(function(j) {
                    return cloneNode(j, cloned);
                }) : "before" !== i && "after" !== i && "between" !== i && "semicolon" !== i && ("object" === type && null !== value && (value = cloneNode(value)), 
                cloned[i] = value);
            }
            return cloned;
        }, Node = function() {
            /**
	     * @param {object} [defaults] - value for node properties
	     */
            function Node() {
                var defaults = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                _classCallCheck(this, Node), this.raws = {};
                for (var name in defaults) this[name] = defaults[name];
            }
            /**
	     * Returns a CssSyntaxError instance containing the original position
	     * of the node in the source, showing line and column numbers and also
	     * a small excerpt to facilitate debugging.
	     *
	     * If present, an input source map will be used to get the original position
	     * of the source, even from a previous compilation step
	     * (e.g., from Sass compilation).
	     *
	     * This method produces very useful error messages.
	     *
	     * @param {string} message     - error description
	     * @param {object} [opts]      - options
	     * @param {string} opts.plugin - plugin name that created this error.
	     *                               PostCSS will set it automatically.
	     * @param {string} opts.word   - a word inside a nodes string that should
	     *                               be highlighted as the source of the error
	     * @param {number} opts.index  - an index inside a nodes string that should
	     *                               be highlighted as the source of the error
	     *
	     * @return {CssSyntaxError} error object to throw it
	     *
	     * @example
	     * if ( !variables[name] ) {
	     *   throw decl.error('Unknown variable ' + name, { word: name });
	     *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
	     *   //   color: $black
	     *   // a
	     *   //          ^
	     *   //   background: white
	     * }
	     */
            return _createClass(Node, [ {
                key: "error",
                value: function(message) {
                    var opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (this.source) {
                        var pos = this.positionBy(opts);
                        return this.source.input.error(message, pos.line, pos.column, opts);
                    }
                    return new _cssSyntaxError2.default(message);
                }
            }, {
                key: "warn",
                value: function(result, text, opts) {
                    var data = {
                        node: this
                    };
                    for (var i in opts) data[i] = opts[i];
                    return result.warn(text, data);
                }
            }, {
                key: "remove",
                value: function() {
                    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
                }
            }, {
                key: "toString",
                value: function() {
                    var stringifier = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : _stringify2.default;
                    stringifier.stringify && (stringifier = stringifier.stringify);
                    var result = "";
                    return stringifier(this, function(i) {
                        result += i;
                    }), result;
                }
            }, {
                key: "clone",
                value: function() {
                    var overrides = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, cloned = cloneNode(this);
                    for (var name in overrides) cloned[name] = overrides[name];
                    return cloned;
                }
            }, {
                key: "cloneBefore",
                value: function() {
                    var overrides = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, cloned = this.clone(overrides);
                    return this.parent.insertBefore(this, cloned), cloned;
                }
            }, {
                key: "cloneAfter",
                value: function() {
                    var overrides = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, cloned = this.clone(overrides);
                    return this.parent.insertAfter(this, cloned), cloned;
                }
            }, {
                key: "replaceWith",
                value: function() {
                    var _this = this;
                    if (this.parent) {
                        for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) nodes[_key] = arguments[_key];
                        nodes.forEach(function(node) {
                            _this.parent.insertBefore(_this, node);
                        }), this.remove();
                    }
                    return this;
                }
            }, {
                key: "moveTo",
                value: function(newParent) {
                    return this.cleanRaws(this.root() === newParent.root()), this.remove(), newParent.append(this), 
                    this;
                }
            }, {
                key: "moveBefore",
                value: function(otherNode) {
                    return this.cleanRaws(this.root() === otherNode.root()), this.remove(), otherNode.parent.insertBefore(otherNode, this), 
                    this;
                }
            }, {
                key: "moveAfter",
                value: function(otherNode) {
                    return this.cleanRaws(this.root() === otherNode.root()), this.remove(), otherNode.parent.insertAfter(otherNode, this), 
                    this;
                }
            }, {
                key: "next",
                value: function() {
                    var index = this.parent.index(this);
                    return this.parent.nodes[index + 1];
                }
            }, {
                key: "prev",
                value: function() {
                    var index = this.parent.index(this);
                    return this.parent.nodes[index - 1];
                }
            }, {
                key: "toJSON",
                value: function() {
                    var fixed = {};
                    for (var name in this) if (this.hasOwnProperty(name) && "parent" !== name) {
                        var value = this[name];
                        value instanceof Array ? fixed[name] = value.map(function(i) {
                            return "object" === ("undefined" == typeof i ? "undefined" : _typeof(i)) && i.toJSON ? i.toJSON() : i;
                        }) : "object" === ("undefined" == typeof value ? "undefined" : _typeof(value)) && value.toJSON ? fixed[name] = value.toJSON() : fixed[name] = value;
                    }
                    return fixed;
                }
            }, {
                key: "raw",
                value: function(prop, defaultType) {
                    var str = new _stringifier2.default();
                    return str.raw(this, prop, defaultType);
                }
            }, {
                key: "root",
                value: function() {
                    for (var result = this; result.parent; ) result = result.parent;
                    return result;
                }
            }, {
                key: "cleanRaws",
                value: function(keepBetween) {
                    delete this.raws.before, delete this.raws.after, keepBetween || delete this.raws.between;
                }
            }, {
                key: "positionInside",
                value: function(index) {
                    for (var string = this.toString(), column = this.source.start.column, line = this.source.start.line, i = 0; i < index; i++) "\n" === string[i] ? (column = 1, 
                    line += 1) : column += 1;
                    return {
                        line: line,
                        column: column
                    };
                }
            }, {
                key: "positionBy",
                value: function(opts) {
                    var pos = this.source.start;
                    if (opts.index) pos = this.positionInside(opts.index); else if (opts.word) {
                        var index = this.toString().indexOf(opts.word);
                        index !== -1 && (pos = this.positionInside(index));
                    }
                    return pos;
                }
            }, {
                key: "removeSelf",
                value: function() {
                    return (0, _warnOnce2.default)("Node#removeSelf is deprecated. Use Node#remove."), 
                    this.remove();
                }
            }, {
                key: "replace",
                value: function(nodes) {
                    return (0, _warnOnce2.default)("Node#replace is deprecated. Use Node#replaceWith"), 
                    this.replaceWith(nodes);
                }
            }, {
                key: "style",
                value: function(own, detect) {
                    return (0, _warnOnce2.default)("Node#style() is deprecated. Use Node#raw()"), this.raw(own, detect);
                }
            }, {
                key: "cleanStyles",
                value: function(keepBetween) {
                    return (0, _warnOnce2.default)("Node#cleanStyles() is deprecated. Use Node#cleanRaws()"), 
                    this.cleanRaws(keepBetween);
                }
            }, {
                key: "before",
                get: function() {
                    return (0, _warnOnce2.default)("Node#before is deprecated. Use Node#raws.before"), 
                    this.raws.before;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("Node#before is deprecated. Use Node#raws.before"), this.raws.before = val;
                }
            }, {
                key: "between",
                get: function() {
                    return (0, _warnOnce2.default)("Node#between is deprecated. Use Node#raws.between"), 
                    this.raws.between;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("Node#between is deprecated. Use Node#raws.between"), this.raws.between = val;
                }
            } ]), Node;
        }();
        exports.default = Node, module.exports = exports.default;
    }, /* 137 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _supportsColor = __webpack_require__(138), _supportsColor2 = _interopRequireDefault(_supportsColor), _terminalHighlight = __webpack_require__(139), _terminalHighlight2 = _interopRequireDefault(_terminalHighlight), _warnOnce = __webpack_require__(135), _warnOnce2 = _interopRequireDefault(_warnOnce), CssSyntaxError = function() {
            /**
	     * @param {string} message  - error message
	     * @param {number} [line]   - source line of the error
	     * @param {number} [column] - source column of the error
	     * @param {string} [source] - source code of the broken file
	     * @param {string} [file]   - absolute path to the broken file
	     * @param {string} [plugin] - PostCSS plugin name, if error came from plugin
	     */
            function CssSyntaxError(message, line, column, source, file, plugin) {
                _classCallCheck(this, CssSyntaxError), /**
	         * @member {string} - Always equal to `'CssSyntaxError'`. You should
	         *                    always check error type
	         *                    by `error.name === 'CssSyntaxError'` instead of
	         *                    `error instanceof CssSyntaxError`, because
	         *                    npm could have several PostCSS versions.
	         *
	         * @example
	         * if ( error.name === 'CssSyntaxError' ) {
	         *   error //=> CssSyntaxError
	         * }
	         */
                this.name = "CssSyntaxError", /**
	         * @member {string} - Error message.
	         *
	         * @example
	         * error.message //=> 'Unclosed block'
	         */
                this.reason = message, file && (/**
	             * @member {string} - Absolute path to the broken file.
	             *
	             * @example
	             * error.file       //=> 'a.sass'
	             * error.input.file //=> 'a.css'
	             */
                this.file = file), source && (/**
	             * @member {string} - Source code of the broken file.
	             *
	             * @example
	             * error.source       //=> 'a { b {} }'
	             * error.input.column //=> 'a b { }'
	             */
                this.source = source), plugin && (/**
	             * @member {string} - Plugin name, if error came from plugin.
	             *
	             * @example
	             * error.plugin //=> 'postcss-vars'
	             */
                this.plugin = plugin), "undefined" != typeof line && "undefined" != typeof column && (/**
	             * @member {number} - Source line of the error.
	             *
	             * @example
	             * error.line       //=> 2
	             * error.input.line //=> 4
	             */
                this.line = line, /**
	             * @member {number} - Source column of the error.
	             *
	             * @example
	             * error.column       //=> 1
	             * error.input.column //=> 4
	             */
                this.column = column), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, CssSyntaxError);
            }
            return _createClass(CssSyntaxError, [ {
                key: "setMessage",
                value: function() {
                    /**
	             * @member {string} - Full error text in the GNU error format
	             *                    with plugin, file, line and column.
	             *
	             * @example
	             * error.message //=> 'a.css:1:1: Unclosed block'
	             */
                    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", 
                    "undefined" != typeof this.line && (this.message += ":" + this.line + ":" + this.column), 
                    this.message += ": " + this.reason;
                }
            }, {
                key: "showSourceCode",
                value: function(color) {
                    var _this = this;
                    if (!this.source) return "";
                    var css = this.source;
                    "undefined" == typeof color && (color = _supportsColor2.default), color && (css = (0, 
                    _terminalHighlight2.default)(css));
                    var lines = css.split(/\r?\n/), start = Math.max(this.line - 3, 0), end = Math.min(this.line + 2, lines.length), maxWidth = String(end).length;
                    return lines.slice(start, end).map(function(line, index) {
                        var number = start + 1 + index, padded = (" " + number).slice(-maxWidth), gutter = " " + padded + " | ";
                        if (number === _this.line) {
                            var spacing = gutter.replace(/\d/g, " ") + line.slice(0, _this.column - 1).replace(/[^\t]/g, " ");
                            return ">" + gutter + line + "\n " + spacing + "^";
                        }
                        return " " + gutter + line;
                    }).join("\n");
                }
            }, {
                key: "toString",
                value: function() {
                    var code = this.showSourceCode();
                    return code && (code = "\n\n" + code + "\n"), this.name + ": " + this.message + code;
                }
            }, {
                key: "generated",
                get: function() {
                    return (0, _warnOnce2.default)("CssSyntaxError#generated is depreacted. Use input instead."), 
                    this.input;
                }
            } ]), CssSyntaxError;
        }();
        exports.default = CssSyntaxError, module.exports = exports.default;
    }, /* 138 */
    /***/
    function(module, exports) {
        "use strict";
        module.exports = !1;
    }, /* 139 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function code(color) {
            return "[" + color + "m";
        }
        function terminalHighlight(css) {
            var tokens = (0, _tokenize2.default)(new _input2.default(css), {
                ignoreErrors: !0
            }), result = [];
            return tokens.forEach(function(token) {
                var color = HIGHLIGHT_THEME[token[0]];
                color ? result.push(token[1].split(/\r?\n/).map(function(i) {
                    return code(color[0]) + i + code(color[1]);
                }).join("\n")) : result.push(token[1]);
            }), result.join("");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _tokenize = __webpack_require__(140), _tokenize2 = _interopRequireDefault(_tokenize), _input = __webpack_require__(127), _input2 = _interopRequireDefault(_input), HIGHLIGHT_THEME = {
            brackets: [ 36, 39 ],
            // cyan
            string: [ 31, 39 ],
            // red
            "at-word": [ 31, 39 ],
            // red
            comment: [ 90, 39 ],
            // gray
            "{": [ 32, 39 ],
            // green
            "}": [ 32, 39 ],
            // green
            ":": [ 1, 22 ],
            // bold
            ";": [ 1, 22 ],
            // bold
            "(": [ 1, 22 ],
            // bold
            ")": [ 1, 22 ]
        };
        exports.default = terminalHighlight, module.exports = exports.default;
    }, /* 140 */
    /***/
    function(module, exports) {
        "use strict";
        function tokenize(input) {
            function unclosed(what) {
                throw input.error("Unclosed " + what, line, pos - offset);
            }
            for (var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, tokens = [], css = input.css.valueOf(), ignore = options.ignoreErrors, code = void 0, next = void 0, quote = void 0, lines = void 0, last = void 0, content = void 0, escape = void 0, nextLine = void 0, nextOffset = void 0, escaped = void 0, escapePos = void 0, prev = void 0, n = void 0, length = css.length, offset = -1, line = 1, pos = 0; pos < length; ) {
                switch (code = css.charCodeAt(pos), (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) && (offset = pos, 
                line += 1), code) {
                  case NEWLINE:
                  case SPACE:
                  case TAB:
                  case CR:
                  case FEED:
                    next = pos;
                    do next += 1, code = css.charCodeAt(next), code === NEWLINE && (offset = next, line += 1); while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
                    tokens.push([ "space", css.slice(pos, next) ]), pos = next - 1;
                    break;

                  case OPEN_SQUARE:
                    tokens.push([ "[", "[", line, pos - offset ]);
                    break;

                  case CLOSE_SQUARE:
                    tokens.push([ "]", "]", line, pos - offset ]);
                    break;

                  case OPEN_CURLY:
                    tokens.push([ "{", "{", line, pos - offset ]);
                    break;

                  case CLOSE_CURLY:
                    tokens.push([ "}", "}", line, pos - offset ]);
                    break;

                  case COLON:
                    tokens.push([ ":", ":", line, pos - offset ]);
                    break;

                  case SEMICOLON:
                    tokens.push([ ";", ";", line, pos - offset ]);
                    break;

                  case OPEN_PARENTHESES:
                    if (prev = tokens.length ? tokens[tokens.length - 1][1] : "", n = css.charCodeAt(pos + 1), 
                    "url" === prev && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
                        next = pos;
                        do {
                            if (escaped = !1, next = css.indexOf(")", next + 1), next === -1) {
                                if (ignore) {
                                    next = pos;
                                    break;
                                }
                                unclosed("bracket");
                            }
                            for (escapePos = next; css.charCodeAt(escapePos - 1) === BACKSLASH; ) escapePos -= 1, 
                            escaped = !escaped;
                        } while (escaped);
                        tokens.push([ "brackets", css.slice(pos, next + 1), line, pos - offset, line, next - offset ]), 
                        pos = next;
                    } else next = css.indexOf(")", pos + 1), content = css.slice(pos, next + 1), next === -1 || RE_BAD_BRACKET.test(content) ? tokens.push([ "(", "(", line, pos - offset ]) : (tokens.push([ "brackets", content, line, pos - offset, line, next - offset ]), 
                    pos = next);
                    break;

                  case CLOSE_PARENTHESES:
                    tokens.push([ ")", ")", line, pos - offset ]);
                    break;

                  case SINGLE_QUOTE:
                  case DOUBLE_QUOTE:
                    quote = code === SINGLE_QUOTE ? "'" : '"', next = pos;
                    do {
                        if (escaped = !1, next = css.indexOf(quote, next + 1), next === -1) {
                            if (ignore) {
                                next = pos + 1;
                                break;
                            }
                            unclosed("quote");
                        }
                        for (escapePos = next; css.charCodeAt(escapePos - 1) === BACKSLASH; ) escapePos -= 1, 
                        escaped = !escaped;
                    } while (escaped);
                    content = css.slice(pos, next + 1), lines = content.split("\n"), last = lines.length - 1, 
                    last > 0 ? (nextLine = line + last, nextOffset = next - lines[last].length) : (nextLine = line, 
                    nextOffset = offset), tokens.push([ "string", css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset ]), 
                    offset = nextOffset, line = nextLine, pos = next;
                    break;

                  case AT:
                    RE_AT_END.lastIndex = pos + 1, RE_AT_END.test(css), next = 0 === RE_AT_END.lastIndex ? css.length - 1 : RE_AT_END.lastIndex - 2, 
                    tokens.push([ "at-word", css.slice(pos, next + 1), line, pos - offset, line, next - offset ]), 
                    pos = next;
                    break;

                  case BACKSLASH:
                    for (next = pos, escape = !0; css.charCodeAt(next + 1) === BACKSLASH; ) next += 1, 
                    escape = !escape;
                    code = css.charCodeAt(next + 1), escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED && (next += 1), 
                    tokens.push([ "word", css.slice(pos, next + 1), line, pos - offset, line, next - offset ]), 
                    pos = next;
                    break;

                  default:
                    code === SLASH && css.charCodeAt(pos + 1) === ASTERISK ? (next = css.indexOf("*/", pos + 2) + 1, 
                    0 === next && (ignore ? next = css.length : unclosed("comment")), content = css.slice(pos, next + 1), 
                    lines = content.split("\n"), last = lines.length - 1, last > 0 ? (nextLine = line + last, 
                    nextOffset = next - lines[last].length) : (nextLine = line, nextOffset = offset), 
                    tokens.push([ "comment", content, line, pos - offset, nextLine, next - nextOffset ]), 
                    offset = nextOffset, line = nextLine, pos = next) : (RE_WORD_END.lastIndex = pos + 1, 
                    RE_WORD_END.test(css), next = 0 === RE_WORD_END.lastIndex ? css.length - 1 : RE_WORD_END.lastIndex - 2, 
                    tokens.push([ "word", css.slice(pos, next + 1), line, pos - offset, line, next - offset ]), 
                    pos = next);
                }
                pos++;
            }
            return tokens;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = tokenize;
        var SINGLE_QUOTE = "'".charCodeAt(0), DOUBLE_QUOTE = '"'.charCodeAt(0), BACKSLASH = "\\".charCodeAt(0), SLASH = "/".charCodeAt(0), NEWLINE = "\n".charCodeAt(0), SPACE = " ".charCodeAt(0), FEED = "\f".charCodeAt(0), TAB = "\t".charCodeAt(0), CR = "\r".charCodeAt(0), OPEN_SQUARE = "[".charCodeAt(0), CLOSE_SQUARE = "]".charCodeAt(0), OPEN_PARENTHESES = "(".charCodeAt(0), CLOSE_PARENTHESES = ")".charCodeAt(0), OPEN_CURLY = "{".charCodeAt(0), CLOSE_CURLY = "}".charCodeAt(0), SEMICOLON = ";".charCodeAt(0), ASTERISK = "*".charCodeAt(0), COLON = ":".charCodeAt(0), AT = "@".charCodeAt(0), RE_AT_END = /[ \n\t\r\f\{\(\)'"\\;\/\[\]#]/g, RE_WORD_END = /[ \n\t\r\f\(\)\{\}:;@!'"\\\]\[#]|\/(?=\*)/g, RE_BAD_BRACKET = /.[\\\/\("'\n]/;
        module.exports = exports.default;
    }, /* 141 */
    /***/
    function(module, exports) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function capitalize(str) {
            return str[0].toUpperCase() + str.slice(1);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), defaultRaw = {
            colon: ": ",
            indent: "    ",
            beforeDecl: "\n",
            beforeRule: "\n",
            beforeOpen: " ",
            beforeClose: "\n",
            beforeComment: "\n",
            after: "\n",
            emptyBody: "",
            commentLeft: " ",
            commentRight: " "
        }, Stringifier = function() {
            function Stringifier(builder) {
                _classCallCheck(this, Stringifier), this.builder = builder;
            }
            return _createClass(Stringifier, [ {
                key: "stringify",
                value: function(node, semicolon) {
                    this[node.type](node, semicolon);
                }
            }, {
                key: "root",
                value: function(node) {
                    this.body(node), node.raws.after && this.builder(node.raws.after);
                }
            }, {
                key: "comment",
                value: function(node) {
                    var left = this.raw(node, "left", "commentLeft"), right = this.raw(node, "right", "commentRight");
                    this.builder("/*" + left + node.text + right + "*/", node);
                }
            }, {
                key: "decl",
                value: function(node, semicolon) {
                    var between = this.raw(node, "between", "colon"), string = node.prop + between + this.rawValue(node, "value");
                    node.important && (string += node.raws.important || " !important"), semicolon && (string += ";"), 
                    this.builder(string, node);
                }
            }, {
                key: "rule",
                value: function(node) {
                    this.block(node, this.rawValue(node, "selector"));
                }
            }, {
                key: "atrule",
                value: function(node, semicolon) {
                    var name = "@" + node.name, params = node.params ? this.rawValue(node, "params") : "";
                    if ("undefined" != typeof node.raws.afterName ? name += node.raws.afterName : params && (name += " "), 
                    node.nodes) this.block(node, name + params); else {
                        var end = (node.raws.between || "") + (semicolon ? ";" : "");
                        this.builder(name + params + end, node);
                    }
                }
            }, {
                key: "body",
                value: function(node) {
                    for (var last = node.nodes.length - 1; last > 0 && "comment" === node.nodes[last].type; ) last -= 1;
                    for (var semicolon = this.raw(node, "semicolon"), i = 0; i < node.nodes.length; i++) {
                        var child = node.nodes[i], before = this.raw(child, "before");
                        before && this.builder(before), this.stringify(child, last !== i || semicolon);
                    }
                }
            }, {
                key: "block",
                value: function(node, start) {
                    var between = this.raw(node, "between", "beforeOpen");
                    this.builder(start + between + "{", node, "start");
                    var after = void 0;
                    node.nodes && node.nodes.length ? (this.body(node), after = this.raw(node, "after")) : after = this.raw(node, "after", "emptyBody"), 
                    after && this.builder(after), this.builder("}", node, "end");
                }
            }, {
                key: "raw",
                value: function(node, own, detect) {
                    var value = void 0;
                    // Already had
                    if (detect || (detect = own), own && (value = node.raws[own], "undefined" != typeof value)) return value;
                    var parent = node.parent;
                    // Hack for first rule in CSS
                    if ("before" === detect && (!parent || "root" === parent.type && parent.first === node)) return "";
                    // Floating child without parent
                    if (!parent) return defaultRaw[detect];
                    // Detect style by other nodes
                    var root = node.root();
                    if (root.rawCache || (root.rawCache = {}), "undefined" != typeof root.rawCache[detect]) return root.rawCache[detect];
                    if ("before" === detect || "after" === detect) return this.beforeAfter(node, detect);
                    var method = "raw" + capitalize(detect);
                    return this[method] ? value = this[method](root, node) : root.walk(function(i) {
                        if (value = i.raws[own], "undefined" != typeof value) return !1;
                    }), "undefined" == typeof value && (value = defaultRaw[detect]), root.rawCache[detect] = value, 
                    value;
                }
            }, {
                key: "rawSemicolon",
                value: function(root) {
                    var value = void 0;
                    return root.walk(function(i) {
                        if (i.nodes && i.nodes.length && "decl" === i.last.type && (value = i.raws.semicolon, 
                        "undefined" != typeof value)) return !1;
                    }), value;
                }
            }, {
                key: "rawEmptyBody",
                value: function(root) {
                    var value = void 0;
                    return root.walk(function(i) {
                        if (i.nodes && 0 === i.nodes.length && (value = i.raws.after, "undefined" != typeof value)) return !1;
                    }), value;
                }
            }, {
                key: "rawIndent",
                value: function(root) {
                    if (root.raws.indent) return root.raws.indent;
                    var value = void 0;
                    return root.walk(function(i) {
                        var p = i.parent;
                        if (p && p !== root && p.parent && p.parent === root && "undefined" != typeof i.raws.before) {
                            var parts = i.raws.before.split("\n");
                            return value = parts[parts.length - 1], value = value.replace(/[^\s]/g, ""), !1;
                        }
                    }), value;
                }
            }, {
                key: "rawBeforeComment",
                value: function(root, node) {
                    var value = void 0;
                    return root.walkComments(function(i) {
                        if ("undefined" != typeof i.raws.before) return value = i.raws.before, value.indexOf("\n") !== -1 && (value = value.replace(/[^\n]+$/, "")), 
                        !1;
                    }), "undefined" == typeof value && (value = this.raw(node, null, "beforeDecl")), 
                    value;
                }
            }, {
                key: "rawBeforeDecl",
                value: function(root, node) {
                    var value = void 0;
                    return root.walkDecls(function(i) {
                        if ("undefined" != typeof i.raws.before) return value = i.raws.before, value.indexOf("\n") !== -1 && (value = value.replace(/[^\n]+$/, "")), 
                        !1;
                    }), "undefined" == typeof value && (value = this.raw(node, null, "beforeRule")), 
                    value;
                }
            }, {
                key: "rawBeforeRule",
                value: function(root) {
                    var value = void 0;
                    return root.walk(function(i) {
                        if (i.nodes && (i.parent !== root || root.first !== i) && "undefined" != typeof i.raws.before) return value = i.raws.before, 
                        value.indexOf("\n") !== -1 && (value = value.replace(/[^\n]+$/, "")), !1;
                    }), value;
                }
            }, {
                key: "rawBeforeClose",
                value: function(root) {
                    var value = void 0;
                    return root.walk(function(i) {
                        if (i.nodes && i.nodes.length > 0 && "undefined" != typeof i.raws.after) return value = i.raws.after, 
                        value.indexOf("\n") !== -1 && (value = value.replace(/[^\n]+$/, "")), !1;
                    }), value;
                }
            }, {
                key: "rawBeforeOpen",
                value: function(root) {
                    var value = void 0;
                    return root.walk(function(i) {
                        if ("decl" !== i.type && (value = i.raws.between, "undefined" != typeof value)) return !1;
                    }), value;
                }
            }, {
                key: "rawColon",
                value: function(root) {
                    var value = void 0;
                    return root.walkDecls(function(i) {
                        if ("undefined" != typeof i.raws.between) return value = i.raws.between.replace(/[^\s:]/g, ""), 
                        !1;
                    }), value;
                }
            }, {
                key: "beforeAfter",
                value: function(node, detect) {
                    var value = void 0;
                    value = "decl" === node.type ? this.raw(node, null, "beforeDecl") : "comment" === node.type ? this.raw(node, null, "beforeComment") : "before" === detect ? this.raw(node, null, "beforeRule") : this.raw(node, null, "beforeClose");
                    for (var buf = node.parent, depth = 0; buf && "root" !== buf.type; ) depth += 1, 
                    buf = buf.parent;
                    if (value.indexOf("\n") !== -1) {
                        var indent = this.raw(node, null, "indent");
                        if (indent.length) for (var step = 0; step < depth; step++) value += indent;
                    }
                    return value;
                }
            }, {
                key: "rawValue",
                value: function(node, prop) {
                    var value = node[prop], raw = node.raws[prop];
                    return raw && raw.value === value ? raw.raw : value;
                }
            } ]), Stringifier;
        }();
        exports.default = Stringifier, module.exports = exports.default;
    }, /* 142 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function stringify(node, builder) {
            var str = new _stringifier2.default(builder);
            str.stringify(node);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = stringify;
        var _stringifier = __webpack_require__(141), _stringifier2 = _interopRequireDefault(_stringifier);
        module.exports = exports.default;
    }, /* 143 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _warnOnce = __webpack_require__(135), _warnOnce2 = _interopRequireDefault(_warnOnce), _node = __webpack_require__(136), _node2 = _interopRequireDefault(_node), Comment = function(_Node) {
            function Comment(defaults) {
                _classCallCheck(this, Comment);
                var _this = _possibleConstructorReturn(this, (Comment.__proto__ || Object.getPrototypeOf(Comment)).call(this, defaults));
                return _this.type = "comment", _this;
            }
            return _inherits(Comment, _Node), _createClass(Comment, [ {
                key: "left",
                get: function() {
                    return (0, _warnOnce2.default)("Comment#left was deprecated. Use Comment#raws.left"), 
                    this.raws.left;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("Comment#left was deprecated. Use Comment#raws.left"), this.raws.left = val;
                }
            }, {
                key: "right",
                get: function() {
                    return (0, _warnOnce2.default)("Comment#right was deprecated. Use Comment#raws.right"), 
                    this.raws.right;
                },
                set: function(val) {
                    (0, _warnOnce2.default)("Comment#right was deprecated. Use Comment#raws.right"), 
                    this.raws.right = val;
                }
            } ]), Comment;
        }(_node2.default);
        exports.default = Comment, module.exports = exports.default;
    }, /* 144 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        /**
	 * Contains helpers for safely splitting lists of CSS values,
	 * preserving parentheses and quotes.
	 *
	 * @example
	 * const list = postcss.list;
	 *
	 * @namespace list
	 */
        var list = {
            split: function split(string, separators, last) {
                for (var array = [], current = "", split = !1, func = 0, quote = !1, escape = !1, i = 0; i < string.length; i++) {
                    var letter = string[i];
                    quote ? escape ? escape = !1 : "\\" === letter ? escape = !0 : letter === quote && (quote = !1) : '"' === letter || "'" === letter ? quote = letter : "(" === letter ? func += 1 : ")" === letter ? func > 0 && (func -= 1) : 0 === func && separators.indexOf(letter) !== -1 && (split = !0), 
                    split ? ("" !== current && array.push(current.trim()), current = "", split = !1) : current += letter;
                }
                return (last || "" !== current) && array.push(current.trim()), array;
            },
            /**
	     * Safely splits space-separated values (such as those for `background`,
	     * `border-radius`, and other shorthand properties).
	     *
	     * @param {string} string - space-separated values
	     *
	     * @return {string[]} splitted values
	     *
	     * @example
	     * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
	     */
            space: function(string) {
                var spaces = [ " ", "\n", "\t" ];
                return list.split(string, spaces);
            },
            /**
	     * Safely splits comma-separated values (such as those for `transition-*`
	     * and `background` properties).
	     *
	     * @param {string} string - comma-separated values
	     *
	     * @return {string[]} splitted values
	     *
	     * @example
	     * postcss.list.comma('black, linear-gradient(white, black)')
	     * //=> ['black', 'linear-gradient(white, black)']
	     */
            comma: function comma(string) {
                var comma = ",";
                return list.split(string, [ comma ], !0);
            }
        };
        exports.default = list, module.exports = exports.default;
    }, /* 145 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function isPromise(obj) {
            return "object" === ("undefined" == typeof obj ? "undefined" : _typeof(obj)) && "function" == typeof obj.then;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _stringify2 = __webpack_require__(142), _stringify3 = _interopRequireDefault(_stringify2), _warnOnce = __webpack_require__(135), _warnOnce2 = _interopRequireDefault(_warnOnce), _result = __webpack_require__(146), _result2 = _interopRequireDefault(_result), _parse = __webpack_require__(132), _parse2 = _interopRequireDefault(_parse), LazyResult = function() {
            function LazyResult(processor, css, opts) {
                _classCallCheck(this, LazyResult), this.stringified = !1, this.processed = !1;
                var root = void 0;
                if ("object" === ("undefined" == typeof css ? "undefined" : _typeof(css)) && "root" === css.type) root = css; else if (css instanceof LazyResult || css instanceof _result2.default) root = css.root, 
                css.map && ("undefined" == typeof opts.map && (opts.map = {}), opts.map.inline || (opts.map.inline = !1), 
                opts.map.prev = css.map); else {
                    var parser = _parse2.default;
                    opts.syntax && (parser = opts.syntax.parse), opts.parser && (parser = opts.parser), 
                    parser.parse && (parser = parser.parse);
                    try {
                        root = parser(css, opts);
                    } catch (error) {
                        this.error = error;
                    }
                }
                this.result = new _result2.default(processor, root, opts);
            }
            /**
	     * Returns a {@link Processor} instance, which will be used
	     * for CSS transformations.
	     * @type {Processor}
	     */
            return _createClass(LazyResult, [ {
                key: "warnings",
                /**
	         * Processes input CSS through synchronous plugins
	         * and calls {@link Result#warnings()}.
	         *
	         * @return {Warning[]} warnings from plugins
	         */
                value: function() {
                    return this.sync().warnings();
                }
            }, {
                key: "toString",
                value: function() {
                    return this.css;
                }
            }, {
                key: "then",
                value: function(onFulfilled, onRejected) {
                    return this.async().then(onFulfilled, onRejected);
                }
            }, {
                key: "catch",
                value: function(onRejected) {
                    return this.async().catch(onRejected);
                }
            }, {
                key: "handleError",
                value: function(error, plugin) {
                    try {
                        if (this.error = error, "CssSyntaxError" !== error.name || error.plugin) {
                            if (plugin.postcssVersion) {
                                var pluginName = plugin.postcssPlugin, pluginVer = plugin.postcssVersion, runtimeVer = this.result.processor.version, a = pluginVer.split("."), b = runtimeVer.split(".");
                                (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) && (0, _warnOnce2.default)("Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below.");
                            }
                        } else error.plugin = plugin.postcssPlugin, error.setMessage();
                    } catch (err) {
                        console && console.error && console.error(err);
                    }
                }
            }, {
                key: "asyncTick",
                value: function(resolve, reject) {
                    var _this = this;
                    if (this.plugin >= this.processor.plugins.length) return this.processed = !0, resolve();
                    try {
                        !function() {
                            var plugin = _this.processor.plugins[_this.plugin], promise = _this.run(plugin);
                            _this.plugin += 1, isPromise(promise) ? promise.then(function() {
                                _this.asyncTick(resolve, reject);
                            }).catch(function(error) {
                                _this.handleError(error, plugin), _this.processed = !0, reject(error);
                            }) : _this.asyncTick(resolve, reject);
                        }();
                    } catch (error) {
                        this.processed = !0, reject(error);
                    }
                }
            }, {
                key: "async",
                value: function() {
                    var _this2 = this;
                    return this.processed ? new Promise(function(resolve, reject) {
                        _this2.error ? reject(_this2.error) : resolve(_this2.stringify());
                    }) : this.processing ? this.processing : (this.processing = new Promise(function(resolve, reject) {
                        return _this2.error ? reject(_this2.error) : (_this2.plugin = 0, void _this2.asyncTick(resolve, reject));
                    }).then(function() {
                        return _this2.processed = !0, _this2.stringify();
                    }), this.processing);
                }
            }, {
                key: "sync",
                value: function() {
                    var _this3 = this;
                    if (this.processed) return this.result;
                    if (this.processed = !0, this.processing) throw new Error("Use process(css).then(cb) to work with async plugins");
                    if (this.error) throw this.error;
                    return this.result.processor.plugins.forEach(function(plugin) {
                        var promise = _this3.run(plugin);
                        if (isPromise(promise)) throw new Error("Use process(css).then(cb) to work with async plugins");
                    }), this.result;
                }
            }, {
                key: "run",
                value: function(plugin) {
                    this.result.lastPlugin = plugin;
                    try {
                        return plugin(this.result.root, this.result);
                    } catch (error) {
                        throw this.handleError(error, plugin), error;
                    }
                }
            }, {
                key: "stringify",
                value: function() {
                    if (this.stringified) return this.result;
                    this.stringified = !0, this.sync();
                    var opts = this.result.opts, str = _stringify3.default;
                    opts.syntax && (str = opts.syntax.stringify), opts.stringifier && (str = opts.stringifier), 
                    str.stringify && (str = str.stringify);
                    var result = "";
                    return str(this.root, function(i) {
                        result += i;
                    }), this.result.css = result, this.result;
                }
            }, {
                key: "processor",
                get: function() {
                    return this.result.processor;
                }
            }, {
                key: "opts",
                get: function() {
                    return this.result.opts;
                }
            }, {
                key: "css",
                get: function() {
                    return this.stringify().css;
                }
            }, {
                key: "content",
                get: function() {
                    return this.stringify().content;
                }
            }, {
                key: "map",
                get: function() {
                    return this.stringify().map;
                }
            }, {
                key: "root",
                get: function() {
                    return this.sync().root;
                }
            }, {
                key: "messages",
                get: function() {
                    return this.sync().messages;
                }
            } ]), LazyResult;
        }();
        exports.default = LazyResult, module.exports = exports.default;
    }, /* 146 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _warning = __webpack_require__(147), _warning2 = _interopRequireDefault(_warning), Result = function() {
            /**
	   * @param {Processor} processor - processor used for this transformation.
	   * @param {Root}      root      - Root node after all transformations.
	   * @param {processOptions} opts - options from the {@link Processor#process}
	   *                                or {@link Root#toResult}
	   */
            function Result(processor, root, opts) {
                _classCallCheck(this, Result), /**
	     * @member {Processor} - The Processor instance used
	     *                       for this transformation.
	     *
	     * @example
	     * for ( let plugin of result.processor.plugins) {
	     *   if ( plugin.postcssPlugin === 'postcss-bad' ) {
	     *     throw 'postcss-good is incompatible with postcss-bad';
	     *   }
	     * });
	     */
                this.processor = processor, /**
	     * @member {Message[]} - Contains messages from plugins
	     *                       (e.g., warnings or custom messages).
	     *                       Each message should have type
	     *                       and plugin properties.
	     *
	     * @example
	     * postcss.plugin('postcss-min-browser', () => {
	     *   return (root, result) => {
	     *     var browsers = detectMinBrowsersByCanIUse(root);
	     *     result.messages.push({
	     *       type:    'min-browser',
	     *       plugin:  'postcss-min-browser',
	     *       browsers: browsers
	     *     });
	     *   };
	     * });
	     */
                this.messages = [], /**
	     * @member {Root} - Root node after all transformations.
	     *
	     * @example
	     * root.toResult().root == root;
	     */
                this.root = root, /**
	     * @member {processOptions} - Options from the {@link Processor#process}
	     *                            or {@link Root#toResult} call
	     *                            that produced this Result instance.
	     *
	     * @example
	     * root.toResult(opts).opts == opts;
	     */
                this.opts = opts, /**
	     * @member {string} - A CSS string representing of {@link Result#root}.
	     *
	     * @example
	     * postcss.parse('a{}').toResult().css //=> "a{}"
	     */
                this.css = void 0, /**
	     * @member {SourceMapGenerator} - An instance of `SourceMapGenerator`
	     *                                class from the `source-map` library,
	     *                                representing changes
	     *                                to the {@link Result#root} instance.
	     *
	     * @example
	     * result.map.toJSON() //=> { version: 3, file: 'a.css',  }
	     *
	     * @example
	     * if ( result.map ) {
	     *   fs.writeFileSync(result.opts.to + '.map', result.map.toString());
	     * }
	     */
                this.map = void 0;
            }
            /**
	   * Returns for @{link Result#css} content.
	   *
	   * @example
	   * result + '' === result.css
	   *
	   * @return {string} string representing of {@link Result#root}
	   */
            return _createClass(Result, [ {
                key: "toString",
                value: function() {
                    return this.css;
                }
            }, {
                key: "warn",
                value: function(text) {
                    var opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    opts.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (opts.plugin = this.lastPlugin.postcssPlugin);
                    var warning = new _warning2.default(text, opts);
                    return this.messages.push(warning), warning;
                }
            }, {
                key: "warnings",
                value: function() {
                    return this.messages.filter(function(i) {
                        return "warning" === i.type;
                    });
                }
            }, {
                key: "content",
                get: function() {
                    return this.css;
                }
            } ]), Result;
        }();
        exports.default = Result, module.exports = exports.default;
    }, /* 147 */
    /***/
    function(module, exports) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), Warning = function() {
            /**
	   * @param {string} text        - warning message
	   * @param {Object} [opts]      - warning options
	   * @param {Node}   opts.node   - CSS node that caused the warning
	   * @param {string} opts.word   - word in CSS source that caused the warning
	   * @param {number} opts.index  - index in CSS node string that caused
	   *                               the warning
	   * @param {string} opts.plugin - name of the plugin that created
	   *                               this warning. {@link Result#warn} fills
	   *                               this property automatically.
	   */
            function Warning(text) {
                var opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (_classCallCheck(this, Warning), /**
	     * @member {string} - Type to filter warnings from
	     *                    {@link Result#messages}. Always equal
	     *                    to `"warning"`.
	     *
	     * @example
	     * const nonWarning = result.messages.filter(i => i.type !== 'warning')
	     */
                this.type = "warning", /**
	     * @member {string} - The warning message.
	     *
	     * @example
	     * warning.text //=> 'Try to avoid !important'
	     */
                this.text = text, opts.node && opts.node.source) {
                    var pos = opts.node.positionBy(opts);
                    /**
	       * @member {number} - Line in the input file
	       *                    with this warnings source
	       *
	       * @example
	       * warning.line //=> 5
	       */
                    this.line = pos.line, /**
	       * @member {number} - Column in the input file
	       *                    with this warnings source.
	       *
	       * @example
	       * warning.column //=> 6
	       */
                    this.column = pos.column;
                }
                for (var opt in opts) this[opt] = opts[opt];
            }
            /**
	   * Returns a warning position and message.
	   *
	   * @example
	   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
	   *
	   * @return {string} warning position and message
	   */
            return _createClass(Warning, [ {
                key: "toString",
                value: function() {
                    return this.node ? this.node.error(this.text, {
                        plugin: this.plugin,
                        index: this.index,
                        word: this.word
                    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
                }
            } ]), Warning;
        }();
        exports.default = Warning, module.exports = exports.default;
    }, /* 148 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _lazyResult = __webpack_require__(145), _lazyResult2 = _interopRequireDefault(_lazyResult), Processor = function() {
            /**
	   * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS
	   *        plugins. See {@link Processor#use} for plugin format.
	   */
            function Processor() {
                var plugins = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                _classCallCheck(this, Processor), /**
	     * @member {string} - Current PostCSS version.
	     *
	     * @example
	     * if ( result.processor.version.split('.')[0] !== '5' ) {
	     *   throw new Error('This plugin works only with PostCSS 5');
	     * }
	     */
                this.version = "5.2.0", /**
	     * @member {pluginFunction[]} - Plugins added to this processor.
	     *
	     * @example
	     * const processor = postcss([autoprefixer, precss]);
	     * processor.plugins.length //=> 2
	     */
                this.plugins = this.normalize(plugins);
            }
            /**
	   * Adds a plugin to be used as a CSS processor.
	   *
	   * PostCSS plugin can be in 4 formats:
	   * * A plugin created by {@link postcss.plugin} method.
	   * * A function. PostCSS will pass the function a @{link Root}
	   *   as the first argument and current {@link Result} instance
	   *   as the second.
	   * * An object with a `postcss` method. PostCSS will use that method
	   *   as described in #2.
	   * * Another {@link Processor} instance. PostCSS will copy plugins
	   *   from that instance into this one.
	   *
	   * Plugins can also be added by passing them as arguments when creating
	   * a `postcss` instance (see [`postcss(plugins)`]).
	   *
	   * Asynchronous plugins should return a `Promise` instance.
	   *
	   * @param {Plugin|pluginFunction|Processor} plugin - PostCSS plugin
	   *                                                   or {@link Processor}
	   *                                                   with plugins
	   *
	   * @example
	   * const processor = postcss()
	   *   .use(autoprefixer)
	   *   .use(precss);
	   *
	   * @return {Processes} current processor to make methods chain
	   */
            return _createClass(Processor, [ {
                key: "use",
                value: function(plugin) {
                    return this.plugins = this.plugins.concat(this.normalize([ plugin ])), this;
                }
            }, {
                key: "process",
                value: function(css) {
                    var opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return new _lazyResult2.default(this, css, opts);
                }
            }, {
                key: "normalize",
                value: function(plugins) {
                    var normalized = [];
                    return plugins.forEach(function(i) {
                        if (i.postcss && (i = i.postcss), "object" === ("undefined" == typeof i ? "undefined" : _typeof(i)) && Array.isArray(i.plugins)) normalized = normalized.concat(i.plugins); else {
                            if ("function" != typeof i) throw new Error(i + " is not a PostCSS plugin");
                            normalized.push(i);
                        }
                    }), normalized;
                }
            } ]), Processor;
        }();
        exports.default = Processor, module.exports = exports.default;
    }, /* 149 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _tokenize2 = __webpack_require__(140), _tokenize3 = _interopRequireDefault(_tokenize2), _comment = __webpack_require__(143), _comment2 = _interopRequireDefault(_comment), _parser = __webpack_require__(133), _parser2 = _interopRequireDefault(_parser), SafeParser = function(_Parser) {
            function SafeParser() {
                return _classCallCheck(this, SafeParser), _possibleConstructorReturn(this, (SafeParser.__proto__ || Object.getPrototypeOf(SafeParser)).apply(this, arguments));
            }
            return _inherits(SafeParser, _Parser), _createClass(SafeParser, [ {
                key: "tokenize",
                value: function() {
                    this.tokens = (0, _tokenize3.default)(this.input, {
                        ignoreErrors: !0
                    });
                }
            }, {
                key: "comment",
                value: function(token) {
                    var node = new _comment2.default();
                    this.init(node, token[2], token[3]), node.source.end = {
                        line: token[4],
                        column: token[5]
                    };
                    var text = token[1].slice(2);
                    if ("*/" === text.slice(-2) && (text = text.slice(0, -2)), /^\s*$/.test(text)) node.text = "", 
                    node.raws.left = text, node.raws.right = ""; else {
                        var match = text.match(/^(\s*)([^]*[^\s])(\s*)$/);
                        node.text = match[2], node.raws.left = match[1], node.raws.right = match[3];
                    }
                }
            }, {
                key: "unclosedBracket",
                value: function() {}
            }, {
                key: "unknownWord",
                value: function(start) {
                    var buffer = this.tokens.slice(start, this.pos + 1);
                    this.spaces += buffer.map(function(i) {
                        return i[1];
                    }).join("");
                }
            }, {
                key: "unexpectedClose",
                value: function() {
                    this.current.raws.after += "}";
                }
            }, {
                key: "doubleColon",
                value: function() {}
            }, {
                key: "unnamedAtrule",
                value: function(node) {
                    node.name = "";
                }
            }, {
                key: "precheckMissedSemicolon",
                value: function(tokens) {
                    var colon = this.colon(tokens);
                    if (colon !== !1) {
                        var split = void 0;
                        for (split = colon - 1; split >= 0 && "word" !== tokens[split][0]; split--) ;
                        for (split -= 1; split >= 0; split--) if ("space" !== tokens[split][0]) {
                            split += 1;
                            break;
                        }
                        var other = tokens.splice(split, tokens.length - split);
                        this.decl(other);
                    }
                }
            }, {
                key: "checkMissedSemicolon",
                value: function() {}
            }, {
                key: "endFile",
                value: function() {
                    for (this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), 
                    this.current.raws.after = (this.current.raws.after || "") + this.spaces; this.current.parent; ) this.current = this.current.parent, 
                    this.current.raws.after = "";
                }
            } ]), SafeParser;
        }(_parser2.default);
        exports.default = SafeParser, module.exports = exports.default;
    }, /* 150 */
    /***/
    function(module, exports) {
        "use strict";
        function selectors(parent, node) {
            var result = [];
            return parent.selectors.forEach(function(i) {
                node.selectors.forEach(function(j) {
                    j.indexOf("&") === -1 ? result.push(i + " " + j) : result.push(j.replace(/&/g, i));
                });
            }), result;
        }
        function pickComment(comment, after) {
            return comment && "comment" === comment.type ? comment.moveAfter(after) : after;
        }
        function atruleChilds(rule, atrule) {
            var children = [];
            if (atrule.each(function(child) {
                "comment" === child.type && children.push(child), "decl" === child.type ? children.push(child) : "rule" === child.type ? child.selectors = selectors(rule, child) : "atrule" === child.type && atruleChilds(rule, child);
            }), children.length) {
                for (var clone = rule.clone({
                    nodes: []
                }), i = 0; i < children.length; i++) children[i].moveTo(clone);
                atrule.prepend(clone);
            }
        }
        function processRule(rule, bubble) {
            var unwrapped = !1, after = rule;
            rule.each(function(child) {
                "rule" === child.type ? (unwrapped = !0, child.selectors = selectors(rule, child), 
                after = pickComment(child.prev(), after), after = child.moveAfter(after)) : "atrule" === child.type && bubble.indexOf(child.name) !== -1 && (unwrapped = !0, 
                atruleChilds(rule, child), after = pickComment(child.prev(), after), after = child.moveAfter(after));
            }), unwrapped && (rule.raws.semicolon = !0, 0 === rule.nodes.length && rule.remove());
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var bubble = [ "media", "supports", "document" ], process = function process(node) {
            node.each(function(child) {
                "rule" === child.type ? processRule(child, bubble) : "atrule" === child.type && process(child);
            });
        };
        exports.default = process, module.exports = exports.default;
    }, /* 151 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _sheet = __webpack_require__(152), StyleSheet = (__webpack_require__(118).babelPluginFlowReactPropTypes_proptype_GlamorInsertedRule || __webpack_require__(109).PropTypes.any, 
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_GlamorRule || __webpack_require__(109).PropTypes.any, 
        function() {
            function StyleSheet() {
                _classCallCheck(this, StyleSheet), /* Don't specify a maxLength for the global sheet, since these rules
	     * are defined at initialization and should remain static after that */
                this.globalStyleSheet = new _sheet.StyleSheet({
                    speedy: !1
                }), this.componentStyleSheet = new _sheet.StyleSheet({
                    speedy: !1,
                    maxLength: 40
                });
            }
            return _createClass(StyleSheet, [ {
                key: "inject",
                value: function() {
                    this.globalStyleSheet.inject(), this.componentStyleSheet.inject();
                }
            }, {
                key: "flush",
                value: function() {
                    this.globalStyleSheet.sheet && this.globalStyleSheet.flush(), this.componentStyleSheet.sheet && this.componentStyleSheet.flush();
                }
            }, {
                key: "insert",
                value: function(rule) {
                    var opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                        global: !1
                    }, sheet = opts.global ? this.globalStyleSheet : this.componentStyleSheet;
                    return sheet.insert(rule);
                }
            }, {
                key: "rules",
                value: function() {
                    return this.globalStyleSheet.rules().concat(this.componentStyleSheet.rules());
                }
            }, {
                key: "injected",
                get: function() {
                    return this.globalStyleSheet.injected && this.componentStyleSheet.injected;
                }
            } ]), StyleSheet;
        }());
        /* Export stylesheet as a singleton class */
        exports.default = new StyleSheet(), module.exports = exports.default;
    }, /* 152 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function _toConsumableArray(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2;
                }
                return Array.from(arr);
            }
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            /*
	
	high performance StyleSheet for css-in-js systems
	
	- uses multiple style tags behind the scenes for millions of rules
	- uses `insertRule` for appending in production for *much* faster performance
	- 'polyfills' on server side
	
	
	// usage
	
	import StyleSheet from 'glamor/lib/sheet'
	let styleSheet = new StyleSheet()
	
	styleSheet.inject()
	- 'injects' the stylesheet into the page (or into memory if on server)
	
	styleSheet.insert('#box { border: 1px solid red; }')
	- appends a css rule into the stylesheet
	
	styleSheet.flush()
	- empties the stylesheet of all its contents
	
	
	*/
            function last(arr) {
                return arr[arr.length - 1];
            }
            function sheetForTag(tag) {
                for (var i = 0; i < document.styleSheets.length; i++) if (document.styleSheets[i].ownerNode === tag) return document.styleSheets[i];
            }
            function makeStyleTag() {
                var tag = document.createElement("style");
                return tag.type = "text/css", tag.appendChild(document.createTextNode("")), (document.head || document.getElementsByTagName("head")[0]).appendChild(tag), 
                tag;
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                    Constructor;
                };
            }(), isBrowser = "undefined" != typeof document, isDev = function(x) {
                return "development" === x || !x;
            }(process.env.NODE_ENV), isTest = "test" === process.env.NODE_ENV, oldIE = function() {
                if (isBrowser) {
                    var div = document.createElement("div");
                    return div.innerHTML = "<!--[if lt IE 10]><i></i><![endif]-->", 1 === div.getElementsByTagName("i").length;
                }
            }();
            exports.StyleSheet = function() {
                function StyleSheet() {
                    var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref$speedy = _ref.speedy, speedy = void 0 === _ref$speedy ? !isDev && !isTest : _ref$speedy, _ref$maxLength = _ref.maxLength, maxLength = void 0 === _ref$maxLength ? isBrowser && oldIE ? 4e3 : 65e3 : _ref$maxLength;
                    _classCallCheck(this, StyleSheet), this.isSpeedy = speedy, // the big drawback here is that the css won't be editable in devtools
                    this.sheet = void 0, this.tags = [], this.maxLength = maxLength, this.ctr = 0;
                }
                return _createClass(StyleSheet, [ {
                    key: "inject",
                    value: function() {
                        var _this = this;
                        if (this.injected) throw new Error("already injected stylesheet!");
                        isBrowser ? (// this section is just weird alchemy I found online off many sources
                        this.tags[0] = makeStyleTag(), // this weirdness brought to you by firefox
                        this.sheet = sheetForTag(this.tags[0])) : // server side 'polyfill'. just enough behavior to be useful.
                        this.sheet = {
                            cssRules: [],
                            insertRule: function(rule) {
                                // enough 'spec compliance' to be able to extract the rules later
                                // in other words, just the cssText field
                                var serverRule = {
                                    cssText: rule
                                };
                                return _this.sheet.cssRules.push(serverRule), {
                                    serverRule: serverRule,
                                    appendRule: function(newCss) {
                                        return serverRule.cssText += newCss;
                                    }
                                };
                            }
                        }, this.injected = !0;
                    }
                }, {
                    key: "speedy",
                    value: function(bool) {
                        if (0 !== this.ctr) throw new Error("cannot change speedy mode after inserting any rule to sheet. Either call speedy(" + bool + ") earlier in your app, or call flush() before speedy(" + bool + ")");
                        this.isSpeedy = !!bool;
                    }
                }, {
                    key: "_insert",
                    value: function(rule) {
                        // this weirdness for perf, and chrome's weird bug
                        // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule
                        try {
                            this.sheet.insertRule(rule, this.sheet.cssRules.length);
                        } catch (e) {
                            isDev && // might need beter dx for this
                            console.warn("whoops, illegal rule inserted", rule);
                        }
                    }
                }, {
                    key: "insert",
                    value: function(rule) {
                        var _this2 = this, insertedRule = void 0;
                        // this is the ultrafast version, works across browsers
                        // server side is pretty simple
                        return isBrowser ? this.isSpeedy && this.sheet.insertRule ? this._insert(rule) : !function() {
                            var textNode = document.createTextNode(rule);
                            last(_this2.tags).appendChild(textNode), insertedRule = {
                                textNode: textNode,
                                appendRule: function(newCss) {
                                    return textNode.appendData(newCss);
                                }
                            }, _this2.isSpeedy || (// sighhh
                            _this2.sheet = sheetForTag(last(_this2.tags)));
                        }() : insertedRule = this.sheet.insertRule(rule), this.ctr++, isBrowser && this.ctr % this.maxLength === 0 && (this.tags.push(makeStyleTag()), 
                        this.sheet = sheetForTag(last(this.tags))), insertedRule;
                    }
                }, {
                    key: "flush",
                    value: function() {
                        isBrowser ? (this.tags.forEach(function(tag) {
                            return tag.parentNode.removeChild(tag);
                        }), this.tags = [], this.sheet = null, this.ctr = 0) : // simpler on server
                        this.sheet.cssRules = [], this.injected = !1;
                    }
                }, {
                    key: "rules",
                    value: function() {
                        if (!isBrowser) return this.sheet.cssRules;
                        var arr = [];
                        return this.tags.forEach(function(tag) {
                            return arr.splice.apply(arr, [ arr.length, 0 ].concat(_toConsumableArray(Array.from(sheetForTag(tag).cssRules))));
                        }), arr;
                    }
                } ]), StyleSheet;
            }();
        }).call(exports, __webpack_require__(153));
    }, /* 153 */
    /***/
    function(module, exports) {
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
            return setTimeout(fun, 0);
            // if setTimeout wasn't available but was latter defined
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
            return clearTimeout(marker);
            // if clearTimeout wasn't available but was latter defined
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
            clearTimeout(marker);
            try {
                // when when somebody has screwed with setTimeout but no I.E. maddness
                return cachedClearTimeout(marker);
            } catch (e) {
                try {
                    // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                    return cachedClearTimeout.call(null, marker);
                } catch (e) {
                    // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                    // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                    return cachedClearTimeout.call(this, marker);
                }
            }
        }
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, runClearTimeout(timeout);
            }
        }
        // v8 likes predictible objects
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        // shim for using process in browser
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", // empty string to avoid regexp issues
        process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, 
        process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, /* 154 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(109), _validAttr = __webpack_require__(155), _validAttr2 = _interopRequireDefault(_validAttr), _isTag = __webpack_require__(156), _isTag2 = _interopRequireDefault(_isTag), _AbstractStyledComponent = __webpack_require__(157), _AbstractStyledComponent2 = _interopRequireDefault(_AbstractStyledComponent), _ThemeProvider = __webpack_require__(158);
        __webpack_require__(158).babelPluginFlowReactPropTypes_proptype_Theme || __webpack_require__(109).PropTypes.any, 
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_Target || __webpack_require__(109).PropTypes.any, 
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_RuleSet || __webpack_require__(109).PropTypes.any;
        exports.default = function(ComponentStyle) {
            // eslint-disable-next-line no-undef
            var createStyledComponent = function createStyledComponent(target, rules, parent) {
                /* Handle styled(OtherStyledComponent) differently */
                var isStyledComponent = _AbstractStyledComponent2.default.isPrototypeOf(target);
                if (!(0, _isTag2.default)(target) && isStyledComponent) return createStyledComponent(target.target, target.rules.concat(rules), target);
                var componentStyle = new ComponentStyle(rules), ParentComponent = parent || _AbstractStyledComponent2.default, StyledComponent = function(_ParentComponent) {
                    function StyledComponent() {
                        _classCallCheck(this, StyledComponent);
                        var _this = _possibleConstructorReturn(this, (StyledComponent.__proto__ || Object.getPrototypeOf(StyledComponent)).call(this));
                        return _this.state = {
                            theme: null,
                            generatedClassName: ""
                        }, _this;
                    }
                    return _inherits(StyledComponent, _ParentComponent), _createClass(StyledComponent, [ {
                        key: "generateAndInjectStyles",
                        value: function(theme, props) {
                            var executionContext = _extends({}, props, {
                                theme: theme
                            });
                            return componentStyle.generateAndInjectStyles(executionContext);
                        }
                    }, {
                        key: "componentWillMount",
                        value: function() {
                            var _this2 = this;
                            // If there is a theme in the context, subscribe to the event emitter. This
                            // is necessary due to pure components blocking context updates, this circumvents
                            // that by updating when an event is emitted
                            if (this.context[_ThemeProvider.CHANNEL]) {
                                var subscribe = this.context[_ThemeProvider.CHANNEL];
                                this.unsubscribe = subscribe(function(nextTheme) {
                                    // This will be called once immediately
                                    // Props should take precedence over ThemeProvider, which should take precedence over
                                    // defaultProps, but React automatically puts defaultProps on props.
                                    var defaultProps = _this2.constructor.defaultProps, isDefaultTheme = defaultProps && _this2.props.theme === defaultProps.theme, theme = _this2.props.theme && !isDefaultTheme ? _this2.props.theme : nextTheme, generatedClassName = _this2.generateAndInjectStyles(theme, _this2.props);
                                    _this2.setState({
                                        theme: theme,
                                        generatedClassName: generatedClassName
                                    });
                                });
                            } else {
                                var _theme = this.props.theme || {}, generatedClassName = this.generateAndInjectStyles(_theme, this.props);
                                this.setState({
                                    theme: _theme,
                                    generatedClassName: generatedClassName
                                });
                            }
                        }
                    }, {
                        key: "componentWillReceiveProps",
                        value: function(nextProps) {
                            var _this3 = this;
                            this.setState(function(oldState) {
                                // Props should take precedence over ThemeProvider, which should take precedence over
                                // defaultProps, but React automatically puts defaultProps on props.
                                var defaultProps = _this3.constructor.defaultProps, isDefaultTheme = defaultProps && nextProps.theme === defaultProps.theme, theme = nextProps.theme && !isDefaultTheme ? nextProps.theme : oldState.theme, generatedClassName = _this3.generateAndInjectStyles(theme, nextProps);
                                return {
                                    theme: theme,
                                    generatedClassName: generatedClassName
                                };
                            });
                        }
                    }, {
                        key: "componentWillUnmount",
                        value: function() {
                            this.unsubscribe && this.unsubscribe();
                        }
                    }, {
                        key: "render",
                        value: function() {
                            var _this4 = this, _props = this.props, className = _props.className, children = _props.children, innerRef = _props.innerRef, generatedClassName = this.state.generatedClassName, propsForElement = {};
                            /* Don't pass through non HTML tags through to HTML elements */
                            return Object.keys(this.props).filter(function(propName) {
                                return !(0, _isTag2.default)(target) || (0, _validAttr2.default)(propName);
                            }).forEach(function(propName) {
                                propsForElement[propName] = _this4.props[propName];
                            }), propsForElement.className = [ className, generatedClassName ].filter(function(x) {
                                return x;
                            }).join(" "), innerRef && (propsForElement.ref = innerRef, (0, _isTag2.default)(target) && delete propsForElement.innerRef), 
                            (0, _react.createElement)(target, propsForElement, children);
                        }
                    } ]), StyledComponent;
                }(ParentComponent);
                return StyledComponent.contextTypes = ParentComponent.contextTypes, StyledComponent.target = target, 
                StyledComponent.rules = rules, StyledComponent.displayName = (0, _isTag2.default)(target) ? "styled." + target : "Styled(" + (target.displayName || target.name) + ")", 
                StyledComponent;
            };
            return createStyledComponent;
        }, module.exports = exports.default;
    }, /* 155 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        /* Trying to avoid the unknown-prop errors on styled components
	 by filtering by React's attribute whitelist.
	 */
        /* Logic copied from ReactDOMUnknownPropertyHook */
        var reactProps = {
            children: !0,
            dangerouslySetInnerHTML: !0,
            key: !0,
            ref: !0,
            autoFocus: !0,
            defaultValue: !0,
            valueLink: !0,
            defaultChecked: !0,
            checkedLink: !0,
            innerHTML: !0,
            suppressContentEditableWarning: !0,
            onFocusIn: !0,
            onFocusOut: !0,
            className: !0,
            /* List copied from https://facebook.github.io/react/docs/events.html */
            onCopy: !0,
            onCut: !0,
            onPaste: !0,
            onCompositionEnd: !0,
            onCompositionStart: !0,
            onCompositionUpdate: !0,
            onKeyDown: !0,
            onKeyPress: !0,
            onKeyUp: !0,
            onFocus: !0,
            onBlur: !0,
            onChange: !0,
            onInput: !0,
            onSubmit: !0,
            onClick: !0,
            onContextMenu: !0,
            onDoubleClick: !0,
            onDrag: !0,
            onDragEnd: !0,
            onDragEnter: !0,
            onDragExit: !0,
            onDragLeave: !0,
            onDragOver: !0,
            onDragStart: !0,
            onDrop: !0,
            onMouseDown: !0,
            onMouseEnter: !0,
            onMouseLeave: !0,
            onMouseMove: !0,
            onMouseOut: !0,
            onMouseOver: !0,
            onMouseUp: !0,
            onSelect: !0,
            onTouchCancel: !0,
            onTouchEnd: !0,
            onTouchMove: !0,
            onTouchStart: !0,
            onScroll: !0,
            onWheel: !0,
            onAbort: !0,
            onCanPlay: !0,
            onCanPlayThrough: !0,
            onDurationChange: !0,
            onEmptied: !0,
            onEncrypted: !0,
            onEnded: !0,
            onError: !0,
            onLoadedData: !0,
            onLoadedMetadata: !0,
            onLoadStart: !0,
            onPause: !0,
            onPlay: !0,
            onPlaying: !0,
            onProgress: !0,
            onRateChange: !0,
            onSeeked: !0,
            onSeeking: !0,
            onStalled: !0,
            onSuspend: !0,
            onTimeUpdate: !0,
            onVolumeChange: !0,
            onWaiting: !0,
            onLoad: !0,
            onAnimationStart: !0,
            onAnimationEnd: !0,
            onAnimationIteration: !0,
            onTransitionEnd: !0,
            onCopyCapture: !0,
            onCutCapture: !0,
            onPasteCapture: !0,
            onCompositionEndCapture: !0,
            onCompositionStartCapture: !0,
            onCompositionUpdateCapture: !0,
            onKeyDownCapture: !0,
            onKeyPressCapture: !0,
            onKeyUpCapture: !0,
            onFocusCapture: !0,
            onBlurCapture: !0,
            onChangeCapture: !0,
            onInputCapture: !0,
            onSubmitCapture: !0,
            onClickCapture: !0,
            onContextMenuCapture: !0,
            onDoubleClickCapture: !0,
            onDragCapture: !0,
            onDragEndCapture: !0,
            onDragEnterCapture: !0,
            onDragExitCapture: !0,
            onDragLeaveCapture: !0,
            onDragOverCapture: !0,
            onDragStartCapture: !0,
            onDropCapture: !0,
            onMouseDownCapture: !0,
            onMouseEnterCapture: !0,
            onMouseLeaveCapture: !0,
            onMouseMoveCapture: !0,
            onMouseOutCapture: !0,
            onMouseOverCapture: !0,
            onMouseUpCapture: !0,
            onSelectCapture: !0,
            onTouchCancelCapture: !0,
            onTouchEndCapture: !0,
            onTouchMoveCapture: !0,
            onTouchStartCapture: !0,
            onScrollCapture: !0,
            onWheelCapture: !0,
            onAbortCapture: !0,
            onCanPlayCapture: !0,
            onCanPlayThroughCapture: !0,
            onDurationChangeCapture: !0,
            onEmptiedCapture: !0,
            onEncryptedCapture: !0,
            onEndedCapture: !0,
            onErrorCapture: !0,
            onLoadedDataCapture: !0,
            onLoadedMetadataCapture: !0,
            onLoadStartCapture: !0,
            onPauseCapture: !0,
            onPlayCapture: !0,
            onPlayingCapture: !0,
            onProgressCapture: !0,
            onRateChangeCapture: !0,
            onSeekedCapture: !0,
            onSeekingCapture: !0,
            onStalledCapture: !0,
            onSuspendCapture: !0,
            onTimeUpdateCapture: !0,
            onVolumeChangeCapture: !0,
            onWaitingCapture: !0,
            onLoadCapture: !0,
            onAnimationStartCapture: !0,
            onAnimationEndCapture: !0,
            onAnimationIterationCapture: !0,
            onTransitionEndCapture: !0
        }, htmlProps = {
            /**
	   * Standard Properties
	   */
            accept: !0,
            acceptCharset: !0,
            accessKey: !0,
            action: !0,
            allowFullScreen: !0,
            allowTransparency: !0,
            alt: !0,
            // specifies target context for links with `preload` type
            as: !0,
            async: !0,
            autoComplete: !0,
            // autoFocus is polyfilled/normalized by AutoFocusUtils
            // autoFocus: true,
            autoPlay: !0,
            capture: !0,
            cellPadding: !0,
            cellSpacing: !0,
            charSet: !0,
            challenge: !0,
            checked: !0,
            cite: !0,
            classID: !0,
            className: !0,
            cols: !0,
            colSpan: !0,
            content: !0,
            contentEditable: !0,
            contextMenu: !0,
            controls: !0,
            coords: !0,
            crossOrigin: !0,
            data: !0,
            // For `<object />` acts as `src`.
            dateTime: !0,
            default: !0,
            defer: !0,
            dir: !0,
            disabled: !0,
            download: !0,
            draggable: !0,
            encType: !0,
            form: !0,
            formAction: !0,
            formEncType: !0,
            formMethod: !0,
            formNoValidate: !0,
            formTarget: !0,
            frameBorder: !0,
            headers: !0,
            height: !0,
            hidden: !0,
            high: !0,
            href: !0,
            hrefLang: !0,
            htmlFor: !0,
            httpEquiv: !0,
            icon: !0,
            id: !0,
            inputMode: !0,
            integrity: !0,
            is: !0,
            keyParams: !0,
            keyType: !0,
            kind: !0,
            label: !0,
            lang: !0,
            list: !0,
            loop: !0,
            low: !0,
            manifest: !0,
            marginHeight: !0,
            marginWidth: !0,
            max: !0,
            maxLength: !0,
            media: !0,
            mediaGroup: !0,
            method: !0,
            min: !0,
            minLength: !0,
            // Caution; `option.selected` is not updated if `select.multiple` is
            // disabled with `removeAttribute`.
            multiple: !0,
            muted: !0,
            name: !0,
            nonce: !0,
            noValidate: !0,
            open: !0,
            optimum: !0,
            pattern: !0,
            placeholder: !0,
            playsInline: !0,
            poster: !0,
            preload: !0,
            profile: !0,
            radioGroup: !0,
            readOnly: !0,
            referrerPolicy: !0,
            rel: !0,
            required: !0,
            reversed: !0,
            role: !0,
            rows: !0,
            rowSpan: !0,
            sandbox: !0,
            scope: !0,
            scoped: !0,
            scrolling: !0,
            seamless: !0,
            selected: !0,
            shape: !0,
            size: !0,
            sizes: !0,
            span: !0,
            spellCheck: !0,
            src: !0,
            srcDoc: !0,
            srcLang: !0,
            srcSet: !0,
            start: !0,
            step: !0,
            style: !0,
            summary: !0,
            tabIndex: !0,
            target: !0,
            title: !0,
            // Setting .type throws on non-<input> tags
            type: !0,
            useMap: !0,
            value: !0,
            width: !0,
            wmode: !0,
            wrap: !0,
            /**
	   * RDFa Properties
	   */
            about: !0,
            datatype: !0,
            inlist: !0,
            prefix: !0,
            // property is also supported for OpenGraph in meta tags.
            property: !0,
            resource: !0,
            typeof: !0,
            vocab: !0,
            /**
	   * Non-standard Properties
	   */
            // autoCapitalize and autoCorrect are supported in Mobile Safari for
            // keyboard hints.
            autoCapitalize: !0,
            autoCorrect: !0,
            // autoSave allows WebKit/Blink to persist values of input fields on page reloads
            autoSave: !0,
            // color is for Safari mask-icon link
            color: !0,
            // itemProp, itemScope, itemType are for
            // Microdata support. See http://schema.org/docs/gs.html
            itemProp: !0,
            itemScope: !0,
            itemType: !0,
            // itemID and itemRef are for Microdata support as well but
            // only specified in the WHATWG spec document. See
            // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
            itemID: !0,
            itemRef: !0,
            // results show looking glass icon and recent searches on input
            // search fields in WebKit/Blink
            results: !0,
            // IE-only attribute that specifies security restrictions on an iframe
            // as an alternative to the sandbox attribute on IE<10
            security: !0,
            // IE-only attribute that controls focus behavior
            unselectable: 0
        }, svgProps = {
            accentHeight: !0,
            accumulate: !0,
            additive: !0,
            alignmentBaseline: !0,
            allowReorder: !0,
            alphabetic: !0,
            amplitude: !0,
            arabicForm: !0,
            ascent: !0,
            attributeName: !0,
            attributeType: !0,
            autoReverse: !0,
            azimuth: !0,
            baseFrequency: !0,
            baseProfile: !0,
            baselineShift: !0,
            bbox: !0,
            begin: !0,
            bias: !0,
            by: !0,
            calcMode: !0,
            capHeight: !0,
            clip: !0,
            clipPath: !0,
            clipRule: !0,
            clipPathUnits: !0,
            colorInterpolation: !0,
            colorInterpolationFilters: !0,
            colorProfile: !0,
            colorRendering: !0,
            contentScriptType: !0,
            contentStyleType: !0,
            cursor: !0,
            cx: !0,
            cy: !0,
            d: !0,
            decelerate: !0,
            descent: !0,
            diffuseConstant: !0,
            direction: !0,
            display: !0,
            divisor: !0,
            dominantBaseline: !0,
            dur: !0,
            dx: !0,
            dy: !0,
            edgeMode: !0,
            elevation: !0,
            enableBackground: !0,
            end: !0,
            exponent: !0,
            externalResourcesRequired: !0,
            fill: !0,
            fillOpacity: !0,
            fillRule: !0,
            filter: !0,
            filterRes: !0,
            filterUnits: !0,
            floodColor: !0,
            floodOpacity: !0,
            focusable: !0,
            fontFamily: !0,
            fontSize: !0,
            fontSizeAdjust: !0,
            fontStretch: !0,
            fontStyle: !0,
            fontVariant: !0,
            fontWeight: !0,
            format: !0,
            from: !0,
            fx: !0,
            fy: !0,
            g1: !0,
            g2: !0,
            glyphName: !0,
            glyphOrientationHorizontal: !0,
            glyphOrientationVertical: !0,
            glyphRef: !0,
            gradientTransform: !0,
            gradientUnits: !0,
            hanging: !0,
            horizAdvX: !0,
            horizOriginX: !0,
            ideographic: !0,
            imageRendering: !0,
            in: !0,
            in2: !0,
            intercept: !0,
            k: !0,
            k1: !0,
            k2: !0,
            k3: !0,
            k4: !0,
            kernelMatrix: !0,
            kernelUnitLength: !0,
            kerning: !0,
            keyPoints: !0,
            keySplines: !0,
            keyTimes: !0,
            lengthAdjust: !0,
            letterSpacing: !0,
            lightingColor: !0,
            limitingConeAngle: !0,
            local: !0,
            markerEnd: !0,
            markerMid: !0,
            markerStart: !0,
            markerHeight: !0,
            markerUnits: !0,
            markerWidth: !0,
            mask: !0,
            maskContentUnits: !0,
            maskUnits: !0,
            mathematical: !0,
            mode: !0,
            numOctaves: !0,
            offset: !0,
            opacity: !0,
            operator: !0,
            order: !0,
            orient: !0,
            orientation: !0,
            origin: !0,
            overflow: !0,
            overlinePosition: !0,
            overlineThickness: !0,
            paintOrder: !0,
            panose1: !0,
            pathLength: !0,
            patternContentUnits: !0,
            patternTransform: !0,
            patternUnits: !0,
            pointerEvents: !0,
            points: !0,
            pointsAtX: !0,
            pointsAtY: !0,
            pointsAtZ: !0,
            preserveAlpha: !0,
            preserveAspectRatio: !0,
            primitiveUnits: !0,
            r: !0,
            radius: !0,
            refX: !0,
            refY: !0,
            renderingIntent: !0,
            repeatCount: !0,
            repeatDur: !0,
            requiredExtensions: !0,
            requiredFeatures: !0,
            restart: !0,
            result: !0,
            rotate: !0,
            rx: !0,
            ry: !0,
            scale: !0,
            seed: !0,
            shapeRendering: !0,
            slope: !0,
            spacing: !0,
            specularConstant: !0,
            specularExponent: !0,
            speed: !0,
            spreadMethod: !0,
            startOffset: !0,
            stdDeviation: !0,
            stemh: !0,
            stemv: !0,
            stitchTiles: !0,
            stopColor: !0,
            stopOpacity: !0,
            strikethroughPosition: !0,
            strikethroughThickness: !0,
            string: !0,
            stroke: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeLinecap: !0,
            strokeLinejoin: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0,
            surfaceScale: !0,
            systemLanguage: !0,
            tableValues: !0,
            targetX: !0,
            targetY: !0,
            textAnchor: !0,
            textDecoration: !0,
            textRendering: !0,
            textLength: !0,
            to: !0,
            transform: !0,
            u1: !0,
            u2: !0,
            underlinePosition: !0,
            underlineThickness: !0,
            unicode: !0,
            unicodeBidi: !0,
            unicodeRange: !0,
            unitsPerEm: !0,
            vAlphabetic: !0,
            vHanging: !0,
            vIdeographic: !0,
            vMathematical: !0,
            values: !0,
            vectorEffect: !0,
            version: !0,
            vertAdvY: !0,
            vertOriginX: !0,
            vertOriginY: !0,
            viewBox: !0,
            viewTarget: !0,
            visibility: !0,
            widths: !0,
            wordSpacing: !0,
            writingMode: !0,
            x: !0,
            xHeight: !0,
            x1: !0,
            x2: !0,
            xChannelSelector: !0,
            xlinkActuate: !0,
            xlinkArcrole: !0,
            xlinkHref: !0,
            xlinkRole: !0,
            xlinkShow: !0,
            xlinkTitle: !0,
            xlinkType: !0,
            xmlBase: !0,
            xmlns: !0,
            xmlnsXlink: !0,
            xmlLang: !0,
            xmlSpace: !0,
            y: !0,
            y1: !0,
            y2: !0,
            yChannelSelector: !0,
            z: !0,
            zoomAndPan: !0
        }, ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", isCustomAttribute = RegExp.prototype.test.bind(new RegExp("^(data|aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$")), hasOwnProperty = {}.hasOwnProperty;
        exports.default = function(name) {
            return hasOwnProperty.call(htmlProps, name) || hasOwnProperty.call(svgProps, name) || isCustomAttribute(name.toLowerCase()) || hasOwnProperty.call(reactProps, name);
        }, module.exports = exports.default;
    }, /* 156 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function isTag(target) {
            return "string" == typeof target;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = isTag;
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_Target || __webpack_require__(109).PropTypes.any;
        module.exports = exports.default;
    }, /* 157 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _react = __webpack_require__(109), _ThemeProvider = __webpack_require__(158), AbstractStyledComponent = function(_Component) {
            function AbstractStyledComponent() {
                return _classCallCheck(this, AbstractStyledComponent), _possibleConstructorReturn(this, (AbstractStyledComponent.__proto__ || Object.getPrototypeOf(AbstractStyledComponent)).apply(this, arguments));
            }
            return _inherits(AbstractStyledComponent, _Component), AbstractStyledComponent;
        }(_react.Component);
        exports.default = AbstractStyledComponent, AbstractStyledComponent.contextTypes = _defineProperty({}, _ThemeProvider.CHANNEL, _react.PropTypes.func), 
        module.exports = exports.default;
    }, /* 158 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CHANNEL = void 0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _isFunction = __webpack_require__(159), _isFunction2 = _interopRequireDefault(_isFunction), _isPlainObject = __webpack_require__(122), _isPlainObject2 = _interopRequireDefault(_isPlainObject), _createBroadcast = __webpack_require__(160), _createBroadcast2 = _interopRequireDefault(_createBroadcast), CHANNEL = (__webpack_require__(160).babelPluginFlowReactPropTypes_proptype_Broadcast || __webpack_require__(109).PropTypes.any, 
        exports.CHANNEL = "__styled-components__");
        Object.defineProperty(module.exports, "babelPluginFlowReactPropTypes_proptype_Theme", {
            value: __webpack_require__(109).PropTypes.shape({})
        });
        /**
	 * Provide a theme to an entire react component tree via context and event listeners (have to do
	 * both context and event emitter as pure components block context updates)
	 */
        var ThemeProvider = function(_Component) {
            function ThemeProvider() {
                _classCallCheck(this, ThemeProvider);
                var _this = _possibleConstructorReturn(this, (ThemeProvider.__proto__ || Object.getPrototypeOf(ThemeProvider)).call(this));
                return _this.getTheme = _this.getTheme.bind(_this), _this;
            }
            return _inherits(ThemeProvider, _Component), _createClass(ThemeProvider, [ {
                key: "componentWillMount",
                value: function() {
                    var _this2 = this;
                    // If there is a ThemeProvider wrapper anywhere around this theme provider, merge this theme
                    // with the outer theme
                    if (this.context[CHANNEL]) {
                        var subscribe = this.context[CHANNEL];
                        this.unsubscribeToOuter = subscribe(function(theme) {
                            _this2.outerTheme = theme;
                        });
                    }
                    this.broadcast = (0, _createBroadcast2.default)(this.getTheme());
                }
            }, {
                key: "getChildContext",
                value: function() {
                    return _extends({}, this.context, _defineProperty({}, CHANNEL, this.broadcast.subscribe));
                }
            }, {
                key: "componentWillReceiveProps",
                value: function(nextProps) {
                    this.props.theme !== nextProps.theme && this.broadcast.publish(this.getTheme(nextProps.theme));
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this.context[CHANNEL] && this.unsubscribeToOuter();
                }
            }, {
                key: "getTheme",
                value: function(passedTheme) {
                    var theme = passedTheme || this.props.theme;
                    if ((0, _isFunction2.default)(theme)) {
                        var mergedTheme = theme(this.outerTheme);
                        if (!(0, _isPlainObject2.default)(mergedTheme)) throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
                        return mergedTheme;
                    }
                    if (!(0, _isPlainObject2.default)(theme)) throw new Error("[ThemeProvider] Please make your theme prop a plain object");
                    return _extends({}, this.outerTheme, theme);
                }
            }, {
                key: "render",
                value: function() {
                    return this.props.children ? _react2.default.Children.only(this.props.children) : null;
                }
            } ]), ThemeProvider;
        }(_react.Component);
        ThemeProvider.propTypes = {
            children: __webpack_require__(109).PropTypes.any,
            theme: __webpack_require__(109).PropTypes.oneOfType([ __webpack_require__(109).PropTypes.shape({}), __webpack_require__(109).PropTypes.func ]).isRequired
        }, ThemeProvider.childContextTypes = _defineProperty({}, CHANNEL, _react.PropTypes.func.isRequired), 
        ThemeProvider.contextTypes = _defineProperty({}, CHANNEL, _react.PropTypes.func), 
        exports.default = ThemeProvider;
    }, /* 159 */
    /***/
    function(module, exports) {
        function isFunction(fn) {
            var string = toString.call(fn);
            // IE8 and below
            return "[object Function]" === string || "function" == typeof fn && "[object RegExp]" !== string || "undefined" != typeof window && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
        }
        module.exports = isFunction;
        var toString = Object.prototype.toString;
    }, /* 160 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), Object.defineProperty(module.exports, "babelPluginFlowReactPropTypes_proptype_Broadcast", {
            value: __webpack_require__(109).PropTypes.shape({
                publish: __webpack_require__(109).PropTypes.func.isRequired,
                subscribe: __webpack_require__(109).PropTypes.func.isRequired
            })
        });
        /**
	 * Creates a broadcast that can be listened to, i.e. simple event emitter
	 *
	 * @see https://github.com/ReactTraining/react-broadcast
	 */
        var createBroadcast = function(initialValue) {
            var listeners = [], currentValue = initialValue;
            return {
                publish: function(value) {
                    currentValue = value, listeners.forEach(function(listener) {
                        return listener(currentValue);
                    });
                },
                subscribe: function(listener) {
                    // Publish to this subscriber once immediately.
                    return listeners.push(listener), listener(currentValue), function() {
                        listeners = listeners.filter(function(item) {
                            return item !== listener;
                        });
                    };
                }
            };
        };
        exports.default = createBroadcast, module.exports = exports.default;
    }, /* 161 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _css = __webpack_require__(116), _css2 = _interopRequireDefault(_css), _domElements = __webpack_require__(162), _domElements2 = _interopRequireDefault(_domElements);
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_Target || __webpack_require__(109).PropTypes.any, 
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_Interpolation || __webpack_require__(109).PropTypes.any;
        exports.default = function(styledComponent) {
            var styled = function(tag) {
                return function(strings) {
                    for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
                    return styledComponent(tag, _css2.default.apply(void 0, [ strings ].concat(interpolations)));
                };
            };
            // Shorthands for all valid HTML Elements
            return _domElements2.default.forEach(function(domElement) {
                styled[domElement] = styled(domElement);
            }), styled;
        }, module.exports = exports.default;
    }, /* 162 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), // Thanks to ReactDOMFactories for this handy list!
        exports.default = [ "a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", // SVG
        "circle", "clipPath", "defs", "ellipse", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan" ], 
        module.exports = exports.default;
    }, /* 163 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _hash = __webpack_require__(164), _hash2 = _interopRequireDefault(_hash), _css = __webpack_require__(116), _css2 = _interopRequireDefault(_css), _GlobalStyle = __webpack_require__(125), _GlobalStyle2 = _interopRequireDefault(_GlobalStyle), replaceWhitespace = (__webpack_require__(118).babelPluginFlowReactPropTypes_proptype_NameGenerator || __webpack_require__(109).PropTypes.any, 
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_Interpolation || __webpack_require__(109).PropTypes.any, 
        function(str) {
            return str.replace(/\s|\\n/g, "");
        });
        exports.default = function(nameGenerator) {
            return function(strings) {
                for (var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) interpolations[_key - 1] = arguments[_key];
                var rules = _css2.default.apply(void 0, [ strings ].concat(interpolations)), hash = (0, 
                _hash2.default)(replaceWhitespace(JSON.stringify(rules))), name = nameGenerator(hash), keyframes = new _GlobalStyle2.default(rules, "@keyframes " + name);
                return keyframes.generateAndInject(), name;
            };
        }, module.exports = exports.default;
    }, /* 164 */
    /***/
    function(module, exports) {
        "use strict";
        // murmurhash2 via https://gist.github.com/raycmorgan/588423
        function doHash(str, seed) {
            for (var m = 1540483477, r = 24, h = seed ^ str.length, length = str.length, currentIndex = 0; length >= 4; ) {
                var k = UInt32(str, currentIndex);
                k = Umul32(k, m), k ^= k >>> r, k = Umul32(k, m), h = Umul32(h, m), h ^= k, currentIndex += 4, 
                length -= 4;
            }
            switch (length) {
              case 3:
                h ^= UInt16(str, currentIndex), h ^= str.charCodeAt(currentIndex + 2) << 16, h = Umul32(h, m);
                break;

              case 2:
                h ^= UInt16(str, currentIndex), h = Umul32(h, m);
                break;

              case 1:
                h ^= str.charCodeAt(currentIndex), h = Umul32(h, m);
            }
            return h ^= h >>> 13, h = Umul32(h, m), h ^= h >>> 15, h >>> 0;
        }
        function UInt32(str, pos) {
            return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8) + (str.charCodeAt(pos++) << 16) + (str.charCodeAt(pos) << 24);
        }
        function UInt16(str, pos) {
            return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8);
        }
        function Umul32(n, m) {
            n |= 0, m |= 0;
            var nlo = 65535 & n, nhi = n >>> 16, res = nlo * m + ((nhi * m & 65535) << 16) | 0;
            return res;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = doHash;
    }, /* 165 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _hash = __webpack_require__(164), _hash2 = _interopRequireDefault(_hash), _flatten = __webpack_require__(119), _flatten2 = _interopRequireDefault(_flatten), _parse = __webpack_require__(126), _parse2 = _interopRequireDefault(_parse), _postcssNested = __webpack_require__(150), _postcssNested2 = _interopRequireDefault(_postcssNested), _autoprefix = __webpack_require__(166), _autoprefix2 = _interopRequireDefault(_autoprefix), _StyleSheet = __webpack_require__(151), _StyleSheet2 = _interopRequireDefault(_StyleSheet);
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_GlamorInsertedRule || __webpack_require__(109).PropTypes.any, 
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_NameGenerator || __webpack_require__(109).PropTypes.any, 
        __webpack_require__(118).babelPluginFlowReactPropTypes_proptype_RuleSet || __webpack_require__(109).PropTypes.any;
        /*
	 ComponentStyle is all the CSS-specific stuff, not
	 the React-specific stuff.
	 */
        exports.default = function(nameGenerator) {
            var inserted = {}, ComponentStyle = function() {
                function ComponentStyle(rules) {
                    _classCallCheck(this, ComponentStyle), this.rules = rules, _StyleSheet2.default.injected || _StyleSheet2.default.inject(), 
                    this.insertedRule = _StyleSheet2.default.insert("");
                }
                /*
	     * Flattens a rule set into valid CSS
	     * Hashes it, wraps the whole chunk in a ._hashName {}
	     * Parses that with PostCSS then runs PostCSS-Nested on it
	     * Returns the hash to be injected on render()
	     * */
                return _createClass(ComponentStyle, [ {
                    key: "generateAndInjectStyles",
                    value: function(executionContext) {
                        var flatCSS = (0, _flatten2.default)(this.rules, executionContext).join("").replace(/^\s*\/\/.*$/gm, ""), hash = (0, 
                        _hash2.default)(flatCSS);
                        if (!inserted[hash]) {
                            var selector = nameGenerator(hash);
                            inserted[hash] = selector;
                            var root = (0, _parse2.default)("." + selector + " { " + flatCSS + " }");
                            (0, _postcssNested2.default)(root), (0, _autoprefix2.default)(root), this.insertedRule.appendRule(root.toResult().css);
                        }
                        return inserted[hash];
                    }
                } ]), ComponentStyle;
            }();
            return ComponentStyle;
        }, module.exports = exports.default;
    }, /* 166 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _camelizeStyleName = __webpack_require__(167), _camelizeStyleName2 = _interopRequireDefault(_camelizeStyleName), _hyphenateStyleName = __webpack_require__(120), _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName), _static = __webpack_require__(169), _static2 = _interopRequireDefault(_static);
        __webpack_require__(131).babelPluginFlowReactPropTypes_proptype_Container || __webpack_require__(109).PropTypes.any;
        exports.default = function(root) {
            root.walkDecls(function(decl) {
                /* No point even checking custom props */
                if (!/^--/.test(decl.prop)) {
                    var objStyle = _defineProperty({}, (0, _camelizeStyleName2.default)(decl.prop), decl.value), prefixed = (0, 
                    _static2.default)(objStyle);
                    Object.keys(prefixed).reverse().forEach(function(newProp) {
                        var newVals = prefixed[newProp], newValArray = Array.isArray(newVals) ? newVals : [ newVals ];
                        newValArray.forEach(function(newVal) {
                            decl.cloneBefore({
                                prop: (0, _hyphenateStyleName2.default)(newProp),
                                value: newVal
                            });
                        });
                    }), decl.remove();
                }
            });
        }, module.exports = exports.default;
    }, /* 167 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
        "use strict";
        /**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
        function camelizeStyleName(string) {
            return camelize(string.replace(msPattern, "ms-"));
        }
        var camelize = __webpack_require__(168), msPattern = /^-ms-/;
        module.exports = camelizeStyleName;
    }, /* 168 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
        function camelize(string) {
            return string.replace(_hyphenPattern, function(_, character) {
                return character.toUpperCase();
            });
        }
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 */
        var _hyphenPattern = /-(.)/g;
        module.exports = camelize;
    }, /* 169 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(170);
    }, /* 170 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        /**
	 * Returns a prefixed version of the style object using all vendor prefixes
	 * @param {Object} styles - Style object that gets prefixed properties added
	 * @returns {Object} - Style object with prefixed properties and values
	 */
        function prefixAll(styles) {
            return Object.keys(styles).forEach(function(property) {
                var value = styles[property];
                value instanceof Object && !Array.isArray(value) ? // recurse through nested style objects
                styles[property] = prefixAll(value) : Object.keys(_prefixProps2.default).forEach(function(prefix) {
                    var properties = _prefixProps2.default[prefix];
                    // add prefixes if needed
                    properties[property] && (styles[prefix + (0, _capitalizeString2.default)(property)] = value);
                });
            }), Object.keys(styles).forEach(function(property) {
                [].concat(styles[property]).forEach(function(value, index) {
                    // resolve every special plugins
                    plugins.forEach(function(plugin) {
                        return assignStyles(styles, plugin(property, value));
                    });
                });
            }), (0, _sortPrefixedStyle2.default)(styles);
        }
        function assignStyles(base) {
            var extend = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1];
            Object.keys(extend).forEach(function(property) {
                var baseValue = base[property];
                Array.isArray(baseValue) ? [].concat(extend[property]).forEach(function(value) {
                    var valueIndex = baseValue.indexOf(value);
                    valueIndex > -1 && base[property].splice(valueIndex, 1), base[property].push(value);
                }) : base[property] = extend[property];
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = prefixAll;
        var _prefixProps = __webpack_require__(171), _prefixProps2 = _interopRequireDefault(_prefixProps), _capitalizeString = __webpack_require__(172), _capitalizeString2 = _interopRequireDefault(_capitalizeString), _sortPrefixedStyle = __webpack_require__(173), _sortPrefixedStyle2 = _interopRequireDefault(_sortPrefixedStyle), _position = __webpack_require__(175), _position2 = _interopRequireDefault(_position), _calc = __webpack_require__(176), _calc2 = _interopRequireDefault(_calc), _cursor = __webpack_require__(179), _cursor2 = _interopRequireDefault(_cursor), _flex = __webpack_require__(180), _flex2 = _interopRequireDefault(_flex), _sizing = __webpack_require__(181), _sizing2 = _interopRequireDefault(_sizing), _gradient = __webpack_require__(182), _gradient2 = _interopRequireDefault(_gradient), _transition = __webpack_require__(183), _transition2 = _interopRequireDefault(_transition), _flexboxIE = __webpack_require__(185), _flexboxIE2 = _interopRequireDefault(_flexboxIE), _flexboxOld = __webpack_require__(186), _flexboxOld2 = _interopRequireDefault(_flexboxOld), plugins = [ _position2.default, _calc2.default, _cursor2.default, _sizing2.default, _gradient2.default, _transition2.default, _flexboxIE2.default, _flexboxOld2.default, _flex2.default ];
        module.exports = exports.default;
    }, /* 171 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = {
            Webkit: {
                transform: !0,
                transformOrigin: !0,
                transformOriginX: !0,
                transformOriginY: !0,
                backfaceVisibility: !0,
                perspective: !0,
                perspectiveOrigin: !0,
                transformStyle: !0,
                transformOriginZ: !0,
                animation: !0,
                animationDelay: !0,
                animationDirection: !0,
                animationFillMode: !0,
                animationDuration: !0,
                animationIterationCount: !0,
                animationName: !0,
                animationPlayState: !0,
                animationTimingFunction: !0,
                appearance: !0,
                userSelect: !0,
                fontKerning: !0,
                textEmphasisPosition: !0,
                textEmphasis: !0,
                textEmphasisStyle: !0,
                textEmphasisColor: !0,
                boxDecorationBreak: !0,
                clipPath: !0,
                maskImage: !0,
                maskMode: !0,
                maskRepeat: !0,
                maskPosition: !0,
                maskClip: !0,
                maskOrigin: !0,
                maskSize: !0,
                maskComposite: !0,
                mask: !0,
                maskBorderSource: !0,
                maskBorderMode: !0,
                maskBorderSlice: !0,
                maskBorderWidth: !0,
                maskBorderOutset: !0,
                maskBorderRepeat: !0,
                maskBorder: !0,
                maskType: !0,
                textDecorationStyle: !0,
                textDecorationSkip: !0,
                textDecorationLine: !0,
                textDecorationColor: !0,
                filter: !0,
                fontFeatureSettings: !0,
                breakAfter: !0,
                breakBefore: !0,
                breakInside: !0,
                columnCount: !0,
                columnFill: !0,
                columnGap: !0,
                columnRule: !0,
                columnRuleColor: !0,
                columnRuleStyle: !0,
                columnRuleWidth: !0,
                columns: !0,
                columnSpan: !0,
                columnWidth: !0,
                flex: !0,
                flexBasis: !0,
                flexDirection: !0,
                flexGrow: !0,
                flexFlow: !0,
                flexShrink: !0,
                flexWrap: !0,
                alignContent: !0,
                alignItems: !0,
                alignSelf: !0,
                justifyContent: !0,
                order: !0,
                transition: !0,
                transitionDelay: !0,
                transitionDuration: !0,
                transitionProperty: !0,
                transitionTimingFunction: !0,
                backdropFilter: !0,
                scrollSnapType: !0,
                scrollSnapPointsX: !0,
                scrollSnapPointsY: !0,
                scrollSnapDestination: !0,
                scrollSnapCoordinate: !0,
                shapeImageThreshold: !0,
                shapeImageMargin: !0,
                shapeImageOutside: !0,
                hyphens: !0,
                flowInto: !0,
                flowFrom: !0,
                regionFragment: !0,
                textSizeAdjust: !0
            },
            Moz: {
                appearance: !0,
                userSelect: !0,
                boxSizing: !0,
                textAlignLast: !0,
                textDecorationStyle: !0,
                textDecorationSkip: !0,
                textDecorationLine: !0,
                textDecorationColor: !0,
                tabSize: !0,
                hyphens: !0,
                fontFeatureSettings: !0,
                breakAfter: !0,
                breakBefore: !0,
                breakInside: !0,
                columnCount: !0,
                columnFill: !0,
                columnGap: !0,
                columnRule: !0,
                columnRuleColor: !0,
                columnRuleStyle: !0,
                columnRuleWidth: !0,
                columns: !0,
                columnSpan: !0,
                columnWidth: !0
            },
            ms: {
                flex: !0,
                flexBasis: !1,
                flexDirection: !0,
                flexGrow: !1,
                flexFlow: !0,
                flexShrink: !1,
                flexWrap: !0,
                alignContent: !1,
                alignItems: !1,
                alignSelf: !1,
                justifyContent: !1,
                order: !1,
                transform: !0,
                transformOrigin: !0,
                transformOriginX: !0,
                transformOriginY: !0,
                userSelect: !0,
                wrapFlow: !0,
                wrapThrough: !0,
                wrapMargin: !0,
                scrollSnapType: !0,
                scrollSnapPointsX: !0,
                scrollSnapPointsY: !0,
                scrollSnapDestination: !0,
                scrollSnapCoordinate: !0,
                touchAction: !0,
                hyphens: !0,
                flowInto: !0,
                flowFrom: !0,
                breakBefore: !0,
                breakAfter: !0,
                breakInside: !0,
                regionFragment: !0,
                gridTemplateColumns: !0,
                gridTemplateRows: !0,
                gridTemplateAreas: !0,
                gridTemplate: !0,
                gridAutoColumns: !0,
                gridAutoRows: !0,
                gridAutoFlow: !0,
                grid: !0,
                gridRowStart: !0,
                gridColumnStart: !0,
                gridRowEnd: !0,
                gridRow: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnGap: !0,
                gridRowGap: !0,
                gridArea: !0,
                gridGap: !0,
                textSizeAdjust: !0
            }
        }, module.exports = exports.default;
    }, /* 172 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), // helper to capitalize strings
        exports.default = function(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }, module.exports = exports.default;
    }, /* 173 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function sortPrefixedStyle(style) {
            return Object.keys(style).sort(function(left, right) {
                return (0, _isPrefixedProperty2.default)(left) && !(0, _isPrefixedProperty2.default)(right) ? -1 : !(0, 
                _isPrefixedProperty2.default)(left) && (0, _isPrefixedProperty2.default)(right) ? 1 : 0;
            }).reduce(function(sortedStyle, prop) {
                return sortedStyle[prop] = style[prop], sortedStyle;
            }, {});
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = sortPrefixedStyle;
        var _isPrefixedProperty = __webpack_require__(174), _isPrefixedProperty2 = _interopRequireDefault(_isPrefixedProperty);
        module.exports = exports.default;
    }, /* 174 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = function(property) {
            return null !== property.match(/^(Webkit|Moz|O|ms)/);
        }, module.exports = exports.default;
    }, /* 175 */
    /***/
    function(module, exports) {
        "use strict";
        function position(property, value) {
            if ("position" === property && "sticky" === value) return {
                position: [ "-webkit-sticky", "sticky" ]
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = position, module.exports = exports.default;
    }, /* 176 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function calc(property, value) {
            if ("string" == typeof value && !(0, _isPrefixedValue2.default)(value) && value.indexOf("calc(") > -1) return (0, 
            _joinPrefixedValue2.default)(property, value, function(prefix, value) {
                return value.replace(/calc\(/g, prefix + "calc(");
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = calc;
        var _joinPrefixedValue = __webpack_require__(177), _joinPrefixedValue2 = _interopRequireDefault(_joinPrefixedValue), _isPrefixedValue = __webpack_require__(178), _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);
        module.exports = exports.default;
    }, /* 177 */
    /***/
    function(module, exports) {
        "use strict";
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), // returns a style object with a single concated prefixed value string
        exports.default = function(property, value) {
            var replacer = arguments.length <= 2 || void 0 === arguments[2] ? function(prefix, value) {
                return prefix + value;
            } : arguments[2];
            return _defineProperty({}, property, [ "-webkit-", "-moz-", "" ].map(function(prefix) {
                return replacer(prefix, value);
            }));
        }, module.exports = exports.default;
    }, /* 178 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = function(value) {
            return Array.isArray(value) && (value = value.join(",")), null !== value.match(/-webkit-|-moz-|-ms-/);
        }, module.exports = exports.default;
    }, /* 179 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function cursor(property, value) {
            if ("cursor" === property && values[value]) return (0, _joinPrefixedValue2.default)(property, value);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = cursor;
        var _joinPrefixedValue = __webpack_require__(177), _joinPrefixedValue2 = _interopRequireDefault(_joinPrefixedValue), values = {
            "zoom-in": !0,
            "zoom-out": !0,
            grab: !0,
            grabbing: !0
        };
        module.exports = exports.default;
    }, /* 180 */
    /***/
    function(module, exports) {
        "use strict";
        function flex(property, value) {
            if ("display" === property && values[value]) return {
                display: [ "-webkit-box", "-moz-box", "-ms-" + value + "box", "-webkit-" + value, value ]
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = flex;
        var values = {
            flex: !0,
            "inline-flex": !0
        };
        module.exports = exports.default;
    }, /* 181 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function sizing(property, value) {
            if (properties[property] && values[value]) return (0, _joinPrefixedValue2.default)(property, value);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = sizing;
        var _joinPrefixedValue = __webpack_require__(177), _joinPrefixedValue2 = _interopRequireDefault(_joinPrefixedValue), properties = {
            maxHeight: !0,
            maxWidth: !0,
            width: !0,
            height: !0,
            columnWidth: !0,
            minWidth: !0,
            minHeight: !0
        }, values = {
            "min-content": !0,
            "max-content": !0,
            "fill-available": !0,
            "fit-content": !0,
            "contain-floats": !0
        };
        module.exports = exports.default;
    }, /* 182 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function gradient(property, value) {
            if ("string" == typeof value && !(0, _isPrefixedValue2.default)(value) && null !== value.match(values)) return (0, 
            _joinPrefixedValue2.default)(property, value);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = gradient;
        var _joinPrefixedValue = __webpack_require__(177), _joinPrefixedValue2 = _interopRequireDefault(_joinPrefixedValue), _isPrefixedValue = __webpack_require__(178), _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue), values = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/;
        module.exports = exports.default;
    }, /* 183 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function transition(property, value) {
            // also check for already prefixed transitions
            if ("string" == typeof value && properties[property]) {
                var _ref2, outputValue = prefixValue(value), webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function(value) {
                    return null === value.match(/-moz-|-ms-/);
                }).join(",");
                // if the property is already prefixed
                // if the property is already prefixed
                return property.indexOf("Webkit") > -1 ? _defineProperty({}, property, webkitOutput) : (_ref2 = {}, 
                _defineProperty(_ref2, "Webkit" + (0, _capitalizeString2.default)(property), webkitOutput), 
                _defineProperty(_ref2, property, outputValue), _ref2);
            }
        }
        function prefixValue(value) {
            if ((0, _isPrefixedValue2.default)(value)) return value;
            // only split multi values, not cubic beziers
            var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);
            // iterate each single value and check for transitioned properties
            // that need to be prefixed as well
            return multipleValues.forEach(function(val, index) {
                multipleValues[index] = Object.keys(_prefixProps2.default).reduce(function(out, prefix) {
                    var dashCasePrefix = "-" + prefix.toLowerCase() + "-";
                    return Object.keys(_prefixProps2.default[prefix]).forEach(function(prop) {
                        var dashCaseProperty = (0, _hyphenateStyleName2.default)(prop);
                        val.indexOf(dashCaseProperty) > -1 && "order" !== dashCaseProperty && (// join all prefixes and create a new value
                        out = val.replace(dashCaseProperty, dashCasePrefix + dashCaseProperty) + "," + out);
                    }), out;
                }, val);
            }), multipleValues.join(",");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = transition;
        var _hyphenateStyleName = __webpack_require__(184), _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName), _capitalizeString = __webpack_require__(172), _capitalizeString2 = _interopRequireDefault(_capitalizeString), _isPrefixedValue = __webpack_require__(178), _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue), _prefixProps = __webpack_require__(171), _prefixProps2 = _interopRequireDefault(_prefixProps), properties = {
            transition: !0,
            transitionProperty: !0,
            WebkitTransition: !0,
            WebkitTransitionProperty: !0
        };
        module.exports = exports.default;
    }, /* 184 */
    /***/
    function(module, exports) {
        "use strict";
        function hyphenateStyleName(string) {
            return string in cache ? cache[string] : cache[string] = string.replace(uppercasePattern, "-$&").toLowerCase().replace(msPattern, "-ms-");
        }
        var uppercasePattern = /[A-Z]/g, msPattern = /^ms-/, cache = {};
        module.exports = hyphenateStyleName;
    }, /* 185 */
    /***/
    function(module, exports) {
        "use strict";
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function flexboxIE(property, value) {
            if (alternativeProps[property]) return _defineProperty({}, alternativeProps[property], alternativeValues[value] || value);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = flexboxIE;
        var alternativeValues = {
            "space-around": "distribute",
            "space-between": "justify",
            "flex-start": "start",
            "flex-end": "end"
        }, alternativeProps = {
            alignContent: "msFlexLinePack",
            alignSelf: "msFlexItemAlign",
            alignItems: "msFlexAlign",
            justifyContent: "msFlexPack",
            order: "msFlexOrder",
            flexGrow: "msFlexPositive",
            flexShrink: "msFlexNegative",
            flexBasis: "msPreferredSize"
        };
        module.exports = exports.default;
    }, /* 186 */
    /***/
    function(module, exports) {
        "use strict";
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function flexboxOld(property, value) {
            return "flexDirection" === property && "string" == typeof value ? {
                WebkitBoxOrient: value.indexOf("column") > -1 ? "vertical" : "horizontal",
                WebkitBoxDirection: value.indexOf("reverse") > -1 ? "reverse" : "normal"
            } : alternativeProps[property] ? _defineProperty({}, alternativeProps[property], alternativeValues[value] || value) : void 0;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = flexboxOld;
        var alternativeValues = {
            "space-around": "justify",
            "space-between": "justify",
            "flex-start": "start",
            "flex-end": "end",
            "wrap-reverse": "multiple",
            wrap: "multiple"
        }, alternativeProps = {
            alignItems: "WebkitBoxAlign",
            justifyContent: "WebkitBoxPack",
            flexWrap: "WebkitBoxLines"
        };
        module.exports = exports.default;
    }, /* 187 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _ThemeProvider = __webpack_require__(158);
        /* globals ReactClass */
        exports.default = function(Component) {
            var _class, _temp2;
            return _temp2 = _class = function(_React$Component) {
                function _class() {
                    var _ref, _temp, _this, _ret;
                    _classCallCheck(this, _class);
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    return _temp = _this = _possibleConstructorReturn(this, (_ref = _class.__proto__ || Object.getPrototypeOf(_class)).call.apply(_ref, [ this ].concat(args))), 
                    _this.state = {}, _ret = _temp, _possibleConstructorReturn(_this, _ret);
                }
                return _inherits(_class, _React$Component), _createClass(_class, [ {
                    key: "componentWillMount",
                    value: function() {
                        var _this2 = this;
                        if (!this.context[_ThemeProvider.CHANNEL]) throw new Error("[withTheme] Please use ThemeProvider to be able to use withTheme");
                        var subscribe = this.context[_ThemeProvider.CHANNEL];
                        this.unsubscribe = subscribe(function(theme) {
                            _this2.setState({
                                theme: theme
                            });
                        });
                    }
                }, {
                    key: "componentWillUnmount",
                    value: function() {
                        "function" == typeof this.unsubscribe && this.unsubscribe();
                    }
                }, {
                    key: "render",
                    value: function() {
                        var theme = this.state.theme;
                        return _react2.default.createElement(Component, _extends({
                            theme: theme
                        }, this.props));
                    }
                } ]), _class;
            }(_react2.default.Component), _class.contextTypes = _defineProperty({}, _ThemeProvider.CHANNEL, _react2.default.PropTypes.func), 
            _temp2;
        }, module.exports = exports.default;
    }, /* 188 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: http://codemirror.net/LICENSE
        !function(mod) {
            // CommonJS
            mod(__webpack_require__(113), __webpack_require__(189), __webpack_require__(190));
        }(function(CodeMirror) {
            "use strict";
            // Depth means the amount of open braces in JS context, in XML
            // context 0 means not in tag, 1 means in tag, and 2 means in tag
            // and js block comment.
            function Context(state, mode, depth, prev) {
                this.state = state, this.mode = mode, this.depth = depth, this.prev = prev;
            }
            function copyContext(context) {
                return new Context(CodeMirror.copyState(context.mode, context.state), context.mode, context.depth, context.prev && copyContext(context.prev));
            }
            CodeMirror.defineMode("jsx", function(config, modeConfig) {
                function flatXMLIndent(state) {
                    var tagName = state.tagName;
                    state.tagName = null;
                    var result = xmlMode.indent(state, "");
                    return state.tagName = tagName, result;
                }
                function token(stream, state) {
                    return state.context.mode == xmlMode ? xmlToken(stream, state, state.context) : jsToken(stream, state, state.context);
                }
                function xmlToken(stream, state, cx) {
                    if (2 == cx.depth) // Inside a JS /* */ comment
                    return stream.match(/^.*?\*\//) ? cx.depth = 1 : stream.skipToEnd(), "comment";
                    if ("{" == stream.peek()) {
                        xmlMode.skipAttribute(cx.state);
                        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context;
                        // If JS starts on same line as tag
                        if (xmlContext && stream.match(/^[^>]*>\s*$/, !1)) {
                            for (;xmlContext.prev && !xmlContext.startOfLine; ) xmlContext = xmlContext.prev;
                            // If tag starts the line, use XML indentation level
                            xmlContext.startOfLine ? indent -= config.indentUnit : cx.prev.state.lexical && (indent = cx.prev.state.lexical.indented);
                        } else 1 == cx.depth && (indent += config.indentUnit);
                        return state.context = new Context(CodeMirror.startState(jsMode, indent), jsMode, 0, state.context), 
                        null;
                    }
                    if (1 == cx.depth) {
                        // Inside of tag
                        if ("<" == stream.peek()) // Tag inside of tag
                        return xmlMode.skipAttribute(cx.state), state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)), xmlMode, 0, state.context), 
                        null;
                        if (stream.match("//")) return stream.skipToEnd(), "comment";
                        if (stream.match("/*")) return cx.depth = 2, token(stream, state);
                    }
                    var stop, style = xmlMode.token(stream, cx.state), cur = stream.current();
                    return /\btag\b/.test(style) ? />$/.test(cur) ? cx.state.context ? cx.depth = 0 : state.context = state.context.prev : /^</.test(cur) && (cx.depth = 1) : !style && (stop = cur.indexOf("{")) > -1 && stream.backUp(cur.length - stop), 
                    style;
                }
                function jsToken(stream, state, cx) {
                    if ("<" == stream.peek() && jsMode.expressionAllowed(stream, cx.state)) return jsMode.skipExpression(cx.state), 
                    state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "")), xmlMode, 0, state.context), 
                    null;
                    var style = jsMode.token(stream, cx.state);
                    if (!style && null != cx.depth) {
                        var cur = stream.current();
                        "{" == cur ? cx.depth++ : "}" == cur && 0 == --cx.depth && (state.context = state.context.prev);
                    }
                    return style;
                }
                var xmlMode = CodeMirror.getMode(config, {
                    name: "xml",
                    allowMissing: !0,
                    multilineTagIndentPastTag: !1
                }), jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript");
                return {
                    startState: function() {
                        return {
                            context: new Context(CodeMirror.startState(jsMode), jsMode)
                        };
                    },
                    copyState: function(state) {
                        return {
                            context: copyContext(state.context)
                        };
                    },
                    token: token,
                    indent: function(state, textAfter, fullLine) {
                        return state.context.mode.indent(state.context.state, textAfter, fullLine);
                    },
                    innerMode: function(state) {
                        return state.context;
                    }
                };
            }, "xml", "javascript"), CodeMirror.defineMIME("text/jsx", "jsx"), CodeMirror.defineMIME("text/typescript-jsx", {
                name: "jsx",
                base: {
                    name: "javascript",
                    typescript: !0
                }
            });
        });
    }, /* 189 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: http://codemirror.net/LICENSE
        !function(mod) {
            // CommonJS
            mod(__webpack_require__(113));
        }(function(CodeMirror) {
            "use strict";
            var htmlConfig = {
                autoSelfClosers: {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    command: !0,
                    embed: !0,
                    frame: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0,
                    menuitem: !0
                },
                implicitlyClosed: {
                    dd: !0,
                    li: !0,
                    optgroup: !0,
                    option: !0,
                    p: !0,
                    rp: !0,
                    rt: !0,
                    tbody: !0,
                    td: !0,
                    tfoot: !0,
                    th: !0,
                    tr: !0
                },
                contextGrabbers: {
                    dd: {
                        dd: !0,
                        dt: !0
                    },
                    dt: {
                        dd: !0,
                        dt: !0
                    },
                    li: {
                        li: !0
                    },
                    option: {
                        option: !0,
                        optgroup: !0
                    },
                    optgroup: {
                        optgroup: !0
                    },
                    p: {
                        address: !0,
                        article: !0,
                        aside: !0,
                        blockquote: !0,
                        dir: !0,
                        div: !0,
                        dl: !0,
                        fieldset: !0,
                        footer: !0,
                        form: !0,
                        h1: !0,
                        h2: !0,
                        h3: !0,
                        h4: !0,
                        h5: !0,
                        h6: !0,
                        header: !0,
                        hgroup: !0,
                        hr: !0,
                        menu: !0,
                        nav: !0,
                        ol: !0,
                        p: !0,
                        pre: !0,
                        section: !0,
                        table: !0,
                        ul: !0
                    },
                    rp: {
                        rp: !0,
                        rt: !0
                    },
                    rt: {
                        rp: !0,
                        rt: !0
                    },
                    tbody: {
                        tbody: !0,
                        tfoot: !0
                    },
                    td: {
                        td: !0,
                        th: !0
                    },
                    tfoot: {
                        tbody: !0
                    },
                    th: {
                        td: !0,
                        th: !0
                    },
                    thead: {
                        tbody: !0,
                        tfoot: !0
                    },
                    tr: {
                        tr: !0
                    }
                },
                doNotIndent: {
                    pre: !0
                },
                allowUnquoted: !0,
                allowMissing: !0,
                caseFold: !0
            }, xmlConfig = {
                autoSelfClosers: {},
                implicitlyClosed: {},
                contextGrabbers: {},
                doNotIndent: {},
                allowUnquoted: !1,
                allowMissing: !1,
                caseFold: !1
            };
            CodeMirror.defineMode("xml", function(editorConf, config_) {
                function inText(stream, state) {
                    function chain(parser) {
                        return state.tokenize = parser, parser(stream, state);
                    }
                    var ch = stream.next();
                    if ("<" == ch) return stream.eat("!") ? stream.eat("[") ? stream.match("CDATA[") ? chain(inBlock("atom", "]]>")) : null : stream.match("--") ? chain(inBlock("comment", "-->")) : stream.match("DOCTYPE", !0, !0) ? (stream.eatWhile(/[\w\._\-]/), 
                    chain(doctype(1))) : null : stream.eat("?") ? (stream.eatWhile(/[\w\._\-]/), state.tokenize = inBlock("meta", "?>"), 
                    "meta") : (type = stream.eat("/") ? "closeTag" : "openTag", state.tokenize = inTag, 
                    "tag bracket");
                    if ("&" == ch) {
                        var ok;
                        return ok = stream.eat("#") ? stream.eat("x") ? stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";") : stream.eatWhile(/[\d]/) && stream.eat(";") : stream.eatWhile(/[\w\.\-:]/) && stream.eat(";"), 
                        ok ? "atom" : "error";
                    }
                    return stream.eatWhile(/[^&<]/), null;
                }
                function inTag(stream, state) {
                    var ch = stream.next();
                    if (">" == ch || "/" == ch && stream.eat(">")) return state.tokenize = inText, type = ">" == ch ? "endTag" : "selfcloseTag", 
                    "tag bracket";
                    if ("=" == ch) return type = "equals", null;
                    if ("<" == ch) {
                        state.tokenize = inText, state.state = baseState, state.tagName = state.tagStart = null;
                        var next = state.tokenize(stream, state);
                        return next ? next + " tag error" : "tag error";
                    }
                    return /[\'\"]/.test(ch) ? (state.tokenize = inAttribute(ch), state.stringStartCol = stream.column(), 
                    state.tokenize(stream, state)) : (stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), 
                    "word");
                }
                function inAttribute(quote) {
                    var closure = function(stream, state) {
                        for (;!stream.eol(); ) if (stream.next() == quote) {
                            state.tokenize = inTag;
                            break;
                        }
                        return "string";
                    };
                    return closure.isInAttribute = !0, closure;
                }
                function inBlock(style, terminator) {
                    return function(stream, state) {
                        for (;!stream.eol(); ) {
                            if (stream.match(terminator)) {
                                state.tokenize = inText;
                                break;
                            }
                            stream.next();
                        }
                        return style;
                    };
                }
                function doctype(depth) {
                    return function(stream, state) {
                        for (var ch; null != (ch = stream.next()); ) {
                            if ("<" == ch) return state.tokenize = doctype(depth + 1), state.tokenize(stream, state);
                            if (">" == ch) {
                                if (1 == depth) {
                                    state.tokenize = inText;
                                    break;
                                }
                                return state.tokenize = doctype(depth - 1), state.tokenize(stream, state);
                            }
                        }
                        return "meta";
                    };
                }
                function Context(state, tagName, startOfLine) {
                    this.prev = state.context, this.tagName = tagName, this.indent = state.indented, 
                    this.startOfLine = startOfLine, (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) && (this.noIndent = !0);
                }
                function popContext(state) {
                    state.context && (state.context = state.context.prev);
                }
                function maybePopContext(state, nextTagName) {
                    for (var parentTagName; ;) {
                        if (!state.context) return;
                        if (parentTagName = state.context.tagName, !config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) return;
                        popContext(state);
                    }
                }
                function baseState(type, stream, state) {
                    return "openTag" == type ? (state.tagStart = stream.column(), tagNameState) : "closeTag" == type ? closeTagNameState : baseState;
                }
                function tagNameState(type, stream, state) {
                    return "word" == type ? (state.tagName = stream.current(), setStyle = "tag", attrState) : (setStyle = "error", 
                    tagNameState);
                }
                function closeTagNameState(type, stream, state) {
                    if ("word" == type) {
                        var tagName = stream.current();
                        return state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName) && popContext(state), 
                        state.context && state.context.tagName == tagName || config.matchClosing === !1 ? (setStyle = "tag", 
                        closeState) : (setStyle = "tag error", closeStateErr);
                    }
                    return setStyle = "error", closeStateErr;
                }
                function closeState(type, _stream, state) {
                    return "endTag" != type ? (setStyle = "error", closeState) : (popContext(state), 
                    baseState);
                }
                function closeStateErr(type, stream, state) {
                    return setStyle = "error", closeState(type, stream, state);
                }
                function attrState(type, _stream, state) {
                    if ("word" == type) return setStyle = "attribute", attrEqState;
                    if ("endTag" == type || "selfcloseTag" == type) {
                        var tagName = state.tagName, tagStart = state.tagStart;
                        return state.tagName = state.tagStart = null, "selfcloseTag" == type || config.autoSelfClosers.hasOwnProperty(tagName) ? maybePopContext(state, tagName) : (maybePopContext(state, tagName), 
                        state.context = new Context(state, tagName, tagStart == state.indented)), baseState;
                    }
                    return setStyle = "error", attrState;
                }
                function attrEqState(type, stream, state) {
                    return "equals" == type ? attrValueState : (config.allowMissing || (setStyle = "error"), 
                    attrState(type, stream, state));
                }
                function attrValueState(type, stream, state) {
                    return "string" == type ? attrContinuedState : "word" == type && config.allowUnquoted ? (setStyle = "string", 
                    attrState) : (setStyle = "error", attrState(type, stream, state));
                }
                function attrContinuedState(type, stream, state) {
                    return "string" == type ? attrContinuedState : attrState(type, stream, state);
                }
                var indentUnit = editorConf.indentUnit, config = {}, defaults = config_.htmlMode ? htmlConfig : xmlConfig;
                for (var prop in defaults) config[prop] = defaults[prop];
                for (var prop in config_) config[prop] = config_[prop];
                // Return variables for tokenizers
                var type, setStyle;
                return inText.isInText = !0, {
                    startState: function(baseIndent) {
                        var state = {
                            tokenize: inText,
                            state: baseState,
                            indented: baseIndent || 0,
                            tagName: null,
                            tagStart: null,
                            context: null
                        };
                        return null != baseIndent && (state.baseIndent = baseIndent), state;
                    },
                    token: function(stream, state) {
                        if (!state.tagName && stream.sol() && (state.indented = stream.indentation()), stream.eatSpace()) return null;
                        type = null;
                        var style = state.tokenize(stream, state);
                        return (style || type) && "comment" != style && (setStyle = null, state.state = state.state(type || style, stream, state), 
                        setStyle && (style = "error" == setStyle ? style + " error" : setStyle)), style;
                    },
                    indent: function(state, textAfter, fullLine) {
                        var context = state.context;
                        // Indent multi-line strings (e.g. css).
                        if (state.tokenize.isInAttribute) return state.tagStart == state.indented ? state.stringStartCol + 1 : state.indented + indentUnit;
                        if (context && context.noIndent) return CodeMirror.Pass;
                        if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
                        // Indent the starts of attribute names.
                        if (state.tagName) return config.multilineTagIndentPastTag !== !1 ? state.tagStart + state.tagName.length + 2 : state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
                        if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
                        var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
                        if (tagAfter && tagAfter[1]) // Closing tag spotted
                        for (;context; ) {
                            if (context.tagName == tagAfter[2]) {
                                context = context.prev;
                                break;
                            }
                            if (!config.implicitlyClosed.hasOwnProperty(context.tagName)) break;
                            context = context.prev;
                        } else if (tagAfter) // Opening tag spotted
                        for (;context; ) {
                            var grabbers = config.contextGrabbers[context.tagName];
                            if (!grabbers || !grabbers.hasOwnProperty(tagAfter[2])) break;
                            context = context.prev;
                        }
                        for (;context && context.prev && !context.startOfLine; ) context = context.prev;
                        return context ? context.indent + indentUnit : state.baseIndent || 0;
                    },
                    electricInput: /<\/[\s\w:]+>$/,
                    blockCommentStart: "<!--",
                    blockCommentEnd: "-->",
                    configuration: config.htmlMode ? "html" : "xml",
                    helperType: config.htmlMode ? "html" : "xml",
                    skipAttribute: function(state) {
                        state.state == attrValueState && (state.state = attrState);
                    }
                };
            }), CodeMirror.defineMIME("text/xml", "xml"), CodeMirror.defineMIME("application/xml", "xml"), 
            CodeMirror.mimeModes.hasOwnProperty("text/html") || CodeMirror.defineMIME("text/html", {
                name: "xml",
                htmlMode: !0
            });
        });
    }, /* 190 */
    /***/
    function(module, exports, __webpack_require__) {
        // CodeMirror, copyright (c) by Marijn Haverbeke and others
        // Distributed under an MIT license: http://codemirror.net/LICENSE
        !function(mod) {
            // CommonJS
            mod(__webpack_require__(113));
        }(function(CodeMirror) {
            "use strict";
            function expressionAllowed(stream, state, backUp) {
                return /^(?:operator|sof|keyword c|case|new|export|default|[\[{}\(,;:]|=>)$/.test(state.lastType) || "quasi" == state.lastType && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
            }
            CodeMirror.defineMode("javascript", function(config, parserConfig) {
                function readRegexp(stream) {
                    for (var next, escaped = !1, inSet = !1; null != (next = stream.next()); ) {
                        if (!escaped) {
                            if ("/" == next && !inSet) return;
                            "[" == next ? inSet = !0 : inSet && "]" == next && (inSet = !1);
                        }
                        escaped = !escaped && "\\" == next;
                    }
                }
                function ret(tp, style, cont) {
                    return type = tp, content = cont, style;
                }
                function tokenBase(stream, state) {
                    var ch = stream.next();
                    if ('"' == ch || "'" == ch) return state.tokenize = tokenString(ch), state.tokenize(stream, state);
                    if ("." == ch && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) return ret("number", "number");
                    if ("." == ch && stream.match("..")) return ret("spread", "meta");
                    if (/[\[\]{}\(\),;\:\.]/.test(ch)) return ret(ch);
                    if ("=" == ch && stream.eat(">")) return ret("=>", "operator");
                    if ("0" == ch && stream.eat(/x/i)) return stream.eatWhile(/[\da-f]/i), ret("number", "number");
                    if ("0" == ch && stream.eat(/o/i)) return stream.eatWhile(/[0-7]/i), ret("number", "number");
                    if ("0" == ch && stream.eat(/b/i)) return stream.eatWhile(/[01]/i), ret("number", "number");
                    if (/\d/.test(ch)) return stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/), ret("number", "number");
                    if ("/" == ch) return stream.eat("*") ? (state.tokenize = tokenComment, tokenComment(stream, state)) : stream.eat("/") ? (stream.skipToEnd(), 
                    ret("comment", "comment")) : expressionAllowed(stream, state, 1) ? (readRegexp(stream), 
                    stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/), ret("regexp", "string-2")) : (stream.eatWhile(isOperatorChar), 
                    ret("operator", "operator", stream.current()));
                    if ("`" == ch) return state.tokenize = tokenQuasi, tokenQuasi(stream, state);
                    if ("#" == ch) return stream.skipToEnd(), ret("error", "error");
                    if (isOperatorChar.test(ch)) return ">" == ch && state.lexical && ">" == state.lexical.type || stream.eatWhile(isOperatorChar), 
                    ret("operator", "operator", stream.current());
                    if (wordRE.test(ch)) {
                        stream.eatWhile(wordRE);
                        var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
                        return known && "." != state.lastType ? ret(known.type, known.style, word) : ret("variable", "variable", word);
                    }
                }
                function tokenString(quote) {
                    return function(stream, state) {
                        var next, escaped = !1;
                        if (jsonldMode && "@" == stream.peek() && stream.match(isJsonldKeyword)) return state.tokenize = tokenBase, 
                        ret("jsonld-keyword", "meta");
                        for (;null != (next = stream.next()) && (next != quote || escaped); ) escaped = !escaped && "\\" == next;
                        return escaped || (state.tokenize = tokenBase), ret("string", "string");
                    };
                }
                function tokenComment(stream, state) {
                    for (var ch, maybeEnd = !1; ch = stream.next(); ) {
                        if ("/" == ch && maybeEnd) {
                            state.tokenize = tokenBase;
                            break;
                        }
                        maybeEnd = "*" == ch;
                    }
                    return ret("comment", "comment");
                }
                function tokenQuasi(stream, state) {
                    for (var next, escaped = !1; null != (next = stream.next()); ) {
                        if (!escaped && ("`" == next || "$" == next && stream.eat("{"))) {
                            state.tokenize = tokenBase;
                            break;
                        }
                        escaped = !escaped && "\\" == next;
                    }
                    return ret("quasi", "string-2", stream.current());
                }
                // This is a crude lookahead trick to try and notice that we're
                // parsing the argument patterns for a fat-arrow function before we
                // actually hit the arrow token. It only works if the arrow is on
                // the same line as the arguments and there's no strange noise
                // (comments) in between. Fallback is to only notice when we hit the
                // arrow, and not declare the arguments as locals for the arrow
                // body.
                function findFatArrow(stream, state) {
                    state.fatArrowAt && (state.fatArrowAt = null);
                    var arrow = stream.string.indexOf("=>", stream.start);
                    if (!(arrow < 0)) {
                        if (isTS) {
                            // Try to skip TypeScript return type declarations after the arguments
                            var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
                            m && (arrow = m.index);
                        }
                        for (var depth = 0, sawSomething = !1, pos = arrow - 1; pos >= 0; --pos) {
                            var ch = stream.string.charAt(pos), bracket = brackets.indexOf(ch);
                            if (bracket >= 0 && bracket < 3) {
                                if (!depth) {
                                    ++pos;
                                    break;
                                }
                                if (0 == --depth) {
                                    "(" == ch && (sawSomething = !0);
                                    break;
                                }
                            } else if (bracket >= 3 && bracket < 6) ++depth; else if (wordRE.test(ch)) sawSomething = !0; else {
                                if (/["'\/]/.test(ch)) return;
                                if (sawSomething && !depth) {
                                    ++pos;
                                    break;
                                }
                            }
                        }
                        sawSomething && !depth && (state.fatArrowAt = pos);
                    }
                }
                function JSLexical(indented, column, type, align, prev, info) {
                    this.indented = indented, this.column = column, this.type = type, this.prev = prev, 
                    this.info = info, null != align && (this.align = align);
                }
                function inScope(state, varname) {
                    for (var v = state.localVars; v; v = v.next) if (v.name == varname) return !0;
                    for (var cx = state.context; cx; cx = cx.prev) for (var v = cx.vars; v; v = v.next) if (v.name == varname) return !0;
                }
                function parseJS(state, style, type, content, stream) {
                    var cc = state.cc;
                    for (// Communicate our context to the combinators.
                    // (Less wasteful than consing up a hundred closures on every call.)
                    cx.state = state, cx.stream = stream, cx.marked = null, cx.cc = cc, cx.style = style, 
                    state.lexical.hasOwnProperty("align") || (state.lexical.align = !0); ;) {
                        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
                        if (combinator(type, content)) {
                            for (;cc.length && cc[cc.length - 1].lex; ) cc.pop()();
                            return cx.marked ? cx.marked : "variable" == type && inScope(state, content) ? "variable-2" : style;
                        }
                    }
                }
                function pass() {
                    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
                }
                function cont() {
                    return pass.apply(null, arguments), !0;
                }
                function register(varname) {
                    function inList(list) {
                        for (var v = list; v; v = v.next) if (v.name == varname) return !0;
                        return !1;
                    }
                    var state = cx.state;
                    if (cx.marked = "def", state.context) {
                        if (inList(state.localVars)) return;
                        state.localVars = {
                            name: varname,
                            next: state.localVars
                        };
                    } else {
                        if (inList(state.globalVars)) return;
                        parserConfig.globalVars && (state.globalVars = {
                            name: varname,
                            next: state.globalVars
                        });
                    }
                }
                function pushcontext() {
                    cx.state.context = {
                        prev: cx.state.context,
                        vars: cx.state.localVars
                    }, cx.state.localVars = defaultVars;
                }
                function popcontext() {
                    cx.state.localVars = cx.state.context.vars, cx.state.context = cx.state.context.prev;
                }
                function pushlex(type, info) {
                    var result = function() {
                        var state = cx.state, indent = state.indented;
                        if ("stat" == state.lexical.type) indent = state.lexical.indented; else for (var outer = state.lexical; outer && ")" == outer.type && outer.align; outer = outer.prev) indent = outer.indented;
                        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
                    };
                    return result.lex = !0, result;
                }
                function poplex() {
                    var state = cx.state;
                    state.lexical.prev && (")" == state.lexical.type && (state.indented = state.lexical.indented), 
                    state.lexical = state.lexical.prev);
                }
                function expect(wanted) {
                    function exp(type) {
                        return type == wanted ? cont() : ";" == wanted ? pass() : cont(exp);
                    }
                    return exp;
                }
                function statement(type, value) {
                    return "var" == type ? cont(pushlex("vardef", value.length), vardef, expect(";"), poplex) : "keyword a" == type ? cont(pushlex("form"), parenExpr, statement, poplex) : "keyword b" == type ? cont(pushlex("form"), statement, poplex) : "{" == type ? cont(pushlex("}"), block, poplex) : ";" == type ? cont() : "if" == type ? ("else" == cx.state.lexical.info && cx.state.cc[cx.state.cc.length - 1] == poplex && cx.state.cc.pop()(), 
                    cont(pushlex("form"), parenExpr, statement, poplex, maybeelse)) : "function" == type ? cont(functiondef) : "for" == type ? cont(pushlex("form"), forspec, statement, poplex) : "variable" == type ? cont(pushlex("stat"), maybelabel) : "switch" == type ? cont(pushlex("form"), parenExpr, pushlex("}", "switch"), expect("{"), block, poplex, poplex) : "case" == type ? cont(expression, expect(":")) : "default" == type ? cont(expect(":")) : "catch" == type ? cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext) : "class" == type ? cont(pushlex("form"), className, poplex) : "export" == type ? cont(pushlex("stat"), afterExport, poplex) : "import" == type ? cont(pushlex("stat"), afterImport, poplex) : "module" == type ? cont(pushlex("form"), pattern, pushlex("}"), expect("{"), block, poplex, poplex) : "type" == type ? cont(typeexpr, expect("operator"), typeexpr, expect(";")) : "async" == type ? cont(statement) : pass(pushlex("stat"), expression, expect(";"), poplex);
                }
                function expression(type) {
                    return expressionInner(type, !1);
                }
                function expressionNoComma(type) {
                    return expressionInner(type, !0);
                }
                function parenExpr(type) {
                    return "(" != type ? pass() : cont(pushlex(")"), expression, expect(")"), poplex);
                }
                function expressionInner(type, noComma) {
                    if (cx.state.fatArrowAt == cx.stream.start) {
                        var body = noComma ? arrowBodyNoComma : arrowBody;
                        if ("(" == type) return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
                        if ("variable" == type) return pass(pushcontext, pattern, expect("=>"), body, popcontext);
                    }
                    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
                    return atomicTypes.hasOwnProperty(type) ? cont(maybeop) : "function" == type ? cont(functiondef, maybeop) : "class" == type ? cont(pushlex("form"), classExpression, poplex) : "keyword c" == type || "async" == type ? cont(noComma ? maybeexpressionNoComma : maybeexpression) : "(" == type ? cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop) : "operator" == type || "spread" == type ? cont(noComma ? expressionNoComma : expression) : "[" == type ? cont(pushlex("]"), arrayLiteral, poplex, maybeop) : "{" == type ? contCommasep(objprop, "}", null, maybeop) : "quasi" == type ? pass(quasi, maybeop) : "new" == type ? cont(maybeTarget(noComma)) : cont();
                }
                function maybeexpression(type) {
                    return type.match(/[;\}\)\],]/) ? pass() : pass(expression);
                }
                function maybeexpressionNoComma(type) {
                    return type.match(/[;\}\)\],]/) ? pass() : pass(expressionNoComma);
                }
                function maybeoperatorComma(type, value) {
                    return "," == type ? cont(expression) : maybeoperatorNoComma(type, value, !1);
                }
                function maybeoperatorNoComma(type, value, noComma) {
                    var me = 0 == noComma ? maybeoperatorComma : maybeoperatorNoComma, expr = 0 == noComma ? expression : expressionNoComma;
                    return "=>" == type ? cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext) : "operator" == type ? /\+\+|--/.test(value) ? cont(me) : "?" == value ? cont(expression, expect(":"), expr) : cont(expr) : "quasi" == type ? pass(quasi, me) : ";" != type ? "(" == type ? contCommasep(expressionNoComma, ")", "call", me) : "." == type ? cont(property, me) : "[" == type ? cont(pushlex("]"), maybeexpression, expect("]"), poplex, me) : void 0 : void 0;
                }
                function quasi(type, value) {
                    return "quasi" != type ? pass() : "${" != value.slice(value.length - 2) ? cont(quasi) : cont(expression, continueQuasi);
                }
                function continueQuasi(type) {
                    if ("}" == type) return cx.marked = "string-2", cx.state.tokenize = tokenQuasi, 
                    cont(quasi);
                }
                function arrowBody(type) {
                    return findFatArrow(cx.stream, cx.state), pass("{" == type ? statement : expression);
                }
                function arrowBodyNoComma(type) {
                    return findFatArrow(cx.stream, cx.state), pass("{" == type ? statement : expressionNoComma);
                }
                function maybeTarget(noComma) {
                    return function(type) {
                        return "." == type ? cont(noComma ? targetNoComma : target) : pass(noComma ? expressionNoComma : expression);
                    };
                }
                function target(_, value) {
                    if ("target" == value) return cx.marked = "keyword", cont(maybeoperatorComma);
                }
                function targetNoComma(_, value) {
                    if ("target" == value) return cx.marked = "keyword", cont(maybeoperatorNoComma);
                }
                function maybelabel(type) {
                    return ":" == type ? cont(poplex, statement) : pass(maybeoperatorComma, expect(";"), poplex);
                }
                function property(type) {
                    if ("variable" == type) return cx.marked = "property", cont();
                }
                function objprop(type, value) {
                    return "async" == type ? (cx.marked = "property", cont(objprop)) : "variable" == type || "keyword" == cx.style ? (cx.marked = "property", 
                    cont("get" == value || "set" == value ? getterSetter : afterprop)) : "number" == type || "string" == type ? (cx.marked = jsonldMode ? "property" : cx.style + " property", 
                    cont(afterprop)) : "jsonld-keyword" == type ? cont(afterprop) : "modifier" == type ? cont(objprop) : "[" == type ? cont(expression, expect("]"), afterprop) : "spread" == type ? cont(expression) : ":" == type ? pass(afterprop) : void 0;
                }
                function getterSetter(type) {
                    return "variable" != type ? pass(afterprop) : (cx.marked = "property", cont(functiondef));
                }
                function afterprop(type) {
                    return ":" == type ? cont(expressionNoComma) : "(" == type ? pass(functiondef) : void 0;
                }
                function commasep(what, end, sep) {
                    function proceed(type, value) {
                        if (sep ? sep.indexOf(type) > -1 : "," == type) {
                            var lex = cx.state.lexical;
                            return "call" == lex.info && (lex.pos = (lex.pos || 0) + 1), cont(function(type, value) {
                                return type == end || value == end ? pass() : pass(what);
                            }, proceed);
                        }
                        return type == end || value == end ? cont() : cont(expect(end));
                    }
                    return function(type, value) {
                        return type == end || value == end ? cont() : pass(what, proceed);
                    };
                }
                function contCommasep(what, end, info) {
                    for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);
                    return cont(pushlex(end, info), commasep(what, end), poplex);
                }
                function block(type) {
                    return "}" == type ? cont() : pass(statement, block);
                }
                function maybetype(type, value) {
                    if (isTS) {
                        if (":" == type) return cont(typeexpr);
                        if ("?" == value) return cont(maybetype);
                    }
                }
                function typeexpr(type) {
                    return "variable" == type ? (cx.marked = "variable-3", cont(afterType)) : "string" == type || "number" == type || "atom" == type ? cont(afterType) : "{" == type ? cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex) : "(" == type ? cont(commasep(typearg, ")"), maybeReturnType) : void 0;
                }
                function maybeReturnType(type) {
                    if ("=>" == type) return cont(typeexpr);
                }
                function typeprop(type, value) {
                    return "variable" == type || "keyword" == cx.style ? (cx.marked = "property", cont(typeprop)) : "?" == value ? cont(typeprop) : ":" == type ? cont(typeexpr) : void 0;
                }
                function typearg(type) {
                    return "variable" == type ? cont(typearg) : ":" == type ? cont(typeexpr) : void 0;
                }
                function afterType(type, value) {
                    return "<" == value ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType) : "|" == value || "." == type ? cont(typeexpr) : "[" == type ? cont(expect("]"), afterType) : void 0;
                }
                function vardef() {
                    return pass(pattern, maybetype, maybeAssign, vardefCont);
                }
                function pattern(type, value) {
                    return "modifier" == type ? cont(pattern) : "variable" == type ? (register(value), 
                    cont()) : "spread" == type ? cont(pattern) : "[" == type ? contCommasep(pattern, "]") : "{" == type ? contCommasep(proppattern, "}") : void 0;
                }
                function proppattern(type, value) {
                    return "variable" != type || cx.stream.match(/^\s*:/, !1) ? ("variable" == type && (cx.marked = "property"), 
                    "spread" == type ? cont(pattern) : "}" == type ? pass() : cont(expect(":"), pattern, maybeAssign)) : (register(value), 
                    cont(maybeAssign));
                }
                function maybeAssign(_type, value) {
                    if ("=" == value) return cont(expressionNoComma);
                }
                function vardefCont(type) {
                    if ("," == type) return cont(vardef);
                }
                function maybeelse(type, value) {
                    if ("keyword b" == type && "else" == value) return cont(pushlex("form", "else"), statement, poplex);
                }
                function forspec(type) {
                    if ("(" == type) return cont(pushlex(")"), forspec1, expect(")"), poplex);
                }
                function forspec1(type) {
                    return "var" == type ? cont(vardef, expect(";"), forspec2) : ";" == type ? cont(forspec2) : "variable" == type ? cont(formaybeinof) : pass(expression, expect(";"), forspec2);
                }
                function formaybeinof(_type, value) {
                    return "in" == value || "of" == value ? (cx.marked = "keyword", cont(expression)) : cont(maybeoperatorComma, forspec2);
                }
                function forspec2(type, value) {
                    return ";" == type ? cont(forspec3) : "in" == value || "of" == value ? (cx.marked = "keyword", 
                    cont(expression)) : pass(expression, expect(";"), forspec3);
                }
                function forspec3(type) {
                    ")" != type && cont(expression);
                }
                function functiondef(type, value) {
                    return "*" == value ? (cx.marked = "keyword", cont(functiondef)) : "variable" == type ? (register(value), 
                    cont(functiondef)) : "(" == type ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, maybetype, statement, popcontext) : void 0;
                }
                function funarg(type) {
                    return "spread" == type ? cont(funarg) : pass(pattern, maybetype, maybeAssign);
                }
                function classExpression(type, value) {
                    // Class expressions may have an optional name.
                    // Class expressions may have an optional name.
                    return "variable" == type ? className(type, value) : classNameAfter(type, value);
                }
                function className(type, value) {
                    if ("variable" == type) return register(value), cont(classNameAfter);
                }
                function classNameAfter(type, value) {
                    return "extends" == value || "implements" == value || isTS && "," == type ? cont(isTS ? typeexpr : expression, classNameAfter) : "{" == type ? cont(pushlex("}"), classBody, poplex) : void 0;
                }
                function classBody(type, value) {
                    return "variable" == type || "keyword" == cx.style ? ("async" == value || "static" == value || "get" == value || "set" == value || isTS && ("public" == value || "private" == value || "protected" == value || "readonly" == value || "abstract" == value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (cx.marked = "keyword", 
                    cont(classBody)) : (cx.marked = "property", cont(isTS ? classfield : functiondef, classBody)) : "[" == type ? cont(expression, expect("]"), isTS ? classfield : functiondef, classBody) : "*" == value ? (cx.marked = "keyword", 
                    cont(classBody)) : ";" == type ? cont(classBody) : "}" == type ? cont() : void 0;
                }
                function classfield(type, value) {
                    return "?" == value ? cont(classfield) : ":" == type ? cont(typeexpr, maybeAssign) : pass(functiondef);
                }
                function afterExport(type, value) {
                    return "*" == value ? (cx.marked = "keyword", cont(maybeFrom, expect(";"))) : "default" == value ? (cx.marked = "keyword", 
                    cont(expression, expect(";"))) : "{" == type ? cont(commasep(exportField, "}"), maybeFrom, expect(";")) : pass(statement);
                }
                function exportField(type, value) {
                    return "as" == value ? (cx.marked = "keyword", cont(expect("variable"))) : "variable" == type ? pass(expressionNoComma, exportField) : void 0;
                }
                function afterImport(type) {
                    return "string" == type ? cont() : pass(importSpec, maybeMoreImports, maybeFrom);
                }
                function importSpec(type, value) {
                    return "{" == type ? contCommasep(importSpec, "}") : ("variable" == type && register(value), 
                    "*" == value && (cx.marked = "keyword"), cont(maybeAs));
                }
                function maybeMoreImports(type) {
                    if ("," == type) return cont(importSpec, maybeMoreImports);
                }
                function maybeAs(_type, value) {
                    if ("as" == value) return cx.marked = "keyword", cont(importSpec);
                }
                function maybeFrom(_type, value) {
                    if ("from" == value) return cx.marked = "keyword", cont(expression);
                }
                function arrayLiteral(type) {
                    return "]" == type ? cont() : pass(commasep(expressionNoComma, "]"));
                }
                function isContinuedStatement(state, textAfter) {
                    return "operator" == state.lastType || "," == state.lastType || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
                }
                var type, content, indentUnit = config.indentUnit, statementIndent = parserConfig.statementIndent, jsonldMode = parserConfig.jsonld, jsonMode = parserConfig.json || jsonldMode, isTS = parserConfig.typescript, wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/, keywords = function() {
                    function kw(type) {
                        return {
                            type: type,
                            style: "keyword"
                        };
                    }
                    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), operator = kw("operator"), atom = {
                        type: "atom",
                        style: "atom"
                    }, jsKeywords = {
                        if: kw("if"),
                        while: A,
                        with: A,
                        else: B,
                        do: B,
                        try: B,
                        finally: B,
                        return: C,
                        break: C,
                        continue: C,
                        new: kw("new"),
                        delete: C,
                        throw: C,
                        debugger: C,
                        var: kw("var"),
                        const: kw("var"),
                        let: kw("var"),
                        function: kw("function"),
                        catch: kw("catch"),
                        for: kw("for"),
                        switch: kw("switch"),
                        case: kw("case"),
                        default: kw("default"),
                        in: operator,
                        typeof: operator,
                        instanceof: operator,
                        true: atom,
                        false: atom,
                        null: atom,
                        undefined: atom,
                        NaN: atom,
                        Infinity: atom,
                        this: kw("this"),
                        class: kw("class"),
                        super: kw("atom"),
                        yield: C,
                        export: kw("export"),
                        import: kw("import"),
                        extends: C,
                        await: C,
                        async: kw("async")
                    };
                    // Extend the 'normal' keywords with the TypeScript language extensions
                    if (isTS) {
                        var type = {
                            type: "variable",
                            style: "variable-3"
                        }, tsKeywords = {
                            // object-like things
                            interface: kw("class"),
                            implements: C,
                            namespace: C,
                            module: kw("module"),
                            enum: kw("module"),
                            type: kw("type"),
                            // scope modifiers
                            public: kw("modifier"),
                            private: kw("modifier"),
                            protected: kw("modifier"),
                            abstract: kw("modifier"),
                            // operators
                            as: operator,
                            // types
                            string: type,
                            number: type,
                            boolean: type,
                            any: type
                        };
                        for (var attr in tsKeywords) jsKeywords[attr] = tsKeywords[attr];
                    }
                    return jsKeywords;
                }(), isOperatorChar = /[+\-*&%=<>!?|~^]/, isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/, brackets = "([{}])", atomicTypes = {
                    atom: !0,
                    number: !0,
                    variable: !0,
                    string: !0,
                    regexp: !0,
                    this: !0,
                    "jsonld-keyword": !0
                }, cx = {
                    state: null,
                    column: null,
                    marked: null,
                    cc: null
                }, defaultVars = {
                    name: "this",
                    next: {
                        name: "arguments"
                    }
                };
                // Interface
                return poplex.lex = !0, {
                    startState: function(basecolumn) {
                        var state = {
                            tokenize: tokenBase,
                            lastType: "sof",
                            cc: [],
                            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", !1),
                            localVars: parserConfig.localVars,
                            context: parserConfig.localVars && {
                                vars: parserConfig.localVars
                            },
                            indented: basecolumn || 0
                        };
                        return parserConfig.globalVars && "object" == typeof parserConfig.globalVars && (state.globalVars = parserConfig.globalVars), 
                        state;
                    },
                    token: function(stream, state) {
                        if (stream.sol() && (state.lexical.hasOwnProperty("align") || (state.lexical.align = !1), 
                        state.indented = stream.indentation(), findFatArrow(stream, state)), state.tokenize != tokenComment && stream.eatSpace()) return null;
                        var style = state.tokenize(stream, state);
                        return "comment" == type ? style : (state.lastType = "operator" != type || "++" != content && "--" != content ? type : "incdec", 
                        parseJS(state, style, type, content, stream));
                    },
                    indent: function(state, textAfter) {
                        if (state.tokenize == tokenComment) return CodeMirror.Pass;
                        if (state.tokenize != tokenBase) return 0;
                        var top, firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
                        // Kludge to prevent 'maybelse' from blocking lexical scope pops
                        if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
                            var c = state.cc[i];
                            if (c == poplex) lexical = lexical.prev; else if (c != maybeelse) break;
                        }
                        for (;("stat" == lexical.type || "form" == lexical.type) && ("}" == firstChar || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)); ) lexical = lexical.prev;
                        statementIndent && ")" == lexical.type && "stat" == lexical.prev.type && (lexical = lexical.prev);
                        var type = lexical.type, closing = firstChar == type;
                        return "vardef" == type ? lexical.indented + ("operator" == state.lastType || "," == state.lastType ? lexical.info + 1 : 0) : "form" == type && "{" == firstChar ? lexical.indented : "form" == type ? lexical.indented + indentUnit : "stat" == type ? lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0) : "switch" != lexical.info || closing || 0 == parserConfig.doubleIndentSwitch ? lexical.align ? lexical.column + (closing ? 0 : 1) : lexical.indented + (closing ? 0 : indentUnit) : lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
                    },
                    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
                    blockCommentStart: jsonMode ? null : "/*",
                    blockCommentEnd: jsonMode ? null : "*/",
                    lineComment: jsonMode ? null : "//",
                    fold: "brace",
                    closeBrackets: "()[]{}''\"\"``",
                    helperType: jsonMode ? "json" : "javascript",
                    jsonldMode: jsonldMode,
                    jsonMode: jsonMode,
                    expressionAllowed: expressionAllowed,
                    skipExpression: function(state) {
                        var top = state.cc[state.cc.length - 1];
                        top != expression && top != expressionNoComma || state.cc.pop();
                    }
                };
            }), CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/), CodeMirror.defineMIME("text/javascript", "javascript"), 
            CodeMirror.defineMIME("text/ecmascript", "javascript"), CodeMirror.defineMIME("application/javascript", "javascript"), 
            CodeMirror.defineMIME("application/x-javascript", "javascript"), CodeMirror.defineMIME("application/ecmascript", "javascript"), 
            CodeMirror.defineMIME("application/json", {
                name: "javascript",
                json: !0
            }), CodeMirror.defineMIME("application/x-json", {
                name: "javascript",
                json: !0
            }), CodeMirror.defineMIME("application/ld+json", {
                name: "javascript",
                jsonld: !0
            }), CodeMirror.defineMIME("text/typescript", {
                name: "javascript",
                typescript: !0
            }), CodeMirror.defineMIME("application/typescript", {
                name: "javascript",
                typescript: !0
            });
        });
    }, /* 191 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  height: 100%;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n\n  h1 {\n    paddingRight: 9rem;\n  }\n" ], [ "\n  height: 100%;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n\n  h1 {\n    paddingRight: 9rem;\n  }\n" ]), _styledComponents = __webpack_require__(114), _styledComponents2 = _interopRequireDefault(_styledComponents), _presenterSlideStyle = __webpack_require__(192), _presenterSlideStyle2 = _interopRequireDefault(_presenterSlideStyle);
        exports.default = _styledComponents2.default.div(_templateObject, _presenterSlideStyle2.default);
    }, /* 192 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = function(props) {
            return props.theme.isPresenterMode && "\n  outline: 0.25rem solid #37F;\n  outline-offset: -0.25rem;\n\n  &::before {\n    content: 'presenter';\n    position: fixed;\n    top: 0;\n    left: 0;\n    background-color: #36F;\n    padding: 0.25rem;\n    color: #fff;\n    font-size: 0.65rem;\n  }\n";
        };
    }, /* 193 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(101), _inherits3 = _interopRequireDefault(_inherits2), _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 1rem;\n  right: 7rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 6.5rem;\n  }\n" ], [ "\n  position: absolute;\n  top: 1rem;\n  right: 7rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 6.5rem;\n  }\n" ]), _templateObject2 = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: rgba(0, 0, 0, .5);\n" ], [ "\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background-color: rgba(0, 0, 0, .5);\n" ]), _templateObject3 = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: rgba(255, 255, 255, .1);\n  padding: 1rem;\n  border-radius: 0.5rem;\n  z-index: 2;\n\n  .VirtualizedSelect {\n    width: 250px;\n    max-width: 100%;\n  }\n" ], [ "\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  background-color: rgba(255, 255, 255, .1);\n  padding: 1rem;\n  border-radius: 0.5rem;\n  z-index: 2;\n\n  .VirtualizedSelect {\n    width: 250px;\n    max-width: 100%;\n  }\n" ]), _templateObject4 = (0, 
        _taggedTemplateLiteral3.default)([ "\n  white-space: pre;\n  overflow: hidden;\n  text-overflow: ellipsis;\n" ], [ "\n  white-space: pre;\n  overflow: hidden;\n  text-overflow: ellipsis;\n" ]), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _reactVirtualizedSelect = __webpack_require__(194), _reactVirtualizedSelect2 = _interopRequireDefault(_reactVirtualizedSelect), _reactDom = __webpack_require__(198), _styledComponents = __webpack_require__(114), _styledComponents2 = _interopRequireDefault(_styledComponents), _IconButton = __webpack_require__(229), _IconButton2 = _interopRequireDefault(_IconButton), _Icons = __webpack_require__(230), _PropTypes = __webpack_require__(232);
        __webpack_require__(233);
        var ButtonGroup = _styledComponents2.default.div(_templateObject), Overlay = _styledComponents2.default.div(_templateObject2), SelectWrapper = _styledComponents2.default.div(_templateObject3), Row = _styledComponents2.default.div(_templateObject4), NavigateToSlide = function(_Component) {
            function NavigateToSlide(props, context) {
                (0, _classCallCheck3.default)(this, NavigateToSlide);
                var _this = (0, _possibleConstructorReturn3.default)(this, (NavigateToSlide.__proto__ || (0, 
                _getPrototypeOf2.default)(NavigateToSlide)).call(this, props, context));
                return _this.state = {
                    active: !1
                }, _this._onChange = _this._onChange.bind(_this), _this._onClick = _this._onClick.bind(_this), 
                _this._onKeyDown = _this._onKeyDown.bind(_this), _this._optionRenderer = _this._optionRenderer.bind(_this), 
                _this;
            }
            return (0, _inherits3.default)(NavigateToSlide, _Component), (0, _createClass3.default)(NavigateToSlide, [ {
                key: "componentDidMount",
                value: function() {
                    document.body.addEventListener("click", this._onClick);
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    document.body.removeEventListener("click", this._onClick);
                }
            }, {
                key: "render",
                value: function() {
                    var _this2 = this, slideIndex = this.context.slideIndex, options = this.props.options, active = this.state.active;
                    return active ? _react2.default.createElement(Overlay, null, _react2.default.createElement(SelectWrapper, null, _react2.default.createElement(_reactVirtualizedSelect2.default, {
                        autofocus: !0,
                        className: "VirtualizedSelect",
                        clearable: !1,
                        options: options,
                        onChange: this._onChange,
                        onInputKeyDown: this._onKeyDown,
                        optionHeight: 35,
                        optionRenderer: this._optionRenderer,
                        ref: function(_ref) {
                            _this2._select = _ref;
                        },
                        value: slideIndex
                    }))) : options.length ? _react2.default.createElement(ButtonGroup, null, _react2.default.createElement(_IconButton2.default, {
                        onClick: function() {
                            return _this2.setState({
                                active: !0
                            });
                        }
                    }, _react2.default.createElement(_Icons.IconMore, null))) : null;
                }
            }, {
                key: "_onChange",
                value: function(option) {
                    var slideIndex = option.value, presentation = this.context.presentation;
                    this.setState({
                        active: !1
                    }), presentation.goToSlide({
                        slideIndex: slideIndex
                    });
                }
            }, {
                key: "_onClick",
                value: function(event) {
                    var active = this.state.active;
                    if (active) {
                        var select = (0, _reactDom.findDOMNode)(this._select);
                        select === event.target || select.contains(event.target) || this.setState({
                            active: !1
                        });
                    }
                }
            }, {
                key: "_onKeyDown",
                value: function(event) {
                    switch (event.key) {
                      case "Escape":
                        this.setState({
                            active: !1
                        });
                    }
                }
            }, {
                key: "_optionRenderer",
                value: function(_ref2) {
                    var focusedOption = _ref2.focusedOption, focusOption = _ref2.focusOption, key = _ref2.key, labelKey = _ref2.labelKey, option = _ref2.option, selectValue = _ref2.selectValue, style = _ref2.style, classNames = [ "VirtualizedSelectOption" ];
                    option === focusedOption && classNames.push("VirtualizedSelectFocusedOption"), option.disabled && classNames.push("VirtualizedSelectOptionHeader");
                    var text = option[labelKey], events = option.disabled ? {} : {
                        onClick: function() {
                            return selectValue(option);
                        },
                        onMouseOver: function() {
                            return focusOption(option);
                        }
                    };
                    return _react2.default.createElement("div", (0, _extends3.default)({
                        className: classNames.join(" "),
                        key: key,
                        style: style,
                        title: text
                    }, events), _react2.default.createElement(Row, null, text));
                }
            } ]), NavigateToSlide;
        }(_react.Component);
        NavigateToSlide.contextTypes = {
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = NavigateToSlide;
    }, /* 194 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = void 0;
        var _VirtualizedSelect = __webpack_require__(195), _VirtualizedSelect2 = _interopRequireDefault(_VirtualizedSelect);
        exports.default = _VirtualizedSelect2.default;
    }, /* 195 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = void 0;
        var _VirtualizedSelect = __webpack_require__(196), _VirtualizedSelect2 = _interopRequireDefault(_VirtualizedSelect);
        exports.default = _VirtualizedSelect2.default;
    }, /* 196 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _reactSelect = __webpack_require__(197), _reactSelect2 = _interopRequireDefault(_reactSelect), _AutoSizer = __webpack_require__(210), _AutoSizer2 = _interopRequireDefault(_AutoSizer), _List = __webpack_require__(216), _List2 = _interopRequireDefault(_List), VirtualizedSelect = function(_Component) {
            function VirtualizedSelect(props, context) {
                _classCallCheck(this, VirtualizedSelect);
                var _this = _possibleConstructorReturn(this, (VirtualizedSelect.__proto__ || Object.getPrototypeOf(VirtualizedSelect)).call(this, props, context));
                return _this._renderMenu = _this._renderMenu.bind(_this), _this._optionRenderer = _this._optionRenderer.bind(_this), 
                _this._setListRef = _this._setListRef.bind(_this), _this._setSelectRef = _this._setSelectRef.bind(_this), 
                _this;
            }
            /** See List#recomputeRowHeights */
            return _inherits(VirtualizedSelect, _Component), _createClass(VirtualizedSelect, [ {
                key: "recomputeOptionHeights",
                value: function() {
                    var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    this._listRef && this._listRef.recomputeRowHeights(index);
                }
            }, {
                key: "focus",
                value: function() {
                    if (this._selectRef) return this._selectRef.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var SelectComponent = this._getSelectComponent();
                    return _react2.default.createElement(SelectComponent, _extends({}, this.props, {
                        ref: this._setSelectRef,
                        menuRenderer: this._renderMenu,
                        menuStyle: {
                            overflow: "hidden"
                        }
                    }));
                }
            }, {
                key: "_renderMenu",
                value: function(_ref) {
                    // react-select 1.0.0-rc2 passes duplicate `onSelect` and `selectValue` props to `menuRenderer`
                    // The `Creatable` HOC only overrides `onSelect` which breaks an edge-case
                    // In order to support creating items via clicking on the placeholder option,
                    // We need to ensure that the specified `onSelect` handle is the one we use.
                    // See issue #33
                    function wrappedRowRenderer(_ref2) {
                        var index = _ref2.index, key = _ref2.key, style = _ref2.style, option = options[index];
                        return innerRowRenderer({
                            focusedOption: focusedOption,
                            focusedOptionIndex: focusedOptionIndex,
                            focusOption: focusOption,
                            key: key,
                            labelKey: labelKey,
                            onSelect: onSelect,
                            option: option,
                            optionIndex: index,
                            options: options,
                            selectValue: onSelect,
                            style: style,
                            valueArray: valueArray
                        });
                    }
                    var _this2 = this, focusedOption = _ref.focusedOption, focusOption = _ref.focusOption, labelKey = _ref.labelKey, onSelect = _ref.onSelect, options = _ref.options, valueArray = (_ref.selectValue, 
                    _ref.valueArray), _props = this.props, listProps = _props.listProps, optionRenderer = _props.optionRenderer, focusedOptionIndex = options.indexOf(focusedOption), height = this._calculateListHeight({
                        options: options
                    }), innerRowRenderer = optionRenderer || this._optionRenderer;
                    return _react2.default.createElement(_AutoSizer2.default, {
                        disableHeight: !0
                    }, function(_ref3) {
                        var width = _ref3.width;
                        return _react2.default.createElement(_List2.default, _extends({
                            className: "VirtualSelectGrid",
                            height: height,
                            ref: _this2._setListRef,
                            rowCount: options.length,
                            rowHeight: function(_ref4) {
                                var index = _ref4.index;
                                return _this2._getOptionHeight({
                                    option: options[index]
                                });
                            },
                            rowRenderer: wrappedRowRenderer,
                            scrollToIndex: focusedOptionIndex,
                            width: width
                        }, listProps));
                    });
                }
            }, {
                key: "_calculateListHeight",
                value: function(_ref5) {
                    for (var options = _ref5.options, maxHeight = this.props.maxHeight, height = 0, optionIndex = 0; optionIndex < options.length; optionIndex++) {
                        var option = options[optionIndex];
                        if (height += this._getOptionHeight({
                            option: option
                        }), height > maxHeight) return maxHeight;
                    }
                    return height;
                }
            }, {
                key: "_getOptionHeight",
                value: function(_ref6) {
                    var option = _ref6.option, optionHeight = this.props.optionHeight;
                    return optionHeight instanceof Function ? optionHeight({
                        option: option
                    }) : optionHeight;
                }
            }, {
                key: "_getSelectComponent",
                value: function() {
                    var _props2 = this.props, async = _props2.async, selectComponent = _props2.selectComponent;
                    return selectComponent ? selectComponent : async ? _reactSelect2.default.Async : _reactSelect2.default;
                }
            }, {
                key: "_optionRenderer",
                value: function(_ref7) {
                    var focusedOption = _ref7.focusedOption, focusOption = _ref7.focusOption, key = _ref7.key, labelKey = _ref7.labelKey, option = _ref7.option, selectValue = _ref7.selectValue, style = _ref7.style, valueArray = _ref7.valueArray, className = [ "VirtualizedSelectOption" ];
                    option === focusedOption && className.push("VirtualizedSelectFocusedOption"), option.disabled && className.push("VirtualizedSelectDisabledOption"), 
                    valueArray && valueArray.indexOf(option) >= 0 && className.push("VirtualizedSelectSelectedOption");
                    var events = option.disabled ? {} : {
                        onClick: function() {
                            return selectValue(option);
                        },
                        onMouseOver: function() {
                            return focusOption(option);
                        }
                    };
                    return _react2.default.createElement("div", _extends({
                        className: className.join(" "),
                        key: key,
                        style: style
                    }, events), option[labelKey]);
                }
            }, {
                key: "_setListRef",
                value: function(ref) {
                    this._listRef = ref;
                }
            }, {
                key: "_setSelectRef",
                value: function(ref) {
                    this._selectRef = ref;
                }
            } ]), VirtualizedSelect;
        }(_react.Component);
        VirtualizedSelect.propTypes = {
            async: _react.PropTypes.bool,
            listProps: _react.PropTypes.object,
            maxHeight: _react.PropTypes.number.isRequired,
            optionHeight: _react.PropTypes.oneOfType([ _react.PropTypes.number, _react.PropTypes.func ]).isRequired,
            optionRenderer: _react.PropTypes.func,
            selectComponent: _react.PropTypes.func
        }, VirtualizedSelect.defaultProps = {
            async: !1,
            maxHeight: 200,
            optionHeight: 35
        }, exports.default = VirtualizedSelect;
    }, /* 197 */
    /***/
    function(module, exports, __webpack_require__) {
        /*!
	  Copyright (c) 2016 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/react-select
	*/
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function stringifyValue(value) {
            var valueType = typeof value;
            return "string" === valueType ? value : "object" === valueType ? JSON.stringify(value) : "number" === valueType || "boolean" === valueType ? String(value) : "";
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _reactDom = __webpack_require__(198), _reactDom2 = _interopRequireDefault(_reactDom), _reactInputAutosize = __webpack_require__(199), _reactInputAutosize2 = _interopRequireDefault(_reactInputAutosize), _classnames = __webpack_require__(111), _classnames2 = _interopRequireDefault(_classnames), _utilsDefaultArrowRenderer = __webpack_require__(200), _utilsDefaultArrowRenderer2 = _interopRequireDefault(_utilsDefaultArrowRenderer), _utilsDefaultFilterOptions = __webpack_require__(201), _utilsDefaultFilterOptions2 = _interopRequireDefault(_utilsDefaultFilterOptions), _utilsDefaultMenuRenderer = __webpack_require__(203), _utilsDefaultMenuRenderer2 = _interopRequireDefault(_utilsDefaultMenuRenderer), _utilsDefaultClearRenderer = __webpack_require__(204), _utilsDefaultClearRenderer2 = _interopRequireDefault(_utilsDefaultClearRenderer), _Async = __webpack_require__(205), _Async2 = _interopRequireDefault(_Async), _AsyncCreatable = __webpack_require__(206), _AsyncCreatable2 = _interopRequireDefault(_AsyncCreatable), _Creatable = __webpack_require__(207), _Creatable2 = _interopRequireDefault(_Creatable), _Option = __webpack_require__(208), _Option2 = _interopRequireDefault(_Option), _Value = __webpack_require__(209), _Value2 = _interopRequireDefault(_Value), stringOrNode = _react2.default.PropTypes.oneOfType([ _react2.default.PropTypes.string, _react2.default.PropTypes.node ]), instanceId = 1, Select = _react2.default.createClass({
            displayName: "Select",
            propTypes: {
                addLabelText: _react2.default.PropTypes.string,
                // placeholder displayed when you want to add a label on a multi-value input
                "aria-label": _react2.default.PropTypes.string,
                // Aria label (for assistive tech)
                "aria-labelledby": _react2.default.PropTypes.string,
                // HTML ID of an element that should be used as the label (for assistive tech)
                arrowRenderer: _react2.default.PropTypes.func,
                // Create drop-down caret element
                autoBlur: _react2.default.PropTypes.bool,
                // automatically blur the component when an option is selected
                autofocus: _react2.default.PropTypes.bool,
                // autofocus the component on mount
                autosize: _react2.default.PropTypes.bool,
                // whether to enable autosizing or not
                backspaceRemoves: _react2.default.PropTypes.bool,
                // whether backspace removes an item if there is no text input
                backspaceToRemoveMessage: _react2.default.PropTypes.string,
                // Message to use for screenreaders to press backspace to remove the current item - {label} is replaced with the item label
                className: _react2.default.PropTypes.string,
                // className for the outer element
                clearAllText: stringOrNode,
                // title for the "clear" control when multi: true
                clearRenderer: _react2.default.PropTypes.func,
                // create clearable x element
                clearValueText: stringOrNode,
                // title for the "clear" control
                clearable: _react2.default.PropTypes.bool,
                // should it be possible to reset value
                deleteRemoves: _react2.default.PropTypes.bool,
                // whether backspace removes an item if there is no text input
                delimiter: _react2.default.PropTypes.string,
                // delimiter to use to join multiple values for the hidden field value
                disabled: _react2.default.PropTypes.bool,
                // whether the Select is disabled or not
                escapeClearsValue: _react2.default.PropTypes.bool,
                // whether escape clears the value when the menu is closed
                filterOption: _react2.default.PropTypes.func,
                // method to filter a single option (option, filterString)
                filterOptions: _react2.default.PropTypes.any,
                // boolean to enable default filtering or function to filter the options array ([options], filterString, [values])
                ignoreAccents: _react2.default.PropTypes.bool,
                // whether to strip diacritics when filtering
                ignoreCase: _react2.default.PropTypes.bool,
                // whether to perform case-insensitive filtering
                inputProps: _react2.default.PropTypes.object,
                // custom attributes for the Input
                inputRenderer: _react2.default.PropTypes.func,
                // returns a custom input component
                instanceId: _react2.default.PropTypes.string,
                // set the components instanceId
                isLoading: _react2.default.PropTypes.bool,
                // whether the Select is loading externally or not (such as options being loaded)
                joinValues: _react2.default.PropTypes.bool,
                // joins multiple values into a single form field with the delimiter (legacy mode)
                labelKey: _react2.default.PropTypes.string,
                // path of the label value in option objects
                matchPos: _react2.default.PropTypes.string,
                // (any|start) match the start or entire string when filtering
                matchProp: _react2.default.PropTypes.string,
                // (any|label|value) which option property to filter on
                menuBuffer: _react2.default.PropTypes.number,
                // optional buffer (in px) between the bottom of the viewport and the bottom of the menu
                menuContainerStyle: _react2.default.PropTypes.object,
                // optional style to apply to the menu container
                menuRenderer: _react2.default.PropTypes.func,
                // renders a custom menu with options
                menuStyle: _react2.default.PropTypes.object,
                // optional style to apply to the menu
                multi: _react2.default.PropTypes.bool,
                // multi-value input
                name: _react2.default.PropTypes.string,
                // generates a hidden <input /> tag with this field name for html forms
                noResultsText: stringOrNode,
                // placeholder displayed when there are no matching search results
                onBlur: _react2.default.PropTypes.func,
                // onBlur handler: function (event) {}
                onBlurResetsInput: _react2.default.PropTypes.bool,
                // whether input is cleared on blur
                onChange: _react2.default.PropTypes.func,
                // onChange handler: function (newValue) {}
                onClose: _react2.default.PropTypes.func,
                // fires when the menu is closed
                onCloseResetsInput: _react2.default.PropTypes.bool,
                // whether input is cleared when menu is closed through the arrow
                onFocus: _react2.default.PropTypes.func,
                // onFocus handler: function (event) {}
                onInputChange: _react2.default.PropTypes.func,
                // onInputChange handler: function (inputValue) {}
                onInputKeyDown: _react2.default.PropTypes.func,
                // input keyDown handler: function (event) {}
                onMenuScrollToBottom: _react2.default.PropTypes.func,
                // fires when the menu is scrolled to the bottom; can be used to paginate options
                onOpen: _react2.default.PropTypes.func,
                // fires when the menu is opened
                onValueClick: _react2.default.PropTypes.func,
                // onClick handler for value labels: function (value, event) {}
                openAfterFocus: _react2.default.PropTypes.bool,
                // boolean to enable opening dropdown when focused
                openOnFocus: _react2.default.PropTypes.bool,
                // always open options menu on focus
                optionClassName: _react2.default.PropTypes.string,
                // additional class(es) to apply to the <Option /> elements
                optionComponent: _react2.default.PropTypes.func,
                // option component to render in dropdown
                optionRenderer: _react2.default.PropTypes.func,
                // optionRenderer: function (option) {}
                options: _react2.default.PropTypes.array,
                // array of options
                pageSize: _react2.default.PropTypes.number,
                // number of entries to page when using page up/down keys
                placeholder: stringOrNode,
                // field placeholder, displayed when there's no value
                required: _react2.default.PropTypes.bool,
                // applies HTML5 required attribute when needed
                resetValue: _react2.default.PropTypes.any,
                // value to use when you clear the control
                scrollMenuIntoView: _react2.default.PropTypes.bool,
                // boolean to enable the viewport to shift so that the full menu fully visible when engaged
                searchable: _react2.default.PropTypes.bool,
                // whether to enable searching feature or not
                simpleValue: _react2.default.PropTypes.bool,
                // pass the value to onChange as a simple value (legacy pre 1.0 mode), defaults to false
                style: _react2.default.PropTypes.object,
                // optional style to apply to the control
                tabIndex: _react2.default.PropTypes.string,
                // optional tab index of the control
                tabSelectsValue: _react2.default.PropTypes.bool,
                // whether to treat tabbing out while focused to be value selection
                value: _react2.default.PropTypes.any,
                // initial field value
                valueComponent: _react2.default.PropTypes.func,
                // value component to render
                valueKey: _react2.default.PropTypes.string,
                // path of the label value in option objects
                valueRenderer: _react2.default.PropTypes.func,
                // valueRenderer: function (option) {}
                wrapperStyle: _react2.default.PropTypes.object
            },
            // optional style to apply to the component wrapper
            statics: {
                Async: _Async2.default,
                AsyncCreatable: _AsyncCreatable2.default,
                Creatable: _Creatable2.default
            },
            getDefaultProps: function() {
                return {
                    addLabelText: 'Add "{label}"?',
                    arrowRenderer: _utilsDefaultArrowRenderer2.default,
                    autosize: !0,
                    backspaceRemoves: !0,
                    backspaceToRemoveMessage: "Press backspace to remove {label}",
                    clearable: !0,
                    clearAllText: "Clear all",
                    clearRenderer: _utilsDefaultClearRenderer2.default,
                    clearValueText: "Clear value",
                    deleteRemoves: !0,
                    delimiter: ",",
                    disabled: !1,
                    escapeClearsValue: !0,
                    filterOptions: _utilsDefaultFilterOptions2.default,
                    ignoreAccents: !0,
                    ignoreCase: !0,
                    inputProps: {},
                    isLoading: !1,
                    joinValues: !1,
                    labelKey: "label",
                    matchPos: "any",
                    matchProp: "any",
                    menuBuffer: 0,
                    menuRenderer: _utilsDefaultMenuRenderer2.default,
                    multi: !1,
                    noResultsText: "No results found",
                    onBlurResetsInput: !0,
                    onCloseResetsInput: !0,
                    openAfterFocus: !1,
                    optionComponent: _Option2.default,
                    pageSize: 5,
                    placeholder: "Select...",
                    required: !1,
                    scrollMenuIntoView: !0,
                    searchable: !0,
                    simpleValue: !1,
                    tabSelectsValue: !0,
                    valueComponent: _Value2.default,
                    valueKey: "value"
                };
            },
            getInitialState: function() {
                return {
                    inputValue: "",
                    isFocused: !1,
                    isOpen: !1,
                    isPseudoFocused: !1,
                    required: !1
                };
            },
            componentWillMount: function() {
                this._instancePrefix = "react-select-" + (this.props.instanceId || ++instanceId) + "-";
                var valueArray = this.getValueArray(this.props.value);
                this.props.required && this.setState({
                    required: this.handleRequired(valueArray[0], this.props.multi)
                });
            },
            componentDidMount: function() {
                this.props.autofocus && this.focus();
            },
            componentWillReceiveProps: function(nextProps) {
                var valueArray = this.getValueArray(nextProps.value, nextProps);
                nextProps.required && this.setState({
                    required: this.handleRequired(valueArray[0], nextProps.multi)
                });
            },
            componentWillUpdate: function(nextProps, nextState) {
                if (nextState.isOpen !== this.state.isOpen) {
                    this.toggleTouchOutsideEvent(nextState.isOpen);
                    var handler = nextState.isOpen ? nextProps.onOpen : nextProps.onClose;
                    handler && handler();
                }
            },
            componentDidUpdate: function(prevProps, prevState) {
                // focus to the selected option
                if (this.menu && this.focused && this.state.isOpen && !this.hasScrolledToOption) {
                    var focusedOptionNode = _reactDom2.default.findDOMNode(this.focused), menuNode = _reactDom2.default.findDOMNode(this.menu);
                    menuNode.scrollTop = focusedOptionNode.offsetTop, this.hasScrolledToOption = !0;
                } else this.state.isOpen || (this.hasScrolledToOption = !1);
                if (this._scrollToFocusedOptionOnUpdate && this.focused && this.menu) {
                    this._scrollToFocusedOptionOnUpdate = !1;
                    var focusedDOM = _reactDom2.default.findDOMNode(this.focused), menuDOM = _reactDom2.default.findDOMNode(this.menu), focusedRect = focusedDOM.getBoundingClientRect(), menuRect = menuDOM.getBoundingClientRect();
                    (focusedRect.bottom > menuRect.bottom || focusedRect.top < menuRect.top) && (menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight);
                }
                if (this.props.scrollMenuIntoView && this.menuContainer) {
                    var menuContainerRect = this.menuContainer.getBoundingClientRect();
                    window.innerHeight < menuContainerRect.bottom + this.props.menuBuffer && window.scrollBy(0, menuContainerRect.bottom + this.props.menuBuffer - window.innerHeight);
                }
                prevProps.disabled !== this.props.disabled && (this.setState({
                    isFocused: !1
                }), // eslint-disable-line react/no-did-update-set-state
                this.closeMenu());
            },
            componentWillUnmount: function() {
                !document.removeEventListener && document.detachEvent ? document.detachEvent("ontouchstart", this.handleTouchOutside) : document.removeEventListener("touchstart", this.handleTouchOutside);
            },
            toggleTouchOutsideEvent: function(enabled) {
                enabled ? !document.addEventListener && document.attachEvent ? document.attachEvent("ontouchstart", this.handleTouchOutside) : document.addEventListener("touchstart", this.handleTouchOutside) : !document.removeEventListener && document.detachEvent ? document.detachEvent("ontouchstart", this.handleTouchOutside) : document.removeEventListener("touchstart", this.handleTouchOutside);
            },
            handleTouchOutside: function(event) {
                // handle touch outside on ios to dismiss menu
                this.wrapper && !this.wrapper.contains(event.target) && this.closeMenu();
            },
            focus: function() {
                this.input && (this.input.focus(), this.props.openAfterFocus && this.setState({
                    isOpen: !0
                }));
            },
            blurInput: function() {
                this.input && this.input.blur();
            },
            handleTouchMove: function(event) {
                // Set a flag that the view is being dragged
                this.dragging = !0;
            },
            handleTouchStart: function(event) {
                // Set a flag that the view is not being dragged
                this.dragging = !1;
            },
            handleTouchEnd: function(event) {
                // Check if the view is being dragged, In this case
                // we don't want to fire the click event (because the user only wants to scroll)
                this.dragging || // Fire the mouse events
                this.handleMouseDown(event);
            },
            handleTouchEndClearValue: function(event) {
                // Check if the view is being dragged, In this case
                // we don't want to fire the click event (because the user only wants to scroll)
                this.dragging || // Clear the value
                this.clearValue(event);
            },
            handleMouseDown: function(event) {
                // if the event was triggered by a mousedown and not the primary
                // button, or if the component is disabled, ignore it.
                if (!(this.props.disabled || "mousedown" === event.type && 0 !== event.button) && "INPUT" !== event.target.tagName) {
                    // for the non-searchable select, toggle the menu
                    if (// prevent default event handlers
                    event.stopPropagation(), event.preventDefault(), !this.props.searchable) return this.focus(), 
                    this.setState({
                        isOpen: !this.state.isOpen
                    });
                    if (this.state.isFocused) {
                        // On iOS, we can get into a state where we think the input is focused but it isn't really,
                        // since iOS ignores programmatic calls to input.focus() that weren't triggered by a click event.
                        // Call focus() again here to be safe.
                        this.focus();
                        var input = this.input;
                        "function" == typeof input.getInput && (// Get the actual DOM input if the ref is an <AutosizeInput /> component
                        input = input.getInput()), // clears the value so that the cursor will be at the end of input when the component re-renders
                        input.value = "", // if the input is focused, ensure the menu is open
                        this.setState({
                            isOpen: !0,
                            isPseudoFocused: !1
                        });
                    } else // otherwise, focus the input and open the menu
                    this._openAfterFocus = !0, this.focus();
                }
            },
            handleMouseDownOnArrow: function(event) {
                // if the event was triggered by a mousedown and not the primary
                // button, or if the component is disabled, ignore it.
                this.props.disabled || "mousedown" === event.type && 0 !== event.button || // If the menu isn't open, let the event bubble to the main handleMouseDown
                this.state.isOpen && (// prevent default event handlers
                event.stopPropagation(), event.preventDefault(), // close the menu
                this.closeMenu());
            },
            handleMouseDownOnMenu: function(event) {
                // if the event was triggered by a mousedown and not the primary
                // button, or if the component is disabled, ignore it.
                this.props.disabled || "mousedown" === event.type && 0 !== event.button || (event.stopPropagation(), 
                event.preventDefault(), this._openAfterFocus = !0, this.focus());
            },
            closeMenu: function() {
                this.props.onCloseResetsInput ? this.setState({
                    isOpen: !1,
                    isPseudoFocused: this.state.isFocused && !this.props.multi,
                    inputValue: ""
                }) : this.setState({
                    isOpen: !1,
                    isPseudoFocused: this.state.isFocused && !this.props.multi,
                    inputValue: this.state.inputValue
                }), this.hasScrolledToOption = !1;
            },
            handleInputFocus: function(event) {
                if (!this.props.disabled) {
                    var isOpen = this.state.isOpen || this._openAfterFocus || this.props.openOnFocus;
                    this.props.onFocus && this.props.onFocus(event), this.setState({
                        isFocused: !0,
                        isOpen: isOpen
                    }), this._openAfterFocus = !1;
                }
            },
            handleInputBlur: function(event) {
                // The check for menu.contains(activeElement) is necessary to prevent IE11's scrollbar from closing the menu in certain contexts.
                if (this.menu && (this.menu === document.activeElement || this.menu.contains(document.activeElement))) return void this.focus();
                this.props.onBlur && this.props.onBlur(event);
                var onBlurredState = {
                    isFocused: !1,
                    isOpen: !1,
                    isPseudoFocused: !1
                };
                this.props.onBlurResetsInput && (onBlurredState.inputValue = ""), this.setState(onBlurredState);
            },
            handleInputChange: function(event) {
                var newInputValue = event.target.value;
                if (this.state.inputValue !== event.target.value && this.props.onInputChange) {
                    var nextState = this.props.onInputChange(newInputValue);
                    // Note: != used deliberately here to catch undefined and null
                    null != nextState && "object" != typeof nextState && (newInputValue = "" + nextState);
                }
                this.setState({
                    isOpen: !0,
                    isPseudoFocused: !1,
                    inputValue: newInputValue
                });
            },
            handleKeyDown: function(event) {
                if (!(this.props.disabled || "function" == typeof this.props.onInputKeyDown && (this.props.onInputKeyDown(event), 
                event.defaultPrevented))) {
                    switch (event.keyCode) {
                      case 8:
                        // backspace
                        return void (!this.state.inputValue && this.props.backspaceRemoves && (event.preventDefault(), 
                        this.popValue()));

                      case 9:
                        // tab
                        if (event.shiftKey || !this.state.isOpen || !this.props.tabSelectsValue) return;
                        return void this.selectFocusedOption();

                      case 13:
                        // enter
                        if (!this.state.isOpen) return;
                        event.stopPropagation(), this.selectFocusedOption();
                        break;

                      case 27:
                        // escape
                        this.state.isOpen ? (this.closeMenu(), event.stopPropagation()) : this.props.clearable && this.props.escapeClearsValue && (this.clearValue(event), 
                        event.stopPropagation());
                        break;

                      case 38:
                        // up
                        this.focusPreviousOption();
                        break;

                      case 40:
                        // down
                        this.focusNextOption();
                        break;

                      case 33:
                        // page up
                        this.focusPageUpOption();
                        break;

                      case 34:
                        // page down
                        this.focusPageDownOption();
                        break;

                      case 35:
                        // end key
                        if (event.shiftKey) return;
                        this.focusEndOption();
                        break;

                      case 36:
                        // home key
                        if (event.shiftKey) return;
                        this.focusStartOption();
                        break;

                      case 46:
                        // backspace
                        return void (!this.state.inputValue && this.props.deleteRemoves && (event.preventDefault(), 
                        this.popValue()));

                      default:
                        return;
                    }
                    event.preventDefault();
                }
            },
            handleValueClick: function(option, event) {
                this.props.onValueClick && this.props.onValueClick(option, event);
            },
            handleMenuScroll: function(event) {
                if (this.props.onMenuScrollToBottom) {
                    var target = event.target;
                    target.scrollHeight > target.offsetHeight && !(target.scrollHeight - target.offsetHeight - target.scrollTop) && this.props.onMenuScrollToBottom();
                }
            },
            handleRequired: function(value, multi) {
                return !value || (multi ? 0 === value.length : 0 === Object.keys(value).length);
            },
            getOptionLabel: function(op) {
                return op[this.props.labelKey];
            },
            /**
	  * Turns a value into an array from the given options
	  * @param	{String|Number|Array}	value		- the value of the select input
	  * @param	{Object}		nextProps	- optionally specify the nextProps so the returned array uses the latest configuration
	  * @returns	{Array}	the value of the select represented in an array
	  */
            getValueArray: function(value, nextProps) {
                var _this = this, props = "object" == typeof nextProps ? nextProps : this.props;
                if (props.multi) {
                    if ("string" == typeof value && (value = value.split(props.delimiter)), !Array.isArray(value)) {
                        if (null === value || void 0 === value) return [];
                        value = [ value ];
                    }
                    return value.map(function(value) {
                        return _this.expandValue(value, props);
                    }).filter(function(i) {
                        return i;
                    });
                }
                var expandedValue = this.expandValue(value, props);
                return expandedValue ? [ expandedValue ] : [];
            },
            /**
	  * Retrieve a value from the given options and valueKey
	  * @param	{String|Number|Array}	value	- the selected value(s)
	  * @param	{Object}		props	- the Select component's props (or nextProps)
	  */
            expandValue: function(value, props) {
                var valueType = typeof value;
                if ("string" !== valueType && "number" !== valueType && "boolean" !== valueType) return value;
                var options = props.options, valueKey = props.valueKey;
                if (options) for (var i = 0; i < options.length; i++) if (options[i][valueKey] === value) return options[i];
            },
            setValue: function(value) {
                var _this2 = this;
                if (this.props.autoBlur && this.blurInput(), this.props.onChange) {
                    if (this.props.required) {
                        var required = this.handleRequired(value, this.props.multi);
                        this.setState({
                            required: required
                        });
                    }
                    this.props.simpleValue && value && (value = this.props.multi ? value.map(function(i) {
                        return i[_this2.props.valueKey];
                    }).join(this.props.delimiter) : value[this.props.valueKey]), this.props.onChange(value);
                }
            },
            selectValue: function(value) {
                var _this3 = this;
                //NOTE: update value in the callback to make sure the input value is empty so that there are no styling issues (Chrome had issue otherwise)
                this.hasScrolledToOption = !1, this.props.multi ? this.setState({
                    inputValue: "",
                    focusedIndex: null
                }, function() {
                    _this3.addValue(value);
                }) : this.setState({
                    isOpen: !1,
                    inputValue: "",
                    isPseudoFocused: this.state.isFocused
                }, function() {
                    _this3.setValue(value);
                });
            },
            addValue: function(value) {
                var valueArray = this.getValueArray(this.props.value), visibleOptions = this._visibleOptions.filter(function(val) {
                    return !val.disabled;
                }), lastValueIndex = visibleOptions.indexOf(value);
                this.setValue(valueArray.concat(value)), visibleOptions.length - 1 === lastValueIndex ? // the last option was selected; focus the second-last one
                this.focusOption(visibleOptions[lastValueIndex - 1]) : visibleOptions.length > lastValueIndex && // focus the option below the selected one
                this.focusOption(visibleOptions[lastValueIndex + 1]);
            },
            popValue: function() {
                var valueArray = this.getValueArray(this.props.value);
                valueArray.length && valueArray[valueArray.length - 1].clearableValue !== !1 && this.setValue(valueArray.slice(0, valueArray.length - 1));
            },
            removeValue: function(value) {
                var valueArray = this.getValueArray(this.props.value);
                this.setValue(valueArray.filter(function(i) {
                    return i !== value;
                })), this.focus();
            },
            clearValue: function(event) {
                // if the event was triggered by a mousedown and not the primary
                // button, ignore it.
                event && "mousedown" === event.type && 0 !== event.button || (event.stopPropagation(), 
                event.preventDefault(), this.setValue(this.getResetValue()), this.setState({
                    isOpen: !1,
                    inputValue: ""
                }, this.focus));
            },
            getResetValue: function() {
                return void 0 !== this.props.resetValue ? this.props.resetValue : this.props.multi ? [] : null;
            },
            focusOption: function(option) {
                this.setState({
                    focusedOption: option
                });
            },
            focusNextOption: function() {
                this.focusAdjacentOption("next");
            },
            focusPreviousOption: function() {
                this.focusAdjacentOption("previous");
            },
            focusPageUpOption: function() {
                this.focusAdjacentOption("page_up");
            },
            focusPageDownOption: function() {
                this.focusAdjacentOption("page_down");
            },
            focusStartOption: function() {
                this.focusAdjacentOption("start");
            },
            focusEndOption: function() {
                this.focusAdjacentOption("end");
            },
            focusAdjacentOption: function(dir) {
                var options = this._visibleOptions.map(function(option, index) {
                    return {
                        option: option,
                        index: index
                    };
                }).filter(function(option) {
                    return !option.option.disabled;
                });
                if (this._scrollToFocusedOptionOnUpdate = !0, !this.state.isOpen) return void this.setState({
                    isOpen: !0,
                    inputValue: "",
                    focusedOption: this._focusedOption || (options.length ? options["next" === dir ? 0 : options.length - 1].option : null)
                });
                if (options.length) {
                    for (var focusedIndex = -1, i = 0; i < options.length; i++) if (this._focusedOption === options[i].option) {
                        focusedIndex = i;
                        break;
                    }
                    if ("next" === dir && focusedIndex !== -1) focusedIndex = (focusedIndex + 1) % options.length; else if ("previous" === dir) focusedIndex > 0 ? focusedIndex -= 1 : focusedIndex = options.length - 1; else if ("start" === dir) focusedIndex = 0; else if ("end" === dir) focusedIndex = options.length - 1; else if ("page_up" === dir) {
                        var potentialIndex = focusedIndex - this.props.pageSize;
                        focusedIndex = potentialIndex < 0 ? 0 : potentialIndex;
                    } else if ("page_down" === dir) {
                        var potentialIndex = focusedIndex + this.props.pageSize;
                        focusedIndex = potentialIndex > options.length - 1 ? options.length - 1 : potentialIndex;
                    }
                    focusedIndex === -1 && (focusedIndex = 0), this.setState({
                        focusedIndex: options[focusedIndex].index,
                        focusedOption: options[focusedIndex].option
                    });
                }
            },
            getFocusedOption: function() {
                return this._focusedOption;
            },
            getInputValue: function() {
                return this.state.inputValue;
            },
            selectFocusedOption: function() {
                if (this._focusedOption) return this.selectValue(this._focusedOption);
            },
            renderLoading: function() {
                if (this.props.isLoading) return _react2.default.createElement("span", {
                    className: "Select-loading-zone",
                    "aria-hidden": "true"
                }, _react2.default.createElement("span", {
                    className: "Select-loading"
                }));
            },
            renderValue: function(valueArray, isOpen) {
                var _this4 = this, renderLabel = this.props.valueRenderer || this.getOptionLabel, ValueComponent = this.props.valueComponent;
                if (!valueArray.length) return this.state.inputValue ? null : _react2.default.createElement("div", {
                    className: "Select-placeholder"
                }, this.props.placeholder);
                var onClick = this.props.onValueClick ? this.handleValueClick : null;
                return this.props.multi ? valueArray.map(function(value, i) {
                    return _react2.default.createElement(ValueComponent, {
                        id: _this4._instancePrefix + "-value-" + i,
                        instancePrefix: _this4._instancePrefix,
                        disabled: _this4.props.disabled || value.clearableValue === !1,
                        key: "value-" + i + "-" + value[_this4.props.valueKey],
                        onClick: onClick,
                        onRemove: _this4.removeValue,
                        value: value
                    }, renderLabel(value, i), _react2.default.createElement("span", {
                        className: "Select-aria-only"
                    }, ""));
                }) : this.state.inputValue ? void 0 : (isOpen && (onClick = null), _react2.default.createElement(ValueComponent, {
                    id: this._instancePrefix + "-value-item",
                    disabled: this.props.disabled,
                    instancePrefix: this._instancePrefix,
                    onClick: onClick,
                    value: valueArray[0]
                }, renderLabel(valueArray[0])));
            },
            renderInput: function(valueArray, focusedOptionIndex) {
                var _classNames, _this5 = this, className = (0, _classnames2.default)("Select-input", this.props.inputProps.className), isOpen = !!this.state.isOpen, ariaOwns = (0, 
                _classnames2.default)((_classNames = {}, _defineProperty(_classNames, this._instancePrefix + "-list", isOpen), 
                _defineProperty(_classNames, this._instancePrefix + "-backspace-remove-message", this.props.multi && !this.props.disabled && this.state.isFocused && !this.state.inputValue), 
                _classNames)), inputProps = _extends({}, this.props.inputProps, {
                    role: "combobox",
                    "aria-expanded": "" + isOpen,
                    "aria-owns": ariaOwns,
                    "aria-haspopup": "" + isOpen,
                    "aria-activedescendant": isOpen ? this._instancePrefix + "-option-" + focusedOptionIndex : this._instancePrefix + "-value",
                    "aria-labelledby": this.props["aria-labelledby"],
                    "aria-label": this.props["aria-label"],
                    className: className,
                    tabIndex: this.props.tabIndex,
                    onBlur: this.handleInputBlur,
                    onChange: this.handleInputChange,
                    onFocus: this.handleInputFocus,
                    ref: function(_ref) {
                        return _this5.input = _ref;
                    },
                    required: this.state.required,
                    value: this.state.inputValue
                });
                if (this.props.inputRenderer) return this.props.inputRenderer(inputProps);
                if (this.props.disabled || !this.props.searchable) {
                    var _props$inputProps = this.props.inputProps, divProps = (_props$inputProps.inputClassName, 
                    _objectWithoutProperties(_props$inputProps, [ "inputClassName" ]));
                    return _react2.default.createElement("div", _extends({}, divProps, {
                        role: "combobox",
                        "aria-expanded": isOpen,
                        "aria-owns": isOpen ? this._instancePrefix + "-list" : this._instancePrefix + "-value",
                        "aria-activedescendant": isOpen ? this._instancePrefix + "-option-" + focusedOptionIndex : this._instancePrefix + "-value",
                        className: className,
                        tabIndex: this.props.tabIndex || 0,
                        onBlur: this.handleInputBlur,
                        onFocus: this.handleInputFocus,
                        ref: function(ref) {
                            return _this5.input = ref;
                        },
                        "aria-readonly": "" + !!this.props.disabled,
                        style: {
                            border: 0,
                            width: 1,
                            display: "inline-block"
                        }
                    }));
                }
                return this.props.autosize ? _react2.default.createElement(_reactInputAutosize2.default, _extends({}, inputProps, {
                    minWidth: "5"
                })) : _react2.default.createElement("div", {
                    className: className
                }, _react2.default.createElement("input", inputProps));
            },
            renderClear: function() {
                if (this.props.clearable && this.props.value && 0 !== this.props.value && (!this.props.multi || this.props.value.length) && !this.props.disabled && !this.props.isLoading) {
                    var clear = this.props.clearRenderer();
                    return _react2.default.createElement("span", {
                        className: "Select-clear-zone",
                        title: this.props.multi ? this.props.clearAllText : this.props.clearValueText,
                        "aria-label": this.props.multi ? this.props.clearAllText : this.props.clearValueText,
                        onMouseDown: this.clearValue,
                        onTouchStart: this.handleTouchStart,
                        onTouchMove: this.handleTouchMove,
                        onTouchEnd: this.handleTouchEndClearValue
                    }, clear);
                }
            },
            renderArrow: function() {
                var onMouseDown = this.handleMouseDownOnArrow, isOpen = this.state.isOpen, arrow = this.props.arrowRenderer({
                    onMouseDown: onMouseDown,
                    isOpen: isOpen
                });
                return _react2.default.createElement("span", {
                    className: "Select-arrow-zone",
                    onMouseDown: onMouseDown
                }, arrow);
            },
            filterOptions: function filterOptions(excludeOptions) {
                var filterValue = this.state.inputValue, options = this.props.options || [];
                if (this.props.filterOptions) {
                    // Maintain backwards compatibility with boolean attribute
                    var filterOptions = "function" == typeof this.props.filterOptions ? this.props.filterOptions : _utilsDefaultFilterOptions2.default;
                    return filterOptions(options, filterValue, excludeOptions, {
                        filterOption: this.props.filterOption,
                        ignoreAccents: this.props.ignoreAccents,
                        ignoreCase: this.props.ignoreCase,
                        labelKey: this.props.labelKey,
                        matchPos: this.props.matchPos,
                        matchProp: this.props.matchProp,
                        valueKey: this.props.valueKey
                    });
                }
                return options;
            },
            onOptionRef: function(ref, isFocused) {
                isFocused && (this.focused = ref);
            },
            renderMenu: function(options, valueArray, focusedOption) {
                return options && options.length ? this.props.menuRenderer({
                    focusedOption: focusedOption,
                    focusOption: this.focusOption,
                    instancePrefix: this._instancePrefix,
                    labelKey: this.props.labelKey,
                    onFocus: this.focusOption,
                    onSelect: this.selectValue,
                    optionClassName: this.props.optionClassName,
                    optionComponent: this.props.optionComponent,
                    optionRenderer: this.props.optionRenderer || this.getOptionLabel,
                    options: options,
                    selectValue: this.selectValue,
                    valueArray: valueArray,
                    valueKey: this.props.valueKey,
                    onOptionRef: this.onOptionRef
                }) : this.props.noResultsText ? _react2.default.createElement("div", {
                    className: "Select-noresults"
                }, this.props.noResultsText) : null;
            },
            renderHiddenField: function(valueArray) {
                var _this6 = this;
                if (this.props.name) {
                    if (this.props.joinValues) {
                        var value = valueArray.map(function(i) {
                            return stringifyValue(i[_this6.props.valueKey]);
                        }).join(this.props.delimiter);
                        return _react2.default.createElement("input", {
                            type: "hidden",
                            ref: function(ref) {
                                return _this6.value = ref;
                            },
                            name: this.props.name,
                            value: value,
                            disabled: this.props.disabled
                        });
                    }
                    return valueArray.map(function(item, index) {
                        return _react2.default.createElement("input", {
                            key: "hidden." + index,
                            type: "hidden",
                            ref: "value" + index,
                            name: _this6.props.name,
                            value: stringifyValue(item[_this6.props.valueKey]),
                            disabled: _this6.props.disabled
                        });
                    });
                }
            },
            getFocusableOptionIndex: function(selectedOption) {
                var options = this._visibleOptions;
                if (!options.length) return null;
                var focusedOption = this.state.focusedOption || selectedOption;
                if (focusedOption && !focusedOption.disabled) {
                    var focusedOptionIndex = options.indexOf(focusedOption);
                    if (focusedOptionIndex !== -1) return focusedOptionIndex;
                }
                for (var i = 0; i < options.length; i++) if (!options[i].disabled) return i;
                return null;
            },
            renderOuter: function(options, valueArray, focusedOption) {
                var _this7 = this, menu = this.renderMenu(options, valueArray, focusedOption);
                return menu ? _react2.default.createElement("div", {
                    ref: function(ref) {
                        return _this7.menuContainer = ref;
                    },
                    className: "Select-menu-outer",
                    style: this.props.menuContainerStyle
                }, _react2.default.createElement("div", {
                    ref: function(ref) {
                        return _this7.menu = ref;
                    },
                    role: "listbox",
                    className: "Select-menu",
                    id: this._instancePrefix + "-list",
                    style: this.props.menuStyle,
                    onScroll: this.handleMenuScroll,
                    onMouseDown: this.handleMouseDownOnMenu
                }, menu)) : null;
            },
            render: function() {
                var _this8 = this, valueArray = this.getValueArray(this.props.value), options = this._visibleOptions = this.filterOptions(this.props.multi ? this.getValueArray(this.props.value) : null), isOpen = this.state.isOpen;
                this.props.multi && !options.length && valueArray.length && !this.state.inputValue && (isOpen = !1);
                var focusedOptionIndex = this.getFocusableOptionIndex(valueArray[0]), focusedOption = null;
                focusedOption = null !== focusedOptionIndex ? this._focusedOption = options[focusedOptionIndex] : this._focusedOption = null;
                var className = (0, _classnames2.default)("Select", this.props.className, {
                    "Select--multi": this.props.multi,
                    "Select--single": !this.props.multi,
                    "is-disabled": this.props.disabled,
                    "is-focused": this.state.isFocused,
                    "is-loading": this.props.isLoading,
                    "is-open": isOpen,
                    "is-pseudo-focused": this.state.isPseudoFocused,
                    "is-searchable": this.props.searchable,
                    "has-value": valueArray.length
                }), removeMessage = null;
                return this.props.multi && !this.props.disabled && valueArray.length && !this.state.inputValue && this.state.isFocused && this.props.backspaceRemoves && (removeMessage = _react2.default.createElement("span", {
                    id: this._instancePrefix + "-backspace-remove-message",
                    className: "Select-aria-only",
                    "aria-live": "assertive"
                }, this.props.backspaceToRemoveMessage.replace("{label}", valueArray[valueArray.length - 1][this.props.labelKey]))), 
                _react2.default.createElement("div", {
                    ref: function(ref) {
                        return _this8.wrapper = ref;
                    },
                    className: className,
                    style: this.props.wrapperStyle
                }, this.renderHiddenField(valueArray), _react2.default.createElement("div", {
                    ref: function(ref) {
                        return _this8.control = ref;
                    },
                    className: "Select-control",
                    style: this.props.style,
                    onKeyDown: this.handleKeyDown,
                    onMouseDown: this.handleMouseDown,
                    onTouchEnd: this.handleTouchEnd,
                    onTouchStart: this.handleTouchStart,
                    onTouchMove: this.handleTouchMove
                }, _react2.default.createElement("span", {
                    className: "Select-multi-value-wrapper",
                    id: this._instancePrefix + "-value"
                }, this.renderValue(valueArray, isOpen), this.renderInput(valueArray, focusedOptionIndex)), removeMessage, this.renderLoading(), this.renderClear(), this.renderArrow()), isOpen ? this.renderOuter(options, this.props.multi ? null : valueArray, focusedOption) : null);
            }
        });
        exports.default = Select, module.exports = exports.default;
    }, /* 198 */
    /***/
    function(module, exports) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_198__;
    }, /* 199 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, React = __webpack_require__(109), sizerStyle = {
            position: "absolute",
            top: 0,
            left: 0,
            visibility: "hidden",
            height: 0,
            overflow: "scroll",
            whiteSpace: "pre"
        }, AutosizeInput = React.createClass({
            displayName: "AutosizeInput",
            propTypes: {
                className: React.PropTypes.string,
                // className for the outer element
                defaultValue: React.PropTypes.any,
                // default field value
                inputClassName: React.PropTypes.string,
                // className for the input element
                inputStyle: React.PropTypes.object,
                // css styles for the input element
                minWidth: React.PropTypes.oneOfType([ // minimum width for input element
                React.PropTypes.number, React.PropTypes.string ]),
                onChange: React.PropTypes.func,
                // onChange handler: function(newValue) {}
                placeholder: React.PropTypes.string,
                // placeholder text
                placeholderIsMinWidth: React.PropTypes.bool,
                // don't collapse size to less than the placeholder
                style: React.PropTypes.object,
                // css styles for the outer element
                value: React.PropTypes.any
            },
            // field value
            getDefaultProps: function() {
                return {
                    minWidth: 1
                };
            },
            getInitialState: function() {
                return {
                    inputWidth: this.props.minWidth
                };
            },
            componentDidMount: function() {
                this.copyInputStyles(), this.updateInputWidth();
            },
            componentDidUpdate: function() {
                this.updateInputWidth();
            },
            copyInputStyles: function() {
                if (this.isMounted() && window.getComputedStyle) {
                    var inputStyle = window.getComputedStyle(this.refs.input);
                    if (inputStyle) {
                        var widthNode = this.refs.sizer;
                        if (widthNode.style.fontSize = inputStyle.fontSize, widthNode.style.fontFamily = inputStyle.fontFamily, 
                        widthNode.style.fontWeight = inputStyle.fontWeight, widthNode.style.fontStyle = inputStyle.fontStyle, 
                        widthNode.style.letterSpacing = inputStyle.letterSpacing, this.props.placeholder) {
                            var placeholderNode = this.refs.placeholderSizer;
                            placeholderNode.style.fontSize = inputStyle.fontSize, placeholderNode.style.fontFamily = inputStyle.fontFamily, 
                            placeholderNode.style.fontWeight = inputStyle.fontWeight, placeholderNode.style.fontStyle = inputStyle.fontStyle, 
                            placeholderNode.style.letterSpacing = inputStyle.letterSpacing;
                        }
                    }
                }
            },
            updateInputWidth: function() {
                if (this.isMounted() && "undefined" != typeof this.refs.sizer.scrollWidth) {
                    var newInputWidth = void 0;
                    newInputWidth = this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth) ? Math.max(this.refs.sizer.scrollWidth, this.refs.placeholderSizer.scrollWidth) + 2 : this.refs.sizer.scrollWidth + 2, 
                    newInputWidth < this.props.minWidth && (newInputWidth = this.props.minWidth), newInputWidth !== this.state.inputWidth && this.setState({
                        inputWidth: newInputWidth
                    });
                }
            },
            getInput: function() {
                return this.refs.input;
            },
            focus: function() {
                this.refs.input.focus();
            },
            blur: function() {
                this.refs.input.blur();
            },
            select: function() {
                this.refs.input.select();
            },
            render: function() {
                var sizerValue = this.props.defaultValue || this.props.value || "", wrapperStyle = this.props.style || {};
                wrapperStyle.display || (wrapperStyle.display = "inline-block");
                var inputStyle = _extends({}, this.props.inputStyle);
                inputStyle.width = this.state.inputWidth + "px", inputStyle.boxSizing = "content-box";
                var inputProps = _extends({}, this.props);
                // ensure props meant for `AutosizeInput` don't end up on the `input`
                return inputProps.className = this.props.inputClassName, inputProps.style = inputStyle, 
                delete inputProps.inputClassName, delete inputProps.inputStyle, delete inputProps.minWidth, 
                delete inputProps.placeholderIsMinWidth, React.createElement("div", {
                    className: this.props.className,
                    style: wrapperStyle
                }, React.createElement("input", _extends({}, inputProps, {
                    ref: "input"
                })), React.createElement("div", {
                    ref: "sizer",
                    style: sizerStyle
                }, sizerValue), this.props.placeholder ? React.createElement("div", {
                    ref: "placeholderSizer",
                    style: sizerStyle
                }, this.props.placeholder) : null);
            }
        });
        module.exports = AutosizeInput;
    }, /* 200 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function arrowRenderer(_ref) {
            var onMouseDown = _ref.onMouseDown;
            return _react2.default.createElement("span", {
                className: "Select-arrow",
                onMouseDown: onMouseDown
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = arrowRenderer;
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react);
        module.exports = exports.default;
    }, /* 201 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function filterOptions(options, filterValue, excludeOptions, props) {
            var _this = this;
            return props.ignoreAccents && (filterValue = (0, _stripDiacritics2.default)(filterValue)), 
            props.ignoreCase && (filterValue = filterValue.toLowerCase()), excludeOptions && (excludeOptions = excludeOptions.map(function(i) {
                return i[props.valueKey];
            })), options.filter(function(option) {
                if (excludeOptions && excludeOptions.indexOf(option[props.valueKey]) > -1) return !1;
                if (props.filterOption) return props.filterOption.call(_this, option, filterValue);
                if (!filterValue) return !0;
                var valueTest = String(option[props.valueKey]), labelTest = String(option[props.labelKey]);
                return props.ignoreAccents && ("label" !== props.matchProp && (valueTest = (0, _stripDiacritics2.default)(valueTest)), 
                "value" !== props.matchProp && (labelTest = (0, _stripDiacritics2.default)(labelTest))), 
                props.ignoreCase && ("label" !== props.matchProp && (valueTest = valueTest.toLowerCase()), 
                "value" !== props.matchProp && (labelTest = labelTest.toLowerCase())), "start" === props.matchPos ? "label" !== props.matchProp && valueTest.substr(0, filterValue.length) === filterValue || "value" !== props.matchProp && labelTest.substr(0, filterValue.length) === filterValue : "label" !== props.matchProp && valueTest.indexOf(filterValue) >= 0 || "value" !== props.matchProp && labelTest.indexOf(filterValue) >= 0;
            });
        }
        var _stripDiacritics = __webpack_require__(202), _stripDiacritics2 = _interopRequireDefault(_stripDiacritics);
        module.exports = filterOptions;
    }, /* 202 */
    /***/
    function(module, exports) {
        "use strict";
        var map = [ {
            base: "A",
            letters: /[\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F]/g
        }, {
            base: "AA",
            letters: /[\uA732]/g
        }, {
            base: "AE",
            letters: /[\u00C6\u01FC\u01E2]/g
        }, {
            base: "AO",
            letters: /[\uA734]/g
        }, {
            base: "AU",
            letters: /[\uA736]/g
        }, {
            base: "AV",
            letters: /[\uA738\uA73A]/g
        }, {
            base: "AY",
            letters: /[\uA73C]/g
        }, {
            base: "B",
            letters: /[\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181]/g
        }, {
            base: "C",
            letters: /[\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E]/g
        }, {
            base: "D",
            letters: /[\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779]/g
        }, {
            base: "DZ",
            letters: /[\u01F1\u01C4]/g
        }, {
            base: "Dz",
            letters: /[\u01F2\u01C5]/g
        }, {
            base: "E",
            letters: /[\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E]/g
        }, {
            base: "F",
            letters: /[\u0046\u24BB\uFF26\u1E1E\u0191\uA77B]/g
        }, {
            base: "G",
            letters: /[\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E]/g
        }, {
            base: "H",
            letters: /[\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D]/g
        }, {
            base: "I",
            letters: /[\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197]/g
        }, {
            base: "J",
            letters: /[\u004A\u24BF\uFF2A\u0134\u0248]/g
        }, {
            base: "K",
            letters: /[\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2]/g
        }, {
            base: "L",
            letters: /[\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780]/g
        }, {
            base: "LJ",
            letters: /[\u01C7]/g
        }, {
            base: "Lj",
            letters: /[\u01C8]/g
        }, {
            base: "M",
            letters: /[\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C]/g
        }, {
            base: "N",
            letters: /[\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4]/g
        }, {
            base: "NJ",
            letters: /[\u01CA]/g
        }, {
            base: "Nj",
            letters: /[\u01CB]/g
        }, {
            base: "O",
            letters: /[\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C]/g
        }, {
            base: "OI",
            letters: /[\u01A2]/g
        }, {
            base: "OO",
            letters: /[\uA74E]/g
        }, {
            base: "OU",
            letters: /[\u0222]/g
        }, {
            base: "P",
            letters: /[\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754]/g
        }, {
            base: "Q",
            letters: /[\u0051\u24C6\uFF31\uA756\uA758\u024A]/g
        }, {
            base: "R",
            letters: /[\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782]/g
        }, {
            base: "S",
            letters: /[\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784]/g
        }, {
            base: "T",
            letters: /[\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786]/g
        }, {
            base: "TZ",
            letters: /[\uA728]/g
        }, {
            base: "U",
            letters: /[\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244]/g
        }, {
            base: "V",
            letters: /[\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245]/g
        }, {
            base: "VY",
            letters: /[\uA760]/g
        }, {
            base: "W",
            letters: /[\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72]/g
        }, {
            base: "X",
            letters: /[\u0058\u24CD\uFF38\u1E8A\u1E8C]/g
        }, {
            base: "Y",
            letters: /[\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE]/g
        }, {
            base: "Z",
            letters: /[\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762]/g
        }, {
            base: "a",
            letters: /[\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250]/g
        }, {
            base: "aa",
            letters: /[\uA733]/g
        }, {
            base: "ae",
            letters: /[\u00E6\u01FD\u01E3]/g
        }, {
            base: "ao",
            letters: /[\uA735]/g
        }, {
            base: "au",
            letters: /[\uA737]/g
        }, {
            base: "av",
            letters: /[\uA739\uA73B]/g
        }, {
            base: "ay",
            letters: /[\uA73D]/g
        }, {
            base: "b",
            letters: /[\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253]/g
        }, {
            base: "c",
            letters: /[\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184]/g
        }, {
            base: "d",
            letters: /[\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A]/g
        }, {
            base: "dz",
            letters: /[\u01F3\u01C6]/g
        }, {
            base: "e",
            letters: /[\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD]/g
        }, {
            base: "f",
            letters: /[\u0066\u24D5\uFF46\u1E1F\u0192\uA77C]/g
        }, {
            base: "g",
            letters: /[\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F]/g
        }, {
            base: "h",
            letters: /[\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265]/g
        }, {
            base: "hv",
            letters: /[\u0195]/g
        }, {
            base: "i",
            letters: /[\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131]/g
        }, {
            base: "j",
            letters: /[\u006A\u24D9\uFF4A\u0135\u01F0\u0249]/g
        }, {
            base: "k",
            letters: /[\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3]/g
        }, {
            base: "l",
            letters: /[\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747]/g
        }, {
            base: "lj",
            letters: /[\u01C9]/g
        }, {
            base: "m",
            letters: /[\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F]/g
        }, {
            base: "n",
            letters: /[\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5]/g
        }, {
            base: "nj",
            letters: /[\u01CC]/g
        }, {
            base: "o",
            letters: /[\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275]/g
        }, {
            base: "oi",
            letters: /[\u01A3]/g
        }, {
            base: "ou",
            letters: /[\u0223]/g
        }, {
            base: "oo",
            letters: /[\uA74F]/g
        }, {
            base: "p",
            letters: /[\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755]/g
        }, {
            base: "q",
            letters: /[\u0071\u24E0\uFF51\u024B\uA757\uA759]/g
        }, {
            base: "r",
            letters: /[\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783]/g
        }, {
            base: "s",
            letters: /[\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B]/g
        }, {
            base: "t",
            letters: /[\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787]/g
        }, {
            base: "tz",
            letters: /[\uA729]/g
        }, {
            base: "u",
            letters: /[\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289]/g
        }, {
            base: "v",
            letters: /[\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C]/g
        }, {
            base: "vy",
            letters: /[\uA761]/g
        }, {
            base: "w",
            letters: /[\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73]/g
        }, {
            base: "x",
            letters: /[\u0078\u24E7\uFF58\u1E8B\u1E8D]/g
        }, {
            base: "y",
            letters: /[\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF]/g
        }, {
            base: "z",
            letters: /[\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763]/g
        } ];
        module.exports = function(str) {
            for (var i = 0; i < map.length; i++) str = str.replace(map[i].letters, map[i].base);
            return str;
        };
    }, /* 203 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function menuRenderer(_ref) {
            var focusedOption = _ref.focusedOption, instancePrefix = _ref.instancePrefix, onFocus = (_ref.labelKey, 
            _ref.onFocus), onSelect = _ref.onSelect, optionClassName = _ref.optionClassName, optionComponent = _ref.optionComponent, optionRenderer = _ref.optionRenderer, options = _ref.options, valueArray = _ref.valueArray, valueKey = _ref.valueKey, onOptionRef = _ref.onOptionRef, Option = optionComponent;
            return options.map(function(option, i) {
                var isSelected = valueArray && valueArray.indexOf(option) > -1, isFocused = option === focusedOption, optionClass = (0, 
                _classnames2.default)(optionClassName, {
                    "Select-option": !0,
                    "is-selected": isSelected,
                    "is-focused": isFocused,
                    "is-disabled": option.disabled
                });
                return _react2.default.createElement(Option, {
                    className: optionClass,
                    instancePrefix: instancePrefix,
                    isDisabled: option.disabled,
                    isFocused: isFocused,
                    isSelected: isSelected,
                    key: "option-" + i + "-" + option[valueKey],
                    onFocus: onFocus,
                    onSelect: onSelect,
                    option: option,
                    optionIndex: i,
                    ref: function(ref) {
                        onOptionRef(ref, isFocused);
                    }
                }, optionRenderer(option, i));
            });
        }
        var _classnames = __webpack_require__(111), _classnames2 = _interopRequireDefault(_classnames), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react);
        module.exports = menuRenderer;
    }, /* 204 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function clearRenderer() {
            return _react2.default.createElement("span", {
                className: "Select-clear",
                dangerouslySetInnerHTML: {
                    __html: "&times;"
                }
            });
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = clearRenderer;
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react);
        module.exports = exports.default;
    }, /* 205 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _defineProperty(obj, key, value) {
            return key in obj ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : obj[key] = value, obj;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        function defaultChildren(props) {
            return _react2.default.createElement(_Select2.default, props);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _get = function(_x, _x2, _x3) {
            for (var _again = !0; _again; ) {
                var object = _x, property = _x2, receiver = _x3;
                _again = !1, null === object && (object = Function.prototype);
                var desc = Object.getOwnPropertyDescriptor(object, property);
                if (void 0 !== desc) {
                    if ("value" in desc) return desc.value;
                    var getter = desc.get;
                    if (void 0 === getter) return;
                    return getter.call(receiver);
                }
                var parent = Object.getPrototypeOf(object);
                if (null === parent) return;
                _x = parent, _x2 = property, _x3 = receiver, _again = !0, desc = parent = void 0;
            }
        }, _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _Select = __webpack_require__(197), _Select2 = _interopRequireDefault(_Select), _utilsStripDiacritics = __webpack_require__(202), _utilsStripDiacritics2 = _interopRequireDefault(_utilsStripDiacritics), propTypes = {
            autoload: _react2.default.PropTypes.bool.isRequired,
            // automatically call the `loadOptions` prop on-mount; defaults to true
            cache: _react2.default.PropTypes.any,
            // object to use to cache results; set to null/false to disable caching
            children: _react2.default.PropTypes.func.isRequired,
            // Child function responsible for creating the inner Select component; (props: Object): PropTypes.element
            ignoreAccents: _react2.default.PropTypes.bool,
            // strip diacritics when filtering; defaults to true
            ignoreCase: _react2.default.PropTypes.bool,
            // perform case-insensitive filtering; defaults to true
            loadingPlaceholder: _react2.default.PropTypes.oneOfType([ // replaces the placeholder while options are loading
            _react2.default.PropTypes.string, _react2.default.PropTypes.node ]),
            loadOptions: _react2.default.PropTypes.func.isRequired,
            // callback to load options asynchronously; (inputValue: string, callback: Function): ?Promise
            options: _react.PropTypes.array.isRequired,
            // array of options
            placeholder: _react2.default.PropTypes.oneOfType([ // field placeholder, displayed when there's no value (shared with Select)
            _react2.default.PropTypes.string, _react2.default.PropTypes.node ]),
            noResultsText: _react2.default.PropTypes.oneOfType([ // field noResultsText, displayed when no options come back from the server
            _react2.default.PropTypes.string, _react2.default.PropTypes.node ]),
            onChange: _react2.default.PropTypes.func,
            // onChange handler: function (newValue) {}
            searchPromptText: _react2.default.PropTypes.oneOfType([ // label to prompt for search input
            _react2.default.PropTypes.string, _react2.default.PropTypes.node ]),
            onInputChange: _react2.default.PropTypes.func,
            // optional for keeping track of what is being typed
            value: _react2.default.PropTypes.any
        }, defaultCache = {}, defaultProps = {
            autoload: !0,
            cache: defaultCache,
            children: defaultChildren,
            ignoreAccents: !0,
            ignoreCase: !0,
            loadingPlaceholder: "Loading...",
            options: [],
            searchPromptText: "Type to search"
        }, Async = function(_Component) {
            function Async(props, context) {
                _classCallCheck(this, Async), _get(Object.getPrototypeOf(Async.prototype), "constructor", this).call(this, props, context), 
                this._cache = props.cache === defaultCache ? {} : props.cache, this.state = {
                    isLoading: !1,
                    options: props.options
                }, this._onInputChange = this._onInputChange.bind(this);
            }
            return _inherits(Async, _Component), _createClass(Async, [ {
                key: "componentDidMount",
                value: function() {
                    var autoload = this.props.autoload;
                    autoload && this.loadOptions("");
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState) {
                    var _this = this, propertiesToSync = [ "options" ];
                    propertiesToSync.forEach(function(prop) {
                        _this.props[prop] !== nextProps[prop] && _this.setState(_defineProperty({}, prop, nextProps[prop]));
                    });
                }
            }, {
                key: "clearOptions",
                value: function() {
                    this.setState({
                        options: []
                    });
                }
            }, {
                key: "loadOptions",
                value: function loadOptions(inputValue) {
                    var _this2 = this, loadOptions = this.props.loadOptions, cache = this._cache;
                    if (cache && cache.hasOwnProperty(inputValue)) return void this.setState({
                        options: cache[inputValue]
                    });
                    var callback = function callback(error, data) {
                        if (callback === _this2._callback) {
                            _this2._callback = null;
                            var options = data && data.options || [];
                            cache && (cache[inputValue] = options), _this2.setState({
                                isLoading: !1,
                                options: options
                            });
                        }
                    };
                    // Ignore all but the most recent request
                    this._callback = callback;
                    var promise = loadOptions(inputValue, callback);
                    return promise && promise.then(function(data) {
                        return callback(null, data);
                    }, function(error) {
                        return callback(error);
                    }), this._callback && !this.state.isLoading && this.setState({
                        isLoading: !0
                    }), inputValue;
                }
            }, {
                key: "_onInputChange",
                value: function(inputValue) {
                    var _props = this.props, ignoreAccents = _props.ignoreAccents, ignoreCase = _props.ignoreCase, onInputChange = _props.onInputChange;
                    return ignoreAccents && (inputValue = (0, _utilsStripDiacritics2.default)(inputValue)), 
                    ignoreCase && (inputValue = inputValue.toLowerCase()), onInputChange && onInputChange(inputValue), 
                    this.loadOptions(inputValue);
                }
            }, {
                key: "inputValue",
                value: function() {
                    return this.select ? this.select.state.inputValue : "";
                }
            }, {
                key: "noResultsText",
                value: function noResultsText() {
                    var _props2 = this.props, loadingPlaceholder = _props2.loadingPlaceholder, noResultsText = _props2.noResultsText, searchPromptText = _props2.searchPromptText, isLoading = this.state.isLoading, inputValue = this.inputValue();
                    return isLoading ? loadingPlaceholder : inputValue && noResultsText ? noResultsText : searchPromptText;
                }
            }, {
                key: "focus",
                value: function() {
                    this.select.focus();
                }
            }, {
                key: "render",
                value: function() {
                    var _this3 = this, _props3 = this.props, children = _props3.children, loadingPlaceholder = _props3.loadingPlaceholder, placeholder = _props3.placeholder, _state = this.state, isLoading = _state.isLoading, options = _state.options, props = {
                        noResultsText: this.noResultsText(),
                        placeholder: isLoading ? loadingPlaceholder : placeholder,
                        options: isLoading && loadingPlaceholder ? [] : options,
                        ref: function(_ref) {
                            return _this3.select = _ref;
                        },
                        onChange: function(newValues) {
                            _this3.props.multi && _this3.props.value && newValues.length > _this3.props.value.length && _this3.clearOptions(), 
                            _this3.props.onChange(newValues);
                        }
                    };
                    return children(_extends({}, this.props, props, {
                        isLoading: isLoading,
                        onInputChange: this._onInputChange
                    }));
                }
            } ]), Async;
        }(_react.Component);
        exports.default = Async, Async.propTypes = propTypes, Async.defaultProps = defaultProps, 
        module.exports = exports.default;
    }, /* 206 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function reduce(obj) {
            var props = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1];
            return Object.keys(obj).reduce(function(props, key) {
                var value = obj[key];
                return void 0 !== value && (props[key] = value), props;
            }, props);
        }
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _Select = __webpack_require__(197), _Select2 = _interopRequireDefault(_Select), AsyncCreatable = _react2.default.createClass({
            displayName: "AsyncCreatableSelect",
            render: function() {
                var _this = this;
                return _react2.default.createElement(_Select2.default.Async, this.props, function(asyncProps) {
                    return _react2.default.createElement(_Select2.default.Creatable, _this.props, function(creatableProps) {
                        return _react2.default.createElement(_Select2.default, _extends({}, reduce(asyncProps, reduce(creatableProps, {})), {
                            onInputChange: function(input) {
                                return creatableProps.onInputChange(input), asyncProps.onInputChange(input);
                            },
                            ref: function(ref) {
                                creatableProps.ref(ref), asyncProps.ref(ref);
                            }
                        }));
                    });
                });
            }
        });
        module.exports = AsyncCreatable;
    }, /* 207 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function defaultChildren(props) {
            return _react2.default.createElement(_Select2.default, props);
        }
        function isOptionUnique(_ref3) {
            var option = _ref3.option, options = _ref3.options, labelKey = _ref3.labelKey, valueKey = _ref3.valueKey;
            return 0 === options.filter(function(existingOption) {
                return existingOption[labelKey] === option[labelKey] || existingOption[valueKey] === option[valueKey];
            }).length;
        }
        function isValidNewOption(_ref4) {
            var label = _ref4.label;
            return !!label;
        }
        function newOptionCreator(_ref5) {
            var label = _ref5.label, labelKey = _ref5.labelKey, valueKey = _ref5.valueKey, option = {};
            return option[valueKey] = label, option[labelKey] = label, option.className = "Select-create-option-placeholder", 
            option;
        }
        function promptTextCreator(label) {
            return 'Create option "' + label + '"';
        }
        function shouldKeyDownEventCreateNewOption(_ref6) {
            var keyCode = _ref6.keyCode;
            switch (keyCode) {
              case 9:
              // TAB
                case 13:
              // ENTER
                case 188:
                // COMMA
                return !0;
            }
            return !1;
        }
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _Select = __webpack_require__(197), _Select2 = _interopRequireDefault(_Select), _utilsDefaultFilterOptions = __webpack_require__(201), _utilsDefaultFilterOptions2 = _interopRequireDefault(_utilsDefaultFilterOptions), _utilsDefaultMenuRenderer = __webpack_require__(203), _utilsDefaultMenuRenderer2 = _interopRequireDefault(_utilsDefaultMenuRenderer), Creatable = _react2.default.createClass({
            displayName: "CreatableSelect",
            propTypes: {
                // Child function responsible for creating the inner Select component
                // This component can be used to compose HOCs (eg Creatable and Async)
                // (props: Object): PropTypes.element
                children: _react2.default.PropTypes.func,
                // See Select.propTypes.filterOptions
                filterOptions: _react2.default.PropTypes.any,
                // Searches for any matching option within the set of options.
                // This function prevents duplicate options from being created.
                // ({ option: Object, options: Array, labelKey: string, valueKey: string }): boolean
                isOptionUnique: _react2.default.PropTypes.func,
                // Determines if the current input text represents a valid option.
                // ({ label: string }): boolean
                isValidNewOption: _react2.default.PropTypes.func,
                // See Select.propTypes.menuRenderer
                menuRenderer: _react2.default.PropTypes.any,
                // Factory to create new option.
                // ({ label: string, labelKey: string, valueKey: string }): Object
                newOptionCreator: _react2.default.PropTypes.func,
                // input change handler: function (inputValue) {}
                onInputChange: _react2.default.PropTypes.func,
                // input keyDown handler: function (event) {}
                onInputKeyDown: _react2.default.PropTypes.func,
                // new option click handler: function (option) {}
                onNewOptionClick: _react2.default.PropTypes.func,
                // See Select.propTypes.options
                options: _react2.default.PropTypes.array,
                // Creates prompt/placeholder option text.
                // (filterText: string): string
                promptTextCreator: _react2.default.PropTypes.func,
                // Decides if a keyDown event (eg its `keyCode`) should result in the creation of a new option.
                shouldKeyDownEventCreateNewOption: _react2.default.PropTypes.func
            },
            // Default prop methods
            statics: {
                isOptionUnique: isOptionUnique,
                isValidNewOption: isValidNewOption,
                newOptionCreator: newOptionCreator,
                promptTextCreator: promptTextCreator,
                shouldKeyDownEventCreateNewOption: shouldKeyDownEventCreateNewOption
            },
            getDefaultProps: function() {
                return {
                    filterOptions: _utilsDefaultFilterOptions2.default,
                    isOptionUnique: isOptionUnique,
                    isValidNewOption: isValidNewOption,
                    menuRenderer: _utilsDefaultMenuRenderer2.default,
                    newOptionCreator: newOptionCreator,
                    promptTextCreator: promptTextCreator,
                    shouldKeyDownEventCreateNewOption: shouldKeyDownEventCreateNewOption
                };
            },
            createNewOption: function() {
                var _props = this.props, isValidNewOption = _props.isValidNewOption, newOptionCreator = _props.newOptionCreator, onNewOptionClick = _props.onNewOptionClick, _props$options = _props.options, options = void 0 === _props$options ? [] : _props$options;
                _props.shouldKeyDownEventCreateNewOption;
                if (isValidNewOption({
                    label: this.inputValue
                })) {
                    var option = newOptionCreator({
                        label: this.inputValue,
                        labelKey: this.labelKey,
                        valueKey: this.valueKey
                    }), _isOptionUnique = this.isOptionUnique({
                        option: option
                    });
                    // Don't add the same option twice.
                    _isOptionUnique && (onNewOptionClick ? onNewOptionClick(option) : (options.unshift(option), 
                    this.select.selectValue(option)));
                }
            },
            filterOptions: function filterOptions() {
                var _props2 = this.props, filterOptions = _props2.filterOptions, isValidNewOption = _props2.isValidNewOption, promptTextCreator = (_props2.options, 
                _props2.promptTextCreator), excludeOptions = arguments[2] || [], filteredOptions = filterOptions.apply(void 0, arguments) || [];
                if (isValidNewOption({
                    label: this.inputValue
                })) {
                    var _newOptionCreator = this.props.newOptionCreator, option = _newOptionCreator({
                        label: this.inputValue,
                        labelKey: this.labelKey,
                        valueKey: this.valueKey
                    }), _isOptionUnique2 = this.isOptionUnique({
                        option: option,
                        options: excludeOptions.concat(filteredOptions)
                    });
                    if (_isOptionUnique2) {
                        var _prompt = promptTextCreator(this.inputValue);
                        this._createPlaceholderOption = _newOptionCreator({
                            label: _prompt,
                            labelKey: this.labelKey,
                            valueKey: this.valueKey
                        }), filteredOptions.unshift(this._createPlaceholderOption);
                    }
                }
                return filteredOptions;
            },
            isOptionUnique: function isOptionUnique(_ref2) {
                var option = _ref2.option, options = _ref2.options, isOptionUnique = this.props.isOptionUnique;
                return options = options || this.select.filterOptions(), isOptionUnique({
                    labelKey: this.labelKey,
                    option: option,
                    options: options,
                    valueKey: this.valueKey
                });
            },
            menuRenderer: function menuRenderer(params) {
                var menuRenderer = this.props.menuRenderer;
                return menuRenderer(_extends({}, params, {
                    onSelect: this.onOptionSelect,
                    selectValue: this.onOptionSelect
                }));
            },
            onInputChange: function onInputChange(input) {
                var onInputChange = this.props.onInputChange;
                onInputChange && onInputChange(input), // This value may be needed in between Select mounts (when this.select is null)
                this.inputValue = input;
            },
            onInputKeyDown: function onInputKeyDown(event) {
                var _props3 = this.props, shouldKeyDownEventCreateNewOption = _props3.shouldKeyDownEventCreateNewOption, onInputKeyDown = _props3.onInputKeyDown, focusedOption = this.select.getFocusedOption();
                focusedOption && focusedOption === this._createPlaceholderOption && shouldKeyDownEventCreateNewOption({
                    keyCode: event.keyCode
                }) ? (this.createNewOption(), // Prevent decorated Select from doing anything additional with this keyDown event
                event.preventDefault()) : onInputKeyDown && onInputKeyDown(event);
            },
            onOptionSelect: function(option, event) {
                option === this._createPlaceholderOption ? this.createNewOption() : this.select.selectValue(option);
            },
            render: function() {
                var _this = this, _props4 = this.props, restProps = (_props4.newOptionCreator, _props4.shouldKeyDownEventCreateNewOption, 
                _objectWithoutProperties(_props4, [ "newOptionCreator", "shouldKeyDownEventCreateNewOption" ])), children = this.props.children;
                // We can't use destructuring default values to set the children,
                // because it won't apply work if `children` is null. A falsy check is
                // more reliable in real world use-cases.
                children || (children = defaultChildren);
                var props = _extends({}, restProps, {
                    allowCreate: !0,
                    filterOptions: this.filterOptions,
                    menuRenderer: this.menuRenderer,
                    onInputChange: this.onInputChange,
                    onInputKeyDown: this.onInputKeyDown,
                    ref: function(_ref) {
                        _this.select = _ref, // These values may be needed in between Select mounts (when this.select is null)
                        _ref && (_this.labelKey = _ref.props.labelKey, _this.valueKey = _ref.props.valueKey);
                    }
                });
                return children(props);
            }
        });
        module.exports = Creatable;
    }, /* 208 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _classnames = __webpack_require__(111), _classnames2 = _interopRequireDefault(_classnames), Option = _react2.default.createClass({
            displayName: "Option",
            propTypes: {
                children: _react2.default.PropTypes.node,
                className: _react2.default.PropTypes.string,
                // className (based on mouse position)
                instancePrefix: _react2.default.PropTypes.string.isRequired,
                // unique prefix for the ids (used for aria)
                isDisabled: _react2.default.PropTypes.bool,
                // the option is disabled
                isFocused: _react2.default.PropTypes.bool,
                // the option is focused
                isSelected: _react2.default.PropTypes.bool,
                // the option is selected
                onFocus: _react2.default.PropTypes.func,
                // method to handle mouseEnter on option element
                onSelect: _react2.default.PropTypes.func,
                // method to handle click on option element
                onUnfocus: _react2.default.PropTypes.func,
                // method to handle mouseLeave on option element
                option: _react2.default.PropTypes.object.isRequired,
                // object that is base for that option
                optionIndex: _react2.default.PropTypes.number
            },
            // index of the option, used to generate unique ids for aria
            blockEvent: function(event) {
                event.preventDefault(), event.stopPropagation(), "A" === event.target.tagName && "href" in event.target && (event.target.target ? window.open(event.target.href, event.target.target) : window.location.href = event.target.href);
            },
            handleMouseDown: function(event) {
                event.preventDefault(), event.stopPropagation(), this.props.onSelect(this.props.option, event);
            },
            handleMouseEnter: function(event) {
                this.onFocus(event);
            },
            handleMouseMove: function(event) {
                this.onFocus(event);
            },
            handleTouchEnd: function(event) {
                // Check if the view is being dragged, In this case
                // we don't want to fire the click event (because the user only wants to scroll)
                this.dragging || this.handleMouseDown(event);
            },
            handleTouchMove: function(event) {
                // Set a flag that the view is being dragged
                this.dragging = !0;
            },
            handleTouchStart: function(event) {
                // Set a flag that the view is not being dragged
                this.dragging = !1;
            },
            onFocus: function(event) {
                this.props.isFocused || this.props.onFocus(this.props.option, event);
            },
            render: function() {
                var _props = this.props, option = _props.option, instancePrefix = _props.instancePrefix, optionIndex = _props.optionIndex, className = (0, 
                _classnames2.default)(this.props.className, option.className);
                return option.disabled ? _react2.default.createElement("div", {
                    className: className,
                    onMouseDown: this.blockEvent,
                    onClick: this.blockEvent
                }, this.props.children) : _react2.default.createElement("div", {
                    className: className,
                    style: option.style,
                    role: "option",
                    onMouseDown: this.handleMouseDown,
                    onMouseEnter: this.handleMouseEnter,
                    onMouseMove: this.handleMouseMove,
                    onTouchStart: this.handleTouchStart,
                    onTouchMove: this.handleTouchMove,
                    onTouchEnd: this.handleTouchEnd,
                    id: instancePrefix + "-option-" + optionIndex,
                    title: option.title
                }, this.props.children);
            }
        });
        module.exports = Option;
    }, /* 209 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _classnames = __webpack_require__(111), _classnames2 = _interopRequireDefault(_classnames), Value = _react2.default.createClass({
            displayName: "Value",
            propTypes: {
                children: _react2.default.PropTypes.node,
                disabled: _react2.default.PropTypes.bool,
                // disabled prop passed to ReactSelect
                id: _react2.default.PropTypes.string,
                // Unique id for the value - used for aria
                onClick: _react2.default.PropTypes.func,
                // method to handle click on value label
                onRemove: _react2.default.PropTypes.func,
                // method to handle removal of the value
                value: _react2.default.PropTypes.object.isRequired
            },
            // the option object for this value
            handleMouseDown: function(event) {
                if ("mousedown" !== event.type || 0 === event.button) return this.props.onClick ? (event.stopPropagation(), 
                void this.props.onClick(this.props.value, event)) : void (this.props.value.href && event.stopPropagation());
            },
            onRemove: function(event) {
                event.preventDefault(), event.stopPropagation(), this.props.onRemove(this.props.value);
            },
            handleTouchEndRemove: function(event) {
                // Check if the view is being dragged, In this case
                // we don't want to fire the click event (because the user only wants to scroll)
                this.dragging || // Fire the mouse events
                this.onRemove(event);
            },
            handleTouchMove: function(event) {
                // Set a flag that the view is being dragged
                this.dragging = !0;
            },
            handleTouchStart: function(event) {
                // Set a flag that the view is not being dragged
                this.dragging = !1;
            },
            renderRemoveIcon: function() {
                if (!this.props.disabled && this.props.onRemove) return _react2.default.createElement("span", {
                    className: "Select-value-icon",
                    "aria-hidden": "true",
                    onMouseDown: this.onRemove,
                    onTouchEnd: this.handleTouchEndRemove,
                    onTouchStart: this.handleTouchStart,
                    onTouchMove: this.handleTouchMove
                }, "");
            },
            renderLabel: function() {
                var className = "Select-value-label";
                return this.props.onClick || this.props.value.href ? _react2.default.createElement("a", {
                    className: className,
                    href: this.props.value.href,
                    target: this.props.value.target,
                    onMouseDown: this.handleMouseDown,
                    onTouchEnd: this.handleMouseDown
                }, this.props.children) : _react2.default.createElement("span", {
                    className: className,
                    role: "option",
                    "aria-selected": "true",
                    id: this.props.id
                }, this.props.children);
            },
            render: function() {
                return _react2.default.createElement("div", {
                    className: (0, _classnames2.default)("Select-value", this.props.value.className),
                    style: this.props.value.style,
                    title: this.props.value.title
                }, this.renderRemoveIcon(), this.renderLabel());
            }
        });
        module.exports = Value;
    }, /* 210 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.AutoSizer = exports.default = void 0;
        var _AutoSizer2 = __webpack_require__(211), _AutoSizer3 = _interopRequireDefault(_AutoSizer2);
        exports.default = _AutoSizer3.default, exports.AutoSizer = _AutoSizer3.default;
    }, /* 211 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }
            function _inherits(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                    Constructor;
                };
            }(), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _reactAddonsShallowCompare = __webpack_require__(212), _reactAddonsShallowCompare2 = _interopRequireDefault(_reactAddonsShallowCompare), _detectElementResize = __webpack_require__(215), _detectElementResize2 = _interopRequireDefault(_detectElementResize), AutoSizer = function(_Component) {
                function AutoSizer(props) {
                    _classCallCheck(this, AutoSizer);
                    var _this = _possibleConstructorReturn(this, (AutoSizer.__proto__ || Object.getPrototypeOf(AutoSizer)).call(this, props));
                    return _this.state = {
                        height: 0,
                        width: 0
                    }, _this._onResize = _this._onResize.bind(_this), _this._setRef = _this._setRef.bind(_this), 
                    _this;
                }
                return _inherits(AutoSizer, _Component), _createClass(AutoSizer, [ {
                    key: "componentDidMount",
                    value: function() {
                        // Delay access of parentNode until mount.
                        // This handles edge-cases where the component has already been unmounted before its ref has been set,
                        // As well as libraries like react-lite which have a slightly different lifecycle.
                        this._parentNode = this._autoSizer.parentNode, // Defer requiring resize handler in order to support server-side rendering.
                        // See issue #41
                        this._detectElementResize = (0, _detectElementResize2.default)(), this._detectElementResize.addResizeListener(this._parentNode, this._onResize), 
                        this._onResize();
                    }
                }, {
                    key: "componentWillUnmount",
                    value: function() {
                        this._detectElementResize && this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
                    }
                }, {
                    key: "render",
                    value: function() {
                        var _props = this.props, children = _props.children, disableHeight = _props.disableHeight, disableWidth = _props.disableWidth, _state = this.state, height = _state.height, width = _state.width, outerStyle = {
                            overflow: "visible"
                        };
                        return disableHeight || (outerStyle.height = 0), disableWidth || (outerStyle.width = 0), 
                        _react2.default.createElement("div", {
                            ref: this._setRef,
                            style: outerStyle
                        }, children({
                            height: height,
                            width: width
                        }));
                    }
                }, {
                    key: "shouldComponentUpdate",
                    value: function(nextProps, nextState) {
                        return (0, _reactAddonsShallowCompare2.default)(this, nextProps, nextState);
                    }
                }, {
                    key: "_onResize",
                    value: function() {
                        var onResize = this.props.onResize, boundingRect = this._parentNode.getBoundingClientRect(), height = boundingRect.height || 0, width = boundingRect.width || 0, style = window.getComputedStyle(this._parentNode) || {}, paddingLeft = parseInt(style.paddingLeft, 10) || 0, paddingRight = parseInt(style.paddingRight, 10) || 0, paddingTop = parseInt(style.paddingTop, 10) || 0, paddingBottom = parseInt(style.paddingBottom, 10) || 0;
                        this.setState({
                            height: height - paddingTop - paddingBottom,
                            width: width - paddingLeft - paddingRight
                        }), onResize({
                            height: height,
                            width: width
                        });
                    }
                }, {
                    key: "_setRef",
                    value: function(autoSizer) {
                        this._autoSizer = autoSizer;
                    }
                } ]), AutoSizer;
            }(_react.Component);
            AutoSizer.defaultProps = {
                onResize: function() {}
            }, exports.default = AutoSizer, "production" !== process.env.NODE_ENV ? AutoSizer.propTypes = {
                /**
	  * Function responsible for rendering children.
	  * This function should implement the following signature:
	  * ({ height, width }) => PropTypes.element
	  */
                children: _react.PropTypes.func.isRequired,
                /** Disable dynamic :height property */
                disableHeight: _react.PropTypes.bool,
                /** Disable dynamic :width property */
                disableWidth: _react.PropTypes.bool,
                /** Callback to be invoked on-resize: ({ height, width }) */
                onResize: _react.PropTypes.func.isRequired
            } : void 0;
        }).call(exports, __webpack_require__(153));
    }, /* 212 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = __webpack_require__(213);
    }, /* 213 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
        "use strict";
        /**
	 * Does a shallow comparison for props and state.
	 * See ReactComponentWithPureRenderMixin
	 * See also https://facebook.github.io/react/docs/shallow-compare.html
	 */
        function shallowCompare(instance, nextProps, nextState) {
            return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
        }
        var shallowEqual = __webpack_require__(214);
        module.exports = shallowCompare;
    }, /* 214 */
    /***/
    function(module, exports) {
        /**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * 
	 */
        /*eslint-disable no-self-compare */
        "use strict";
        /**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
        function is(x, y) {
            // SameValue algorithm
            // SameValue algorithm
            return x === y ? 0 !== x || 0 !== y || 1 / x === 1 / y : x !== x && y !== y;
        }
        /**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
        function shallowEqual(objA, objB) {
            if (is(objA, objB)) return !0;
            if ("object" != typeof objA || null === objA || "object" != typeof objB || null === objB) return !1;
            var keysA = Object.keys(objA), keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) return !1;
            // Test for A's keys different from B.
            for (var i = 0; i < keysA.length; i++) if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) return !1;
            return !0;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        module.exports = shallowEqual;
    }, /* 215 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Detect Element Resize.
	 * https://github.com/sdecima/javascript-detect-element-resize
	 * Sebastian Decima
	 *
	 * Forked from version 0.5.3; includes the following modifications:
	 * 1)Guard against unsafe 'window' and 'document' references (to support SSR).
	 * 2)Defer initialization code via a top-level function wrapper (to support SSR).
	 * 3) Avoid unnecessary reflows by not measuring size for scroll events bubbling from children.
	 **/
        function createDetectElementResize() {
            // Check `document` and `window` in case of server-side rendering
            var _window;
            _window = "undefined" != typeof window ? window : "undefined" != typeof self ? self : this;
            var attachEvent = "undefined" != typeof document && document.attachEvent;
            if (!attachEvent) {
                var requestFrame = function() {
                    var raf = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function(fn) {
                        return _window.setTimeout(fn, 20);
                    };
                    return function(fn) {
                        return raf(fn);
                    };
                }(), cancelFrame = function() {
                    var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
                    return function(id) {
                        return cancel(id);
                    };
                }(), resetTriggers = function(element) {
                    var triggers = element.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
                    contract.scrollLeft = contract.scrollWidth, contract.scrollTop = contract.scrollHeight, 
                    expandChild.style.width = expand.offsetWidth + 1 + "px", expandChild.style.height = expand.offsetHeight + 1 + "px", 
                    expand.scrollLeft = expand.scrollWidth, expand.scrollTop = expand.scrollHeight;
                }, checkTriggers = function(element) {
                    return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
                }, scrollListener = function(e) {
                    // Don't measure (which forces) reflow for scrolls that happen inside of children!
                    if (!(e.target.className.indexOf("contract-trigger") < 0 && e.target.className.indexOf("expand-trigger") < 0)) {
                        var element = this;
                        resetTriggers(this), this.__resizeRAF__ && cancelFrame(this.__resizeRAF__), this.__resizeRAF__ = requestFrame(function() {
                            checkTriggers(element) && (element.__resizeLast__.width = element.offsetWidth, element.__resizeLast__.height = element.offsetHeight, 
                            element.__resizeListeners__.forEach(function(fn) {
                                fn.call(element, e);
                            }));
                        });
                    }
                }, animation = !1, animationstring = "animation", keyframeprefix = "", animationstartevent = "animationstart", domPrefixes = "Webkit Moz O ms".split(" "), startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "), pfx = "", elm = document.createElement("fakeelement");
                if (void 0 !== elm.style.animationName && (animation = !0), animation === !1) for (var i = 0; i < domPrefixes.length; i++) if (void 0 !== elm.style[domPrefixes[i] + "AnimationName"]) {
                    pfx = domPrefixes[i], animationstring = pfx + "Animation", keyframeprefix = "-" + pfx.toLowerCase() + "-", 
                    animationstartevent = startEvents[i], animation = !0;
                    break;
                }
                var animationName = "resizeanim", animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ", animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
            }
            var createStyles = function() {
                if (!document.getElementById("detectElementResize")) {
                    //opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
                    var css = (animationKeyframes ? animationKeyframes : "") + ".resize-triggers { " + (animationStyle ? animationStyle : "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = document.head || document.getElementsByTagName("head")[0], style = document.createElement("style");
                    style.id = "detectElementResize", style.type = "text/css", style.styleSheet ? style.styleSheet.cssText = css : style.appendChild(document.createTextNode(css)), 
                    head.appendChild(style);
                }
            }, addResizeListener = function(element, fn) {
                if (attachEvent) element.attachEvent("onresize", fn); else {
                    if (!element.__resizeTriggers__) {
                        var elementStyle = _window.getComputedStyle(element);
                        elementStyle && "static" == elementStyle.position && (element.style.position = "relative"), 
                        createStyles(), element.__resizeLast__ = {}, element.__resizeListeners__ = [], (element.__resizeTriggers__ = document.createElement("div")).className = "resize-triggers", 
                        element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', 
                        element.appendChild(element.__resizeTriggers__), resetTriggers(element), element.addEventListener("scroll", scrollListener, !0), 
                        /* Listen for a css animation to detect element display/re-attach */
                        animationstartevent && (element.__resizeTriggers__.__animationListener__ = function(e) {
                            e.animationName == animationName && resetTriggers(element);
                        }, element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__));
                    }
                    element.__resizeListeners__.push(fn);
                }
            }, removeResizeListener = function(element, fn) {
                if (attachEvent) element.detachEvent("onresize", fn); else if (element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1), 
                !element.__resizeListeners__.length) {
                    element.removeEventListener("scroll", scrollListener, !0), element.__resizeTriggers__.__animationListener__ && (element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__), 
                    element.__resizeTriggers__.__animationListener__ = null);
                    try {
                        element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
                    } catch (e) {}
                }
            };
            return {
                addResizeListener: addResizeListener,
                removeResizeListener: removeResizeListener
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = createDetectElementResize;
    }, /* 216 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.List = exports.default = void 0;
        var _List2 = __webpack_require__(217), _List3 = _interopRequireDefault(_List2);
        exports.default = _List3.default, exports.List = _List3.default;
    }, /* 217 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }
            function _objectWithoutProperties(obj, keys) {
                var target = {};
                for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
                return target;
            }
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }
            function _inherits(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                    Constructor;
                };
            }(), _Grid = __webpack_require__(218), _Grid2 = _interopRequireDefault(_Grid), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _classnames = __webpack_require__(111), _classnames2 = _interopRequireDefault(_classnames), _reactAddonsShallowCompare = __webpack_require__(212), _reactAddonsShallowCompare2 = _interopRequireDefault(_reactAddonsShallowCompare), List = function(_Component) {
                function List(props, context) {
                    _classCallCheck(this, List);
                    var _this = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this, props, context));
                    return _this._cellRenderer = _this._cellRenderer.bind(_this), _this._onScroll = _this._onScroll.bind(_this), 
                    _this._onSectionRendered = _this._onSectionRendered.bind(_this), _this;
                }
                return _inherits(List, _Component), _createClass(List, [ {
                    key: "forceUpdateGrid",
                    value: function() {
                        this.Grid.forceUpdate();
                    }
                }, {
                    key: "measureAllRows",
                    value: function() {
                        this.Grid.measureAllCells();
                    }
                }, {
                    key: "recomputeRowHeights",
                    value: function() {
                        var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        this.Grid.recomputeGridSize({
                            rowIndex: index
                        });
                    }
                }, {
                    key: "scrollToRow",
                    value: function() {
                        var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        this.Grid.scrollToCell({
                            columnIndex: 0,
                            rowIndex: index
                        });
                    }
                }, {
                    key: "render",
                    value: function() {
                        var _this2 = this, _props = this.props, className = _props.className, noRowsRenderer = _props.noRowsRenderer, scrollToIndex = _props.scrollToIndex, width = _props.width, classNames = (0, 
                        _classnames2.default)("ReactVirtualized__List", className);
                        return _react2.default.createElement(_Grid2.default, _extends({}, this.props, {
                            autoContainerWidth: !0,
                            cellRenderer: this._cellRenderer,
                            className: classNames,
                            columnWidth: width,
                            columnCount: 1,
                            noContentRenderer: noRowsRenderer,
                            onScroll: this._onScroll,
                            onSectionRendered: this._onSectionRendered,
                            ref: function(_ref) {
                                _this2.Grid = _ref;
                            },
                            scrollToRow: scrollToIndex
                        }));
                    }
                }, {
                    key: "shouldComponentUpdate",
                    value: function(nextProps, nextState) {
                        return (0, _reactAddonsShallowCompare2.default)(this, nextProps, nextState);
                    }
                }, {
                    key: "_cellRenderer",
                    value: function(_ref2) {
                        var rowIndex = _ref2.rowIndex, style = _ref2.style, rest = _objectWithoutProperties(_ref2, [ "rowIndex", "style" ]), rowRenderer = this.props.rowRenderer, _Object$getOwnPropert = Object.getOwnPropertyDescriptor(style, "width"), writable = _Object$getOwnPropert.writable;
                        // By default, List cells should be 100% width.
                        // This prevents them from flowing under a scrollbar (if present).
                        return writable && (style.width = "100%"), rowRenderer(_extends({
                            index: rowIndex,
                            style: style
                        }, rest));
                    }
                }, {
                    key: "_onScroll",
                    value: function(_ref3) {
                        var clientHeight = _ref3.clientHeight, scrollHeight = _ref3.scrollHeight, scrollTop = _ref3.scrollTop, onScroll = this.props.onScroll;
                        onScroll({
                            clientHeight: clientHeight,
                            scrollHeight: scrollHeight,
                            scrollTop: scrollTop
                        });
                    }
                }, {
                    key: "_onSectionRendered",
                    value: function(_ref4) {
                        var rowOverscanStartIndex = _ref4.rowOverscanStartIndex, rowOverscanStopIndex = _ref4.rowOverscanStopIndex, rowStartIndex = _ref4.rowStartIndex, rowStopIndex = _ref4.rowStopIndex, onRowsRendered = this.props.onRowsRendered;
                        onRowsRendered({
                            overscanStartIndex: rowOverscanStartIndex,
                            overscanStopIndex: rowOverscanStopIndex,
                            startIndex: rowStartIndex,
                            stopIndex: rowStopIndex
                        });
                    }
                } ]), List;
            }(_react.Component);
            List.defaultProps = {
                estimatedRowSize: 30,
                noRowsRenderer: function() {
                    return null;
                },
                onRowsRendered: function() {
                    return null;
                },
                onScroll: function() {
                    return null;
                },
                overscanRowCount: 10,
                scrollToAlignment: "auto",
                style: {}
            }, exports.default = List, "production" !== process.env.NODE_ENV ? List.propTypes = {
                "aria-label": _react.PropTypes.string,
                /**
	   * Removes fixed height from the scrollingContainer so that the total height
	   * of rows can stretch the window. Intended for use with WindowScroller
	   */
                autoHeight: _react.PropTypes.bool,
                /** Optional CSS class name */
                className: _react.PropTypes.string,
                /**
	   * Used to estimate the total height of a List before all of its rows have actually been measured.
	   * The estimated total height is adjusted as rows are rendered.
	   */
                estimatedRowSize: _react.PropTypes.number.isRequired,
                /** Height constraint for list (determines how many actual rows are rendered) */
                height: _react.PropTypes.number.isRequired,
                /** Optional renderer to be used in place of rows when rowCount is 0 */
                noRowsRenderer: _react.PropTypes.func.isRequired,
                /**
	   * Callback invoked with information about the slice of rows that were just rendered.
	   * ({ startIndex, stopIndex }): void
	   */
                onRowsRendered: _react.PropTypes.func.isRequired,
                /**
	   * Number of rows to render above/below the visible bounds of the list.
	   * These rows can help for smoother scrolling on touch devices.
	   */
                overscanRowCount: _react.PropTypes.number.isRequired,
                /**
	   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
	   * This callback can be used to sync scrolling between lists, tables, or grids.
	   * ({ clientHeight, scrollHeight, scrollTop }): void
	   */
                onScroll: _react.PropTypes.func.isRequired,
                /**
	   * Either a fixed row height (number) or a function that returns the height of a row given its index.
	   * ({ index: number }): number
	   */
                rowHeight: _react.PropTypes.oneOfType([ _react.PropTypes.number, _react.PropTypes.func ]).isRequired,
                /** Responsible for rendering a row given an index; ({ index: number }): node */
                rowRenderer: _react.PropTypes.func.isRequired,
                /** Number of rows in list. */
                rowCount: _react.PropTypes.number.isRequired,
                /** See Grid#scrollToAlignment */
                scrollToAlignment: _react.PropTypes.oneOf([ "auto", "end", "start", "center" ]).isRequired,
                /** Row index to ensure visible (by forcefully scrolling if necessary) */
                scrollToIndex: _react.PropTypes.number,
                /** Vertical offset. */
                scrollTop: _react.PropTypes.number,
                /** Optional inline style */
                style: _react.PropTypes.object,
                /** Tab index for focus */
                tabIndex: _react.PropTypes.number,
                /** Width of list */
                width: _react.PropTypes.number.isRequired
            } : void 0;
        }).call(exports, __webpack_require__(153));
    }, /* 218 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.defaultCellRangeRenderer = exports.Grid = exports.default = void 0;
        var _Grid2 = __webpack_require__(219), _Grid3 = _interopRequireDefault(_Grid2), _defaultCellRangeRenderer2 = __webpack_require__(228), _defaultCellRangeRenderer3 = _interopRequireDefault(_defaultCellRangeRenderer2);
        exports.default = _Grid3.default, exports.Grid = _Grid3.default, exports.defaultCellRangeRenderer = _defaultCellRangeRenderer3.default;
    }, /* 219 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            }
            function _possibleConstructorReturn(self, call) {
                if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !call || "object" != typeof call && "function" != typeof call ? self : call;
            }
            function _inherits(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = void 0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                        "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                return function(Constructor, protoProps, staticProps) {
                    return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                    Constructor;
                };
            }(), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _classnames = __webpack_require__(111), _classnames2 = _interopRequireDefault(_classnames), _calculateSizeAndPositionDataAndUpdateScrollOffset = __webpack_require__(220), _calculateSizeAndPositionDataAndUpdateScrollOffset2 = _interopRequireDefault(_calculateSizeAndPositionDataAndUpdateScrollOffset), _ScalingCellSizeAndPositionManager = __webpack_require__(221), _ScalingCellSizeAndPositionManager2 = _interopRequireDefault(_ScalingCellSizeAndPositionManager), _createCallbackMemoizer = __webpack_require__(223), _createCallbackMemoizer2 = _interopRequireDefault(_createCallbackMemoizer), _getOverscanIndices = __webpack_require__(224), _getOverscanIndices2 = _interopRequireDefault(_getOverscanIndices), _scrollbarSize = __webpack_require__(225), _scrollbarSize2 = _interopRequireDefault(_scrollbarSize), _reactAddonsShallowCompare = __webpack_require__(212), _reactAddonsShallowCompare2 = _interopRequireDefault(_reactAddonsShallowCompare), _updateScrollIndexHelper = __webpack_require__(227), _updateScrollIndexHelper2 = _interopRequireDefault(_updateScrollIndexHelper), _defaultCellRangeRenderer = __webpack_require__(228), _defaultCellRangeRenderer2 = _interopRequireDefault(_defaultCellRangeRenderer), DEFAULT_SCROLLING_RESET_TIME_INTERVAL = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150, SCROLL_POSITION_CHANGE_REASONS = {
                OBSERVED: "observed",
                REQUESTED: "requested"
            }, Grid = function(_Component) {
                function Grid(props, context) {
                    _classCallCheck(this, Grid);
                    var _this = _possibleConstructorReturn(this, (Grid.__proto__ || Object.getPrototypeOf(Grid)).call(this, props, context));
                    // Invokes onSectionRendered callback only when start/stop row or column indices change
                    // Bind functions to instance so they don't lose context when passed around
                    // See defaultCellRangeRenderer() for more information on the usage of these caches
                    return _this.state = {
                        isScrolling: !1,
                        scrollDirectionHorizontal: _getOverscanIndices.SCROLL_DIRECTION_FORWARD,
                        scrollDirectionVertical: _getOverscanIndices.SCROLL_DIRECTION_FORWARD,
                        scrollLeft: 0,
                        scrollTop: 0
                    }, _this._onGridRenderedMemoizer = (0, _createCallbackMemoizer2.default)(), _this._onScrollMemoizer = (0, 
                    _createCallbackMemoizer2.default)(!1), _this._debounceScrollEndedCallback = _this._debounceScrollEndedCallback.bind(_this), 
                    _this._invokeOnGridRenderedHelper = _this._invokeOnGridRenderedHelper.bind(_this), 
                    _this._onScroll = _this._onScroll.bind(_this), _this._updateScrollLeftForScrollToColumn = _this._updateScrollLeftForScrollToColumn.bind(_this), 
                    _this._updateScrollTopForScrollToRow = _this._updateScrollTopForScrollToRow.bind(_this), 
                    _this._columnWidthGetter = _this._wrapSizeGetter(props.columnWidth), _this._rowHeightGetter = _this._wrapSizeGetter(props.rowHeight), 
                    _this._columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({
                        cellCount: props.columnCount,
                        cellSizeGetter: function(params) {
                            return _this._columnWidthGetter(params);
                        },
                        estimatedCellSize: _this._getEstimatedColumnSize(props)
                    }), _this._rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager2.default({
                        cellCount: props.rowCount,
                        cellSizeGetter: function(params) {
                            return _this._rowHeightGetter(params);
                        },
                        estimatedCellSize: _this._getEstimatedRowSize(props)
                    }), _this._cellCache = {}, _this._styleCache = {}, _this;
                }
                /**
	   * Pre-measure all columns and rows in a Grid.
	   * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.
	   * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).
	   */
                return _inherits(Grid, _Component), _createClass(Grid, [ {
                    key: "measureAllCells",
                    value: function() {
                        var _props = this.props, columnCount = _props.columnCount, rowCount = _props.rowCount;
                        this._columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1), this._rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);
                    }
                }, {
                    key: "recomputeGridSize",
                    value: function() {
                        var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref$columnIndex = _ref.columnIndex, columnIndex = void 0 === _ref$columnIndex ? 0 : _ref$columnIndex, _ref$rowIndex = _ref.rowIndex, rowIndex = void 0 === _ref$rowIndex ? 0 : _ref$rowIndex;
                        this._columnSizeAndPositionManager.resetCell(columnIndex), this._rowSizeAndPositionManager.resetCell(rowIndex), 
                        // Clear cell cache in case we are scrolling;
                        // Invalid row heights likely mean invalid cached content as well.
                        this._cellCache = {}, this._styleCache = {}, this.forceUpdate();
                    }
                }, {
                    key: "scrollToCell",
                    value: function(_ref2) {
                        var columnIndex = _ref2.columnIndex, rowIndex = _ref2.rowIndex, props = this.props;
                        this._updateScrollLeftForScrollToColumn(_extends({}, props, {
                            scrollToColumn: columnIndex
                        })), this._updateScrollTopForScrollToRow(_extends({}, props, {
                            scrollToRow: rowIndex
                        }));
                    }
                }, {
                    key: "componentDidMount",
                    value: function() {
                        var _props2 = this.props, scrollLeft = _props2.scrollLeft, scrollToColumn = _props2.scrollToColumn, scrollTop = _props2.scrollTop, scrollToRow = _props2.scrollToRow;
                        // If this component was first rendered server-side, scrollbar size will be undefined.
                        // In that event we need to remeasure.
                        this._scrollbarSizeMeasured || (this._scrollbarSize = (0, _scrollbarSize2.default)(), 
                        this._scrollbarSizeMeasured = !0, this.setState({})), (scrollLeft >= 0 || scrollTop >= 0) && this._setScrollPosition({
                            scrollLeft: scrollLeft,
                            scrollTop: scrollTop
                        }), (scrollToColumn >= 0 || scrollToRow >= 0) && (this._updateScrollLeftForScrollToColumn(), 
                        this._updateScrollTopForScrollToRow()), // Update onRowsRendered callback
                        this._invokeOnGridRenderedHelper(), // Initialize onScroll callback
                        this._invokeOnScrollMemoizer({
                            scrollLeft: scrollLeft || 0,
                            scrollTop: scrollTop || 0,
                            totalColumnsWidth: this._columnSizeAndPositionManager.getTotalSize(),
                            totalRowsHeight: this._rowSizeAndPositionManager.getTotalSize()
                        });
                    }
                }, {
                    key: "componentDidUpdate",
                    value: function(prevProps, prevState) {
                        var _this2 = this, _props3 = this.props, autoHeight = _props3.autoHeight, columnCount = _props3.columnCount, height = _props3.height, rowCount = _props3.rowCount, scrollToAlignment = _props3.scrollToAlignment, scrollToColumn = _props3.scrollToColumn, scrollToRow = _props3.scrollToRow, width = _props3.width, _state = this.state, scrollLeft = _state.scrollLeft, scrollPositionChangeReason = _state.scrollPositionChangeReason, scrollTop = _state.scrollTop, columnOrRowCountJustIncreasedFromZero = columnCount > 0 && 0 === prevProps.columnCount || rowCount > 0 && 0 === prevProps.rowCount;
                        // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners
                        if (// Make sure requested changes to :scrollLeft or :scrollTop get applied.
                        // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,
                        // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).
                        // So we only set these when we require an adjustment of the scroll position.
                        // See issue #2 for more information.
                        scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED && (scrollLeft >= 0 && (scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero) && (this._scrollingContainer.scrollLeft = scrollLeft), 
                        // @TRICKY :autoHeight property instructs Grid to leave :scrollTop management to an external HOC (eg WindowScroller).
                        // In this case we should avoid checking scrollingContainer.scrollTop since it forces layout/flow.
                        !autoHeight && scrollTop >= 0 && (scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero) && (this._scrollingContainer.scrollTop = scrollTop)), 
                        // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it
                        // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?
                        (0, _updateScrollIndexHelper2.default)({
                            cellSizeAndPositionManager: this._columnSizeAndPositionManager,
                            previousCellsCount: prevProps.columnCount,
                            previousCellSize: prevProps.columnWidth,
                            previousScrollToAlignment: prevProps.scrollToAlignment,
                            previousScrollToIndex: prevProps.scrollToColumn,
                            previousSize: prevProps.width,
                            scrollOffset: scrollLeft,
                            scrollToAlignment: scrollToAlignment,
                            scrollToIndex: scrollToColumn,
                            size: width,
                            updateScrollIndexCallback: function(scrollToColumn) {
                                return _this2._updateScrollLeftForScrollToColumn(_extends({}, _this2.props, {
                                    scrollToColumn: scrollToColumn
                                }));
                            }
                        }), (0, _updateScrollIndexHelper2.default)({
                            cellSizeAndPositionManager: this._rowSizeAndPositionManager,
                            previousCellsCount: prevProps.rowCount,
                            previousCellSize: prevProps.rowHeight,
                            previousScrollToAlignment: prevProps.scrollToAlignment,
                            previousScrollToIndex: prevProps.scrollToRow,
                            previousSize: prevProps.height,
                            scrollOffset: scrollTop,
                            scrollToAlignment: scrollToAlignment,
                            scrollToIndex: scrollToRow,
                            size: height,
                            updateScrollIndexCallback: function(scrollToRow) {
                                return _this2._updateScrollTopForScrollToRow(_extends({}, _this2.props, {
                                    scrollToRow: scrollToRow
                                }));
                            }
                        }), // Update onRowsRendered callback if start/stop indices have changed
                        this._invokeOnGridRenderedHelper(), scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {
                            var totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize(), totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize();
                            this._invokeOnScrollMemoizer({
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop,
                                totalColumnsWidth: totalColumnsWidth,
                                totalRowsHeight: totalRowsHeight
                            });
                        }
                    }
                }, {
                    key: "componentWillMount",
                    value: function() {
                        // If this component is being rendered server-side, getScrollbarSize() will return undefined.
                        // We handle this case in componentDidMount()
                        this._scrollbarSize = (0, _scrollbarSize2.default)(), void 0 === this._scrollbarSize ? (this._scrollbarSizeMeasured = !1, 
                        this._scrollbarSize = 0) : this._scrollbarSizeMeasured = !0, this._calculateChildrenToRender();
                    }
                }, {
                    key: "componentWillUnmount",
                    value: function() {
                        this._disablePointerEventsTimeoutId && clearTimeout(this._disablePointerEventsTimeoutId);
                    }
                }, {
                    key: "componentWillUpdate",
                    value: function(nextProps, nextState) {
                        var _this3 = this;
                        if (0 === nextProps.columnCount && 0 !== nextState.scrollLeft || 0 === nextProps.rowCount && 0 !== nextState.scrollTop) this._setScrollPosition({
                            scrollLeft: 0,
                            scrollTop: 0
                        }); else if (nextProps.scrollLeft !== this.props.scrollLeft || nextProps.scrollTop !== this.props.scrollTop) {
                            var newState = {};
                            null != nextProps.scrollLeft && (newState.scrollLeft = nextProps.scrollLeft), null != nextProps.scrollTop && (newState.scrollTop = nextProps.scrollTop), 
                            this._setScrollPosition(newState);
                        }
                        nextProps.columnWidth === this.props.columnWidth && nextProps.rowHeight === this.props.rowHeight || (this._styleCache = {}), 
                        this._columnWidthGetter = this._wrapSizeGetter(nextProps.columnWidth), this._rowHeightGetter = this._wrapSizeGetter(nextProps.rowHeight), 
                        this._columnSizeAndPositionManager.configure({
                            cellCount: nextProps.columnCount,
                            estimatedCellSize: this._getEstimatedColumnSize(nextProps)
                        }), this._rowSizeAndPositionManager.configure({
                            cellCount: nextProps.rowCount,
                            estimatedCellSize: this._getEstimatedRowSize(nextProps)
                        }), // Update scroll offsets if the size or number of cells have changed, invalidating the previous value
                        (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({
                            cellCount: this.props.columnCount,
                            cellSize: this.props.columnWidth,
                            computeMetadataCallback: function() {
                                return _this3._columnSizeAndPositionManager.resetCell(0);
                            },
                            computeMetadataCallbackProps: nextProps,
                            nextCellsCount: nextProps.columnCount,
                            nextCellSize: nextProps.columnWidth,
                            nextScrollToIndex: nextProps.scrollToColumn,
                            scrollToIndex: this.props.scrollToColumn,
                            updateScrollOffsetForScrollToIndex: function() {
                                return _this3._updateScrollLeftForScrollToColumn(nextProps, nextState);
                            }
                        }), (0, _calculateSizeAndPositionDataAndUpdateScrollOffset2.default)({
                            cellCount: this.props.rowCount,
                            cellSize: this.props.rowHeight,
                            computeMetadataCallback: function() {
                                return _this3._rowSizeAndPositionManager.resetCell(0);
                            },
                            computeMetadataCallbackProps: nextProps,
                            nextCellsCount: nextProps.rowCount,
                            nextCellSize: nextProps.rowHeight,
                            nextScrollToIndex: nextProps.scrollToRow,
                            scrollToIndex: this.props.scrollToRow,
                            updateScrollOffsetForScrollToIndex: function() {
                                return _this3._updateScrollTopForScrollToRow(nextProps, nextState);
                            }
                        }), this._calculateChildrenToRender(nextProps, nextState);
                    }
                }, {
                    key: "render",
                    value: function() {
                        var _this4 = this, _props4 = this.props, autoContainerWidth = _props4.autoContainerWidth, autoHeight = _props4.autoHeight, className = _props4.className, containerStyle = _props4.containerStyle, height = _props4.height, id = _props4.id, noContentRenderer = _props4.noContentRenderer, style = _props4.style, tabIndex = _props4.tabIndex, width = _props4.width, isScrolling = this.state.isScrolling, gridStyle = {
                            boxSizing: "border-box",
                            direction: "ltr",
                            height: autoHeight ? "auto" : height,
                            position: "relative",
                            width: width,
                            WebkitOverflowScrolling: "touch",
                            willChange: "transform"
                        }, totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize(), totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize(), verticalScrollBarSize = totalRowsHeight > height ? this._scrollbarSize : 0, horizontalScrollBarSize = totalColumnsWidth > width ? this._scrollbarSize : 0;
                        // Also explicitly init styles to 'auto' if scrollbars are required.
                        // This works around an obscure edge case where external CSS styles have not yet been loaded,
                        // But an initial scroll index of offset is set as an external prop.
                        // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.
                        // This was originally reported via clauderic/react-infinite-calendar/issues/23
                        gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? "hidden" : "auto", 
                        gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? "hidden" : "auto";
                        var childrenToDisplay = this._childrenToDisplay, showNoContentRenderer = 0 === childrenToDisplay.length && height > 0 && width > 0;
                        return _react2.default.createElement("div", {
                            ref: function(_ref3) {
                                _this4._scrollingContainer = _ref3;
                            },
                            "aria-label": this.props["aria-label"],
                            className: (0, _classnames2.default)("ReactVirtualized__Grid", className),
                            id: id,
                            onScroll: this._onScroll,
                            role: "grid",
                            style: _extends({}, gridStyle, style),
                            tabIndex: tabIndex
                        }, childrenToDisplay.length > 0 && _react2.default.createElement("div", {
                            className: "ReactVirtualized__Grid__innerScrollContainer",
                            style: _extends({
                                width: autoContainerWidth ? "auto" : totalColumnsWidth,
                                height: totalRowsHeight,
                                maxWidth: totalColumnsWidth,
                                maxHeight: totalRowsHeight,
                                overflow: "hidden",
                                pointerEvents: isScrolling ? "none" : ""
                            }, containerStyle)
                        }, childrenToDisplay), showNoContentRenderer && noContentRenderer());
                    }
                }, {
                    key: "shouldComponentUpdate",
                    value: function(nextProps, nextState) {
                        return (0, _reactAddonsShallowCompare2.default)(this, nextProps, nextState);
                    }
                }, {
                    key: "_calculateChildrenToRender",
                    value: function() {
                        var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, cellRenderer = props.cellRenderer, cellRangeRenderer = props.cellRangeRenderer, columnCount = props.columnCount, height = props.height, overscanColumnCount = props.overscanColumnCount, overscanRowCount = props.overscanRowCount, rowCount = props.rowCount, width = props.width, isScrolling = state.isScrolling, scrollDirectionHorizontal = state.scrollDirectionHorizontal, scrollDirectionVertical = state.scrollDirectionVertical, scrollLeft = state.scrollLeft, scrollTop = state.scrollTop;
                        // Render only enough columns and rows to cover the visible area of the grid.
                        if (this._childrenToDisplay = [], height > 0 && width > 0) {
                            var visibleColumnIndices = this._columnSizeAndPositionManager.getVisibleCellRange({
                                containerSize: width,
                                offset: scrollLeft
                            }), visibleRowIndices = this._rowSizeAndPositionManager.getVisibleCellRange({
                                containerSize: height,
                                offset: scrollTop
                            }), horizontalOffsetAdjustment = this._columnSizeAndPositionManager.getOffsetAdjustment({
                                containerSize: width,
                                offset: scrollLeft
                            }), verticalOffsetAdjustment = this._rowSizeAndPositionManager.getOffsetAdjustment({
                                containerSize: height,
                                offset: scrollTop
                            });
                            // Store for _invokeOnGridRenderedHelper()
                            this._renderedColumnStartIndex = visibleColumnIndices.start, this._renderedColumnStopIndex = visibleColumnIndices.stop, 
                            this._renderedRowStartIndex = visibleRowIndices.start, this._renderedRowStopIndex = visibleRowIndices.stop;
                            var overscanColumnIndices = (0, _getOverscanIndices2.default)({
                                cellCount: columnCount,
                                overscanCellsCount: overscanColumnCount,
                                scrollDirection: scrollDirectionHorizontal,
                                startIndex: this._renderedColumnStartIndex,
                                stopIndex: this._renderedColumnStopIndex
                            }), overscanRowIndices = (0, _getOverscanIndices2.default)({
                                cellCount: rowCount,
                                overscanCellsCount: overscanRowCount,
                                scrollDirection: scrollDirectionVertical,
                                startIndex: this._renderedRowStartIndex,
                                stopIndex: this._renderedRowStopIndex
                            });
                            // Store for _invokeOnGridRenderedHelper()
                            this._columnStartIndex = overscanColumnIndices.overscanStartIndex, this._columnStopIndex = overscanColumnIndices.overscanStopIndex, 
                            this._rowStartIndex = overscanRowIndices.overscanStartIndex, this._rowStopIndex = overscanRowIndices.overscanStopIndex, 
                            this._childrenToDisplay = cellRangeRenderer({
                                cellCache: this._cellCache,
                                cellRenderer: cellRenderer,
                                columnSizeAndPositionManager: this._columnSizeAndPositionManager,
                                columnStartIndex: this._columnStartIndex,
                                columnStopIndex: this._columnStopIndex,
                                horizontalOffsetAdjustment: horizontalOffsetAdjustment,
                                isScrolling: isScrolling,
                                rowSizeAndPositionManager: this._rowSizeAndPositionManager,
                                rowStartIndex: this._rowStartIndex,
                                rowStopIndex: this._rowStopIndex,
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop,
                                styleCache: this._styleCache,
                                verticalOffsetAdjustment: verticalOffsetAdjustment,
                                visibleColumnIndices: visibleColumnIndices,
                                visibleRowIndices: visibleRowIndices
                            });
                        }
                    }
                }, {
                    key: "_debounceScrollEnded",
                    value: function() {
                        var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
                        this._disablePointerEventsTimeoutId && clearTimeout(this._disablePointerEventsTimeoutId), 
                        this._disablePointerEventsTimeoutId = setTimeout(this._debounceScrollEndedCallback, scrollingResetTimeInterval);
                    }
                }, {
                    key: "_debounceScrollEndedCallback",
                    value: function() {
                        this._disablePointerEventsTimeoutId = null;
                        var styleCache = this._styleCache;
                        // Reset cell and style caches once scrolling stops.
                        // This makes Grid simpler to use (since cells commonly change).
                        // And it keeps the caches from growing too large.
                        // Performance is most sensitive when a user is scrolling.
                        this._cellCache = {}, this._styleCache = {};
                        // Copy over the visible cell styles so avoid unnecessary re-render.
                        for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
                            var key = rowIndex + "-" + columnIndex;
                            this._styleCache[key] = styleCache[key];
                        }
                        this.setState({
                            isScrolling: !1
                        });
                    }
                }, {
                    key: "_getEstimatedColumnSize",
                    value: function(props) {
                        return "number" == typeof props.columnWidth ? props.columnWidth : props.estimatedColumnSize;
                    }
                }, {
                    key: "_getEstimatedRowSize",
                    value: function(props) {
                        return "number" == typeof props.rowHeight ? props.rowHeight : props.estimatedRowSize;
                    }
                }, {
                    key: "_invokeOnGridRenderedHelper",
                    value: function() {
                        var onSectionRendered = this.props.onSectionRendered;
                        this._onGridRenderedMemoizer({
                            callback: onSectionRendered,
                            indices: {
                                columnOverscanStartIndex: this._columnStartIndex,
                                columnOverscanStopIndex: this._columnStopIndex,
                                columnStartIndex: this._renderedColumnStartIndex,
                                columnStopIndex: this._renderedColumnStopIndex,
                                rowOverscanStartIndex: this._rowStartIndex,
                                rowOverscanStopIndex: this._rowStopIndex,
                                rowStartIndex: this._renderedRowStartIndex,
                                rowStopIndex: this._renderedRowStopIndex
                            }
                        });
                    }
                }, {
                    key: "_invokeOnScrollMemoizer",
                    value: function(_ref4) {
                        var _this5 = this, scrollLeft = _ref4.scrollLeft, scrollTop = _ref4.scrollTop, totalColumnsWidth = _ref4.totalColumnsWidth, totalRowsHeight = _ref4.totalRowsHeight;
                        this._onScrollMemoizer({
                            callback: function(_ref5) {
                                var scrollLeft = _ref5.scrollLeft, scrollTop = _ref5.scrollTop, _props5 = _this5.props, height = _props5.height, onScroll = _props5.onScroll, width = _props5.width;
                                onScroll({
                                    clientHeight: height,
                                    clientWidth: width,
                                    scrollHeight: totalRowsHeight,
                                    scrollLeft: scrollLeft,
                                    scrollTop: scrollTop,
                                    scrollWidth: totalColumnsWidth
                                });
                            },
                            indices: {
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop
                            }
                        });
                    }
                }, {
                    key: "_setScrollPosition",
                    value: function(_ref6) {
                        var scrollLeft = _ref6.scrollLeft, scrollTop = _ref6.scrollTop, newState = {
                            scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
                        };
                        scrollLeft >= 0 && (newState.scrollDirectionHorizontal = scrollLeft > this.state.scrollLeft ? _getOverscanIndices.SCROLL_DIRECTION_FORWARD : _getOverscanIndices.SCROLL_DIRECTION_BACKWARD, 
                        newState.scrollLeft = scrollLeft), scrollTop >= 0 && (newState.scrollDirectionVertical = scrollTop > this.state.scrollTop ? _getOverscanIndices.SCROLL_DIRECTION_FORWARD : _getOverscanIndices.SCROLL_DIRECTION_BACKWARD, 
                        newState.scrollTop = scrollTop), (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) && this.setState(newState);
                    }
                }, {
                    key: "_wrapPropertyGetter",
                    value: function(value) {
                        return value instanceof Function ? value : function() {
                            return value;
                        };
                    }
                }, {
                    key: "_wrapSizeGetter",
                    value: function(size) {
                        return this._wrapPropertyGetter(size);
                    }
                }, {
                    key: "_updateScrollLeftForScrollToColumn",
                    value: function() {
                        var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, columnCount = props.columnCount, scrollToAlignment = props.scrollToAlignment, scrollToColumn = props.scrollToColumn, width = props.width, scrollLeft = state.scrollLeft;
                        if (scrollToColumn >= 0 && columnCount > 0) {
                            var targetIndex = Math.max(0, Math.min(columnCount - 1, scrollToColumn)), calculatedScrollLeft = this._columnSizeAndPositionManager.getUpdatedOffsetForIndex({
                                align: scrollToAlignment,
                                containerSize: width,
                                currentOffset: scrollLeft,
                                targetIndex: targetIndex
                            });
                            scrollLeft !== calculatedScrollLeft && this._setScrollPosition({
                                scrollLeft: calculatedScrollLeft
                            });
                        }
                    }
                }, {
                    key: "_updateScrollTopForScrollToRow",
                    value: function() {
                        var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, height = props.height, rowCount = props.rowCount, scrollToAlignment = props.scrollToAlignment, scrollToRow = props.scrollToRow, scrollTop = state.scrollTop;
                        if (scrollToRow >= 0 && rowCount > 0) {
                            var targetIndex = Math.max(0, Math.min(rowCount - 1, scrollToRow)), calculatedScrollTop = this._rowSizeAndPositionManager.getUpdatedOffsetForIndex({
                                align: scrollToAlignment,
                                containerSize: height,
                                currentOffset: scrollTop,
                                targetIndex: targetIndex
                            });
                            scrollTop !== calculatedScrollTop && this._setScrollPosition({
                                scrollTop: calculatedScrollTop
                            });
                        }
                    }
                }, {
                    key: "_onScroll",
                    value: function(event) {
                        // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.
                        // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.
                        // See issue #404 for more information.
                        if (event.target === this._scrollingContainer) {
                            // Prevent pointer events from interrupting a smooth scroll
                            this._debounceScrollEnded();
                            // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,
                            // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.
                            // This causes a series of rapid renders that is slow for long lists.
                            // We can avoid that by doing some simple bounds checking to ensure that scrollTop never exceeds the total height.
                            var _props6 = this.props, autoHeight = _props6.autoHeight, height = _props6.height, width = _props6.width, scrollbarSize = this._scrollbarSize, totalRowsHeight = this._rowSizeAndPositionManager.getTotalSize(), totalColumnsWidth = this._columnSizeAndPositionManager.getTotalSize(), scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), event.target.scrollLeft), scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), event.target.scrollTop);
                            // Certain devices (like Apple touchpad) rapid-fire duplicate events.
                            // Don't force a re-render if this is the case.
                            // The mouse may move faster then the animation frame does.
                            // Use requestAnimationFrame to avoid over-updating.
                            if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
                                // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.
                                var scrollDirectionHorizontal = scrollLeft > this.state.scrollLeft ? _getOverscanIndices.SCROLL_DIRECTION_FORWARD : _getOverscanIndices.SCROLL_DIRECTION_BACKWARD, scrollDirectionVertical = scrollTop > this.state.scrollTop ? _getOverscanIndices.SCROLL_DIRECTION_FORWARD : _getOverscanIndices.SCROLL_DIRECTION_BACKWARD, newState = {
                                    isScrolling: !0,
                                    scrollDirectionHorizontal: scrollDirectionHorizontal,
                                    scrollDirectionVertical: scrollDirectionVertical,
                                    scrollLeft: scrollLeft,
                                    scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED
                                };
                                autoHeight || (newState.scrollTop = scrollTop), this.setState(newState);
                            }
                            this._invokeOnScrollMemoizer({
                                scrollLeft: scrollLeft,
                                scrollTop: scrollTop,
                                totalColumnsWidth: totalColumnsWidth,
                                totalRowsHeight: totalRowsHeight
                            });
                        }
                    }
                } ]), Grid;
            }(_react.Component);
            Grid.defaultProps = {
                "aria-label": "grid",
                cellRangeRenderer: _defaultCellRangeRenderer2.default,
                estimatedColumnSize: 100,
                estimatedRowSize: 30,
                noContentRenderer: function() {
                    return null;
                },
                onScroll: function() {
                    return null;
                },
                onSectionRendered: function() {
                    return null;
                },
                overscanColumnCount: 0,
                overscanRowCount: 10,
                scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
                scrollToAlignment: "auto",
                style: {},
                tabIndex: 0
            }, exports.default = Grid, "production" !== process.env.NODE_ENV ? Grid.propTypes = {
                "aria-label": _react.PropTypes.string,
                /**
	   * Set the width of the inner scrollable container to 'auto'.
	   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.
	   */
                autoContainerWidth: _react.PropTypes.bool,
                /**
	   * Removes fixed height from the scrollingContainer so that the total height
	   * of rows can stretch the window. Intended for use with WindowScroller
	   */
                autoHeight: _react.PropTypes.bool,
                /**
	   * Responsible for rendering a cell given an row and column index.
	   * Should implement the following interface: ({ columnIndex: number, rowIndex: number }): PropTypes.node
	   */
                cellRenderer: _react.PropTypes.func.isRequired,
                /**
	   * Responsible for rendering a group of cells given their index ranges.
	   * Should implement the following interface: ({
	   *   cellCache: Map,
	   *   cellRenderer: Function,
	   *   columnSizeAndPositionManager: CellSizeAndPositionManager,
	   *   columnStartIndex: number,
	   *   columnStopIndex: number,
	   *   isScrolling: boolean,
	   *   rowSizeAndPositionManager: CellSizeAndPositionManager,
	   *   rowStartIndex: number,
	   *   rowStopIndex: number,
	   *   scrollLeft: number,
	   *   scrollTop: number
	   * }): Array<PropTypes.node>
	   */
                cellRangeRenderer: _react.PropTypes.func.isRequired,
                /**
	   * Optional custom CSS class name to attach to root Grid element.
	   */
                className: _react.PropTypes.string,
                /**
	   * Number of columns in grid.
	   */
                columnCount: _react.PropTypes.number.isRequired,
                /**
	   * Either a fixed column width (number) or a function that returns the width of a column given its index.
	   * Should implement the following interface: (index: number): number
	   */
                columnWidth: _react.PropTypes.oneOfType([ _react.PropTypes.number, _react.PropTypes.func ]).isRequired,
                /** Optional inline style applied to inner cell-container */
                containerStyle: _react.PropTypes.object,
                /**
	   * Used to estimate the total width of a Grid before all of its columns have actually been measured.
	   * The estimated total width is adjusted as columns are rendered.
	   */
                estimatedColumnSize: _react.PropTypes.number.isRequired,
                /**
	   * Used to estimate the total height of a Grid before all of its rows have actually been measured.
	   * The estimated total height is adjusted as rows are rendered.
	   */
                estimatedRowSize: _react.PropTypes.number.isRequired,
                /**
	   * Height of Grid; this property determines the number of visible (vs virtualized) rows.
	   */
                height: _react.PropTypes.number.isRequired,
                /**
	   * Optional custom id to attach to root Grid element.
	   */
                id: _react.PropTypes.string,
                /**
	   * Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.
	   */
                noContentRenderer: _react.PropTypes.func.isRequired,
                /**
	   * Callback invoked whenever the scroll offset changes within the inner scrollable region.
	   * This callback can be used to sync scrolling between lists, tables, or grids.
	   * ({ clientHeight, clientWidth, scrollHeight, scrollLeft, scrollTop, scrollWidth }): void
	   */
                onScroll: _react.PropTypes.func.isRequired,
                /**
	   * Callback invoked with information about the section of the Grid that was just rendered.
	   * ({ columnStartIndex, columnStopIndex, rowStartIndex, rowStopIndex }): void
	   */
                onSectionRendered: _react.PropTypes.func.isRequired,
                /**
	   * Number of columns to render before/after the visible section of the grid.
	   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
	   */
                overscanColumnCount: _react.PropTypes.number.isRequired,
                /**
	   * Number of rows to render above/below the visible section of the grid.
	   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
	   */
                overscanRowCount: _react.PropTypes.number.isRequired,
                /**
	   * Either a fixed row height (number) or a function that returns the height of a row given its index.
	   * Should implement the following interface: ({ index: number }): number
	   */
                rowHeight: _react.PropTypes.oneOfType([ _react.PropTypes.number, _react.PropTypes.func ]).isRequired,
                /**
	   * Number of rows in grid.
	   */
                rowCount: _react.PropTypes.number.isRequired,
                /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */
                scrollingResetTimeInterval: _react.PropTypes.number,
                /** Horizontal offset. */
                scrollLeft: _react.PropTypes.number,
                /**
	   * Controls scroll-to-cell behavior of the Grid.
	   * The default ("auto") scrolls the least amount possible to ensure that the specified cell is fully visible.
	   * Use "start" to align cells to the top/left of the Grid and "end" to align bottom/right.
	   */
                scrollToAlignment: _react.PropTypes.oneOf([ "auto", "end", "start", "center" ]).isRequired,
                /**
	   * Column index to ensure visible (by forcefully scrolling if necessary)
	   */
                scrollToColumn: _react.PropTypes.number,
                /** Vertical offset. */
                scrollTop: _react.PropTypes.number,
                /**
	   * Row index to ensure visible (by forcefully scrolling if necessary)
	   */
                scrollToRow: _react.PropTypes.number,
                /** Optional inline style */
                style: _react.PropTypes.object,
                /** Tab index for focus */
                tabIndex: _react.PropTypes.number,
                /**
	   * Width of Grid; this property determines the number of visible (vs virtualized) columns.
	   */
                width: _react.PropTypes.number.isRequired
            } : void 0;
        }).call(exports, __webpack_require__(153));
    }, /* 220 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Helper method that determines when to recalculate row or column metadata.
	 *
	 * @param cellCount Number of rows or columns in the current axis
	 * @param cellsSize Width or height of cells for the current axis
	 * @param computeMetadataCallback Method to invoke if cell metadata should be recalculated
	 * @param computeMetadataCallbackProps Parameters to pass to :computeMetadataCallback
	 * @param nextCellsCount Newly updated number of rows or columns in the current axis
	 * @param nextCellsSize Newly updated width or height of cells for the current axis
	 * @param nextScrollToIndex Newly updated scroll-to-index
	 * @param scrollToIndex Scroll-to-index
	 * @param updateScrollOffsetForScrollToIndex Callback to invoke if the scroll position should be recalculated
	 */
        function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {
            var cellCount = _ref.cellCount, cellSize = _ref.cellSize, computeMetadataCallback = _ref.computeMetadataCallback, computeMetadataCallbackProps = _ref.computeMetadataCallbackProps, nextCellsCount = _ref.nextCellsCount, nextCellSize = _ref.nextCellSize, nextScrollToIndex = _ref.nextScrollToIndex, scrollToIndex = _ref.scrollToIndex, updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;
            // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.
            // In that event users should use the manual recompute methods to inform of changes.
            cellCount === nextCellsCount && ("number" != typeof cellSize && "number" != typeof nextCellSize || cellSize === nextCellSize) || (computeMetadataCallback(computeMetadataCallbackProps), 
            // Updated cell metadata may have hidden the previous scrolled-to item.
            // In this case we should also update the scrollTop to ensure it stays visible.
            scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex && updateScrollOffsetForScrollToIndex());
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = calculateSizeAndPositionDataAndUpdateScrollOffset;
    }, /* 221 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DEFAULT_MAX_SCROLL_SIZE = void 0;
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _CellSizeAndPositionManager = __webpack_require__(222), _CellSizeAndPositionManager2 = _interopRequireDefault(_CellSizeAndPositionManager), DEFAULT_MAX_SCROLL_SIZE = exports.DEFAULT_MAX_SCROLL_SIZE = 15e5, ScalingCellSizeAndPositionManager = function() {
            function ScalingCellSizeAndPositionManager(_ref) {
                var _ref$maxScrollSize = _ref.maxScrollSize, maxScrollSize = void 0 === _ref$maxScrollSize ? DEFAULT_MAX_SCROLL_SIZE : _ref$maxScrollSize, params = _objectWithoutProperties(_ref, [ "maxScrollSize" ]);
                _classCallCheck(this, ScalingCellSizeAndPositionManager), // Favor composition over inheritance to simplify IE10 support
                this._cellSizeAndPositionManager = new _CellSizeAndPositionManager2.default(params), 
                this._maxScrollSize = maxScrollSize;
            }
            return _createClass(ScalingCellSizeAndPositionManager, [ {
                key: "configure",
                value: function(params) {
                    this._cellSizeAndPositionManager.configure(params);
                }
            }, {
                key: "getCellCount",
                value: function() {
                    return this._cellSizeAndPositionManager.getCellCount();
                }
            }, {
                key: "getEstimatedCellSize",
                value: function() {
                    return this._cellSizeAndPositionManager.getEstimatedCellSize();
                }
            }, {
                key: "getLastMeasuredIndex",
                value: function() {
                    return this._cellSizeAndPositionManager.getLastMeasuredIndex();
                }
            }, {
                key: "getOffsetAdjustment",
                value: function(_ref2) {
                    var containerSize = _ref2.containerSize, offset = _ref2.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize(), offsetPercentage = this._getOffsetPercentage({
                        containerSize: containerSize,
                        offset: offset,
                        totalSize: safeTotalSize
                    });
                    return Math.round(offsetPercentage * (safeTotalSize - totalSize));
                }
            }, {
                key: "getSizeAndPositionOfCell",
                value: function(index) {
                    return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);
                }
            }, {
                key: "getSizeAndPositionOfLastMeasuredCell",
                value: function() {
                    return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
                }
            }, {
                key: "getTotalSize",
                value: function() {
                    return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
                }
            }, {
                key: "getUpdatedOffsetForIndex",
                value: function(_ref3) {
                    var _ref3$align = _ref3.align, align = void 0 === _ref3$align ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex, totalSize = _ref3.totalSize;
                    currentOffset = this._safeOffsetToOffset({
                        containerSize: containerSize,
                        offset: currentOffset
                    });
                    var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
                        align: align,
                        containerSize: containerSize,
                        currentOffset: currentOffset,
                        targetIndex: targetIndex,
                        totalSize: totalSize
                    });
                    return this._offsetToSafeOffset({
                        containerSize: containerSize,
                        offset: offset
                    });
                }
            }, {
                key: "getVisibleCellRange",
                value: function(_ref4) {
                    var containerSize = _ref4.containerSize, offset = _ref4.offset;
                    return offset = this._safeOffsetToOffset({
                        containerSize: containerSize,
                        offset: offset
                    }), this._cellSizeAndPositionManager.getVisibleCellRange({
                        containerSize: containerSize,
                        offset: offset
                    });
                }
            }, {
                key: "resetCell",
                value: function(index) {
                    this._cellSizeAndPositionManager.resetCell(index);
                }
            }, {
                key: "_getOffsetPercentage",
                value: function(_ref5) {
                    var containerSize = _ref5.containerSize, offset = _ref5.offset, totalSize = _ref5.totalSize;
                    return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
                }
            }, {
                key: "_offsetToSafeOffset",
                value: function(_ref6) {
                    var containerSize = _ref6.containerSize, offset = _ref6.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize();
                    if (totalSize === safeTotalSize) return offset;
                    var offsetPercentage = this._getOffsetPercentage({
                        containerSize: containerSize,
                        offset: offset,
                        totalSize: totalSize
                    });
                    return Math.round(offsetPercentage * (safeTotalSize - containerSize));
                }
            }, {
                key: "_safeOffsetToOffset",
                value: function(_ref7) {
                    var containerSize = _ref7.containerSize, offset = _ref7.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize();
                    if (totalSize === safeTotalSize) return offset;
                    var offsetPercentage = this._getOffsetPercentage({
                        containerSize: containerSize,
                        offset: offset,
                        totalSize: safeTotalSize
                    });
                    return Math.round(offsetPercentage * (totalSize - containerSize));
                }
            } ]), ScalingCellSizeAndPositionManager;
        }();
        exports.default = ScalingCellSizeAndPositionManager;
    }, /* 222 */
    /***/
    function(module, exports) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), CellSizeAndPositionManager = function() {
            function CellSizeAndPositionManager(_ref) {
                var cellCount = _ref.cellCount, cellSizeGetter = _ref.cellSizeGetter, estimatedCellSize = _ref.estimatedCellSize;
                _classCallCheck(this, CellSizeAndPositionManager), this._cellSizeGetter = cellSizeGetter, 
                this._cellCount = cellCount, this._estimatedCellSize = estimatedCellSize, // Cache of size and position data for cells, mapped by cell index.
                // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex
                this._cellSizeAndPositionData = {}, // Measurements for cells up to this index can be trusted; cells afterward should be estimated.
                this._lastMeasuredIndex = -1;
            }
            return _createClass(CellSizeAndPositionManager, [ {
                key: "configure",
                value: function(_ref2) {
                    var cellCount = _ref2.cellCount, estimatedCellSize = _ref2.estimatedCellSize;
                    this._cellCount = cellCount, this._estimatedCellSize = estimatedCellSize;
                }
            }, {
                key: "getCellCount",
                value: function() {
                    return this._cellCount;
                }
            }, {
                key: "getEstimatedCellSize",
                value: function() {
                    return this._estimatedCellSize;
                }
            }, {
                key: "getLastMeasuredIndex",
                value: function() {
                    return this._lastMeasuredIndex;
                }
            }, {
                key: "getSizeAndPositionOfCell",
                value: function(index) {
                    if (index < 0 || index >= this._cellCount) throw Error("Requested index " + index + " is outside of range 0.." + this._cellCount);
                    if (index > this._lastMeasuredIndex) {
                        for (var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), _offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size, i = this._lastMeasuredIndex + 1; i <= index; i++) {
                            var _size = this._cellSizeGetter({
                                index: i
                            });
                            if (null == _size || isNaN(_size)) throw Error("Invalid size returned for cell " + i + " of value " + _size);
                            this._cellSizeAndPositionData[i] = {
                                offset: _offset,
                                size: _size
                            }, _offset += _size;
                        }
                        this._lastMeasuredIndex = index;
                    }
                    return this._cellSizeAndPositionData[index];
                }
            }, {
                key: "getSizeAndPositionOfLastMeasuredCell",
                value: function() {
                    return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
                        offset: 0,
                        size: 0
                    };
                }
            }, {
                key: "getTotalSize",
                value: function() {
                    var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
                    return lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size + (this._cellCount - this._lastMeasuredIndex - 1) * this._estimatedCellSize;
                }
            }, {
                key: "getUpdatedOffsetForIndex",
                value: function(_ref3) {
                    var _ref3$align = _ref3.align, align = void 0 === _ref3$align ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
                    if (containerSize <= 0) return 0;
                    var datum = this.getSizeAndPositionOfCell(targetIndex), maxOffset = datum.offset, minOffset = maxOffset - containerSize + datum.size, idealOffset = void 0;
                    switch (align) {
                      case "start":
                        idealOffset = maxOffset;
                        break;

                      case "end":
                        idealOffset = minOffset;
                        break;

                      case "center":
                        idealOffset = maxOffset - (containerSize - datum.size) / 2;
                        break;

                      default:
                        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
                    }
                    var totalSize = this.getTotalSize();
                    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
                }
            }, {
                key: "getVisibleCellRange",
                value: function(_ref4) {
                    var containerSize = _ref4.containerSize, offset = _ref4.offset, totalSize = this.getTotalSize();
                    if (0 === totalSize) return {};
                    var maxOffset = offset + containerSize, start = this._findNearestCell(offset), datum = this.getSizeAndPositionOfCell(start);
                    offset = datum.offset + datum.size;
                    for (var stop = start; offset < maxOffset && stop < this._cellCount - 1; ) stop++, 
                    offset += this.getSizeAndPositionOfCell(stop).size;
                    return {
                        start: start,
                        stop: stop
                    };
                }
            }, {
                key: "resetCell",
                value: function(index) {
                    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);
                }
            }, {
                key: "_binarySearch",
                value: function(_ref5) {
                    for (var high = _ref5.high, low = _ref5.low, offset = _ref5.offset, middle = void 0, currentOffset = void 0; low <= high; ) {
                        if (middle = low + Math.floor((high - low) / 2), currentOffset = this.getSizeAndPositionOfCell(middle).offset, 
                        currentOffset === offset) return middle;
                        currentOffset < offset ? low = middle + 1 : currentOffset > offset && (high = middle - 1);
                    }
                    if (low > 0) return low - 1;
                }
            }, {
                key: "_exponentialSearch",
                value: function(_ref6) {
                    for (var index = _ref6.index, offset = _ref6.offset, interval = 1; index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset; ) index += interval, 
                    interval *= 2;
                    return this._binarySearch({
                        high: Math.min(index, this._cellCount - 1),
                        low: Math.floor(index / 2),
                        offset: offset
                    });
                }
            }, {
                key: "_findNearestCell",
                value: function(offset) {
                    if (isNaN(offset)) throw Error("Invalid offset " + offset + " specified");
                    // Our search algorithms find the nearest match at or below the specified offset.
                    // So make sure the offset is at least 0 or no match will be found.
                    offset = Math.max(0, offset);
                    var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);
                    return lastMeasuredCellSizeAndPosition.offset >= offset ? this._binarySearch({
                        high: lastMeasuredIndex,
                        low: 0,
                        offset: offset
                    }) : this._exponentialSearch({
                        index: lastMeasuredIndex,
                        offset: offset
                    });
                }
            } ]), CellSizeAndPositionManager;
        }();
        exports.default = CellSizeAndPositionManager;
    }, /* 223 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Helper utility that updates the specified callback whenever any of the specified indices have changed.
	 */
        function createCallbackMemoizer() {
            var requireAllKeys = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], cachedIndices = {};
            return function(_ref) {
                var callback = _ref.callback, indices = _ref.indices, keys = Object.keys(indices), allInitialized = !requireAllKeys || keys.every(function(key) {
                    var value = indices[key];
                    return Array.isArray(value) ? value.length > 0 : value >= 0;
                }), indexChanged = keys.length !== Object.keys(cachedIndices).length || keys.some(function(key) {
                    var cachedValue = cachedIndices[key], value = indices[key];
                    return Array.isArray(value) ? cachedValue.join(",") !== value.join(",") : cachedValue !== value;
                });
                cachedIndices = indices, allInitialized && indexChanged && callback(indices);
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = createCallbackMemoizer;
    }, /* 224 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Calculates the number of cells to overscan before and after a specified range.
	 * This function ensures that overscanning doesn't exceed the available cells.
	 *
	 * @param cellCount Number of rows or columns in the current axis
	 * @param scrollDirection One of SCROLL_DIRECTION_BACKWARD
	 * @param overscanCellsCount Maximum number of cells to over-render in either direction
	 * @param startIndex Begin of range of visible cells
	 * @param stopIndex End of range of visible cells
	 */
        function getOverscanIndices(_ref) {
            var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex, overscanStartIndex = void 0, overscanStopIndex = void 0;
            switch (scrollDirection) {
              case SCROLL_DIRECTION_FORWARD:
                overscanStartIndex = startIndex, overscanStopIndex = stopIndex + overscanCellsCount;
                break;

              case SCROLL_DIRECTION_BACKWARD:
                overscanStartIndex = startIndex - overscanCellsCount, overscanStopIndex = stopIndex;
            }
            return {
                overscanStartIndex: Math.max(0, overscanStartIndex),
                overscanStopIndex: Math.min(cellCount - 1, overscanStopIndex)
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = getOverscanIndices;
        var SCROLL_DIRECTION_BACKWARD = exports.SCROLL_DIRECTION_BACKWARD = -1, SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_FORWARD = 1;
    }, /* 225 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = function(recalc) {
            if ((!size || recalc) && _inDOM2.default) {
                var scrollDiv = document.createElement("div");
                scrollDiv.style.position = "absolute", scrollDiv.style.top = "-9999px", scrollDiv.style.width = "50px", 
                scrollDiv.style.height = "50px", scrollDiv.style.overflow = "scroll", document.body.appendChild(scrollDiv), 
                size = scrollDiv.offsetWidth - scrollDiv.clientWidth, document.body.removeChild(scrollDiv);
            }
            return size;
        };
        var _inDOM = __webpack_require__(226), _inDOM2 = _interopRequireDefault(_inDOM), size = void 0;
        module.exports = exports.default;
    }, /* 226 */
    /***/
    function(module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = !("undefined" == typeof window || !window.document || !window.document.createElement), 
        module.exports = exports.default;
    }, /* 227 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.
	 * This function also ensures that the scroll ofset isn't past the last column/row of cells.
	 *
	 * @param cellsSize Width or height of cells for the current axis
	 * @param cellSizeAndPositionManager Manages size and position metadata of cells
	 * @param previousCellsCount Previous number of rows or columns
	 * @param previousCellsSize Previous width or height of cells
	 * @param previousScrollToIndex Previous scroll-to-index
	 * @param previousSize Previous width or height of the virtualized container
	 * @param scrollOffset Current scrollLeft or scrollTop
	 * @param scrollToIndex Scroll-to-index
	 * @param size Width or height of the virtualized container
	 * @param updateScrollIndexCallback Callback to invoke with an scroll-to-index value
	 */
        function updateScrollIndexHelper(_ref) {
            var cellSize = _ref.cellSize, cellSizeAndPositionManager = _ref.cellSizeAndPositionManager, previousCellsCount = _ref.previousCellsCount, previousCellSize = _ref.previousCellSize, previousScrollToAlignment = _ref.previousScrollToAlignment, previousScrollToIndex = _ref.previousScrollToIndex, previousSize = _ref.previousSize, scrollOffset = _ref.scrollOffset, scrollToAlignment = _ref.scrollToAlignment, scrollToIndex = _ref.scrollToIndex, size = _ref.size, updateScrollIndexCallback = _ref.updateScrollIndexCallback, cellCount = cellSizeAndPositionManager.getCellCount(), hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount, sizeHasChanged = size !== previousSize || !previousCellSize || "number" == typeof cellSize && cellSize !== previousCellSize;
            // If we have a new scroll target OR if height/row-height has changed,
            // We should ensure that the scroll target is visible.
            hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex) ? updateScrollIndexCallback(scrollToIndex) : !hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount) && scrollOffset > cellSizeAndPositionManager.getTotalSize() - size && updateScrollIndexCallback(cellCount - 1);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = updateScrollIndexHelper;
    }, /* 228 */
    /***/
    function(module, exports) {
        "use strict";
        /**
	 * Default implementation of cellRangeRenderer used by Grid.
	 * This renderer supports cell-caching while the user is scrolling.
	 */
        function defaultCellRangeRenderer(_ref) {
            for (var cellCache = _ref.cellCache, cellRenderer = _ref.cellRenderer, columnSizeAndPositionManager = _ref.columnSizeAndPositionManager, columnStartIndex = _ref.columnStartIndex, columnStopIndex = _ref.columnStopIndex, horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment, isScrolling = _ref.isScrolling, rowSizeAndPositionManager = _ref.rowSizeAndPositionManager, rowStartIndex = _ref.rowStartIndex, rowStopIndex = _ref.rowStopIndex, styleCache = (_ref.scrollLeft, 
            _ref.scrollTop, _ref.styleCache), verticalOffsetAdjustment = _ref.verticalOffsetAdjustment, visibleColumnIndices = _ref.visibleColumnIndices, visibleRowIndices = _ref.visibleRowIndices, renderedCells = [], offsetAdjusted = verticalOffsetAdjustment || horizontalOffsetAdjustment, canCacheStyle = !isScrolling || !offsetAdjusted, rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) for (var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex), columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
                var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex), isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop, key = rowIndex + "-" + columnIndex, style = void 0;
                // Cache style objects so shallow-compare doesn't re-render unnecessarily.
                canCacheStyle && styleCache[key] ? style = styleCache[key] : (style = {
                    height: rowDatum.size,
                    left: columnDatum.offset + horizontalOffsetAdjustment,
                    position: "absolute",
                    top: rowDatum.offset + verticalOffsetAdjustment,
                    width: columnDatum.size
                }, styleCache[key] = style);
                var cellRendererParams = {
                    columnIndex: columnIndex,
                    isScrolling: isScrolling,
                    isVisible: isVisible,
                    key: key,
                    rowIndex: rowIndex,
                    style: style
                }, renderedCell = void 0;
                // Avoid re-creating cells while scrolling.
                // This can lead to the same cell being created many times and can cause performance issues for "heavy" cells.
                // If a scroll is in progress- cache and reuse cells.
                // This cache will be thrown away once scrolling completes.
                // However if we are scaling scroll positions and sizes, we should also avoid caching.
                // This is because the offset changes slightly as scroll position changes and caching leads to stale values.
                // For more info refer to issue #395
                !isScrolling || horizontalOffsetAdjustment || verticalOffsetAdjustment ? renderedCell = cellRenderer(cellRendererParams) : (cellCache[key] || (cellCache[key] = cellRenderer(cellRendererParams)), 
                renderedCell = cellCache[key]), null != renderedCell && renderedCell !== !1 && renderedCells.push(renderedCell);
            }
            return renderedCells;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.default = defaultCellRangeRenderer;
    }, /* 229 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  width: 2.5rem;\n  height: 2.5rem;\n  display: inline-flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  margin-left: 0.5rem;\n  padding: 0;\n  color: #fff;\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.25);\n  transition: 250ms all ease;\n" ], [ "\n  width: 2.5rem;\n  height: 2.5rem;\n  display: inline-flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  margin-left: 0.5rem;\n  padding: 0;\n  color: #fff;\n  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.25);\n  transition: 250ms all ease;\n" ]), _styledComponents = __webpack_require__(114), _styledComponents2 = _interopRequireDefault(_styledComponents);
        exports.default = _styledComponents2.default.button(_templateObject);
    }, /* 230 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function SvgIconWrapper(_ref) {
            var children = _ref.children, rest = (0, _objectWithoutProperties3.default)(_ref, [ "children" ]);
            return _react2.default.createElement("svg", (0, _extends3.default)({
                height: 24,
                preserveAspectRatio: "xMinYMax meet",
                viewBox: "0 0 24 24",
                width: 24
            }, rest), _react2.default.createElement("path", {
                d: "M0-.5h24v24H0z",
                fill: "none"
            }), children);
        }
        function IconLeft() {
            return _react2.default.createElement(SvgIconWrapper, null, _react2.default.createElement(Path, {
                d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
            }));
        }
        function IconMore() {
            return _react2.default.createElement(SvgIconWrapper, null, _react2.default.createElement(Path, {
                d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
            }));
        }
        function IconRight() {
            return _react2.default.createElement(SvgIconWrapper, null, _react2.default.createElement(Path, {
                d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
            }));
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _objectWithoutProperties2 = __webpack_require__(231), _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2), _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  fill: currentColor;\n" ], [ "\n  fill: currentColor;\n" ]);
        exports.SvgIconWrapper = SvgIconWrapper, exports.IconLeft = IconLeft, exports.IconMore = IconMore, 
        exports.IconRight = IconRight;
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _styledComponents = __webpack_require__(114), _styledComponents2 = _interopRequireDefault(_styledComponents), Path = _styledComponents2.default.path(_templateObject);
    }, /* 231 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0, exports.default = function(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        };
    }, /* 232 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.slideContext = exports.presentationContext = void 0;
        var _react = __webpack_require__(109);
        exports.presentationContext = _react.PropTypes.shape({
            getSlideIndex: _react.PropTypes.func.isRequired,
            getSlideMetadata: _react.PropTypes.func.isRequired,
            getStepIndex: _react.PropTypes.func.isRequired,
            goBack: _react.PropTypes.func.isRequired,
            goForward: _react.PropTypes.func.isRequired,
            goToSlide: _react.PropTypes.func.isRequired,
            isAtBeginning: _react.PropTypes.func.isRequired,
            isAtEnd: _react.PropTypes.func.isRequired,
            setPluginProps: _react.PropTypes.func.isRequired
        }), exports.slideContext = _react.PropTypes.shape({
            getNumSteps: _react.PropTypes.func.isRequired,
            registerStep: _react.PropTypes.func.isRequired,
            setNumSteps: _react.PropTypes.func.isRequired
        });
    }, /* 233 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  .Select {\n    position: relative;\n  }\n  .Select,\n  .Select div,\n  .Select input,\n  .Select span {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n  .Select.is-disabled > .Select-control {\n    background-color: #f9f9f9;\n  }\n  .Select.is-disabled > .Select-control:hover {\n    box-shadow: none;\n  }\n  .Select.is-disabled .Select-arrow-zone {\n    cursor: default;\n    pointer-events: none;\n    opacity: 0.35;\n  }\n  .Select-control {\n    background-color: #fff;\n    border-color: #d9d9d9 #ccc #b3b3b3;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n    color: #333;\n    cursor: default;\n    display: table;\n    border-spacing: 0;\n    border-collapse: separate;\n    height: 36px;\n    outline: none;\n    overflow: hidden;\n    position: relative;\n    width: 100%;\n  }\n  .Select-control:hover {\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n  }\n  .Select-control .Select-input:focus {\n    outline: none;\n  }\n  .is-searchable.is-open > .Select-control {\n    cursor: text;\n  }\n  .is-open > .Select-control {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n    background: #fff;\n    border-color: #b3b3b3 #ccc #d9d9d9;\n  }\n  .is-open > .Select-control > .Select-arrow {\n    border-color: transparent transparent #999;\n    border-width: 0 5px 5px;\n  }\n  .is-searchable.is-focused:not(.is-open) > .Select-control {\n    cursor: text;\n  }\n  .is-focused:not(.is-open) > .Select-control {\n    border-color: #007eff;\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 0 3px rgba(0, 126, 255, 0.1);\n  }\n  .Select-placeholder,\n  .Select--single > .Select-control .Select-value {\n    bottom: 0;\n    color: #aaa;\n    left: 0;\n    line-height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    position: absolute;\n    right: 0;\n    top: 0;\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n  .has-value.Select--single > .Select-control .Select-value .Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value .Select-value-label {\n    color: #333;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label {\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:focus,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:focus {\n    color: #007eff;\n    outline: none;\n    text-decoration: underline;\n  }\n  .Select-input {\n    height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    vertical-align: middle;\n  }\n  .Select-input > input {\n    width: 100%;\n    background: none transparent;\n    border: 0 none;\n    box-shadow: none;\n    cursor: default;\n    display: inline-block;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    outline: none;\n    line-height: 14px;\n    /* For IE 8 compatibility */\n    padding: 8px 0 12px;\n    /* For IE 8 compatibility */\n    -webkit-appearance: none;\n  }\n  .is-focused .Select-input > input {\n    cursor: text;\n  }\n  .has-value.is-pseudo-focused .Select-input {\n    opacity: 0;\n  }\n  .Select-control:not(.is-searchable) > .Select-input {\n    outline: none;\n  }\n  .Select-loading-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 16px;\n  }\n  .Select-loading {\n    -webkit-animation: Select-animation-spin 400ms infinite linear;\n    -o-animation: Select-animation-spin 400ms infinite linear;\n    animation: Select-animation-spin 400ms infinite linear;\n    width: 16px;\n    height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    border: 2px solid #ccc;\n    border-right-color: #333;\n    display: inline-block;\n    position: relative;\n    vertical-align: middle;\n  }\n  .Select-clear-zone {\n    -webkit-animation: Select-animation-fadeIn 200ms;\n    -o-animation: Select-animation-fadeIn 200ms;\n    animation: Select-animation-fadeIn 200ms;\n    color: #999;\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 17px;\n  }\n  .Select-clear-zone:hover {\n    color: #D0021B;\n  }\n  .Select-clear {\n    display: inline-block;\n    font-size: 18px;\n    line-height: 1;\n  }\n  .Select--multi .Select-clear-zone {\n    width: 17px;\n  }\n  .Select-arrow-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 25px;\n    padding-right: 5px;\n  }\n  .Select-arrow {\n    border-color: #999 transparent transparent;\n    border-style: solid;\n    border-width: 5px 5px 2.5px;\n    display: inline-block;\n    height: 0;\n    width: 0;\n  }\n  .is-open .Select-arrow,\n  .Select-arrow-zone:hover > .Select-arrow {\n    border-top-color: #666;\n  }\n  .Select--multi .Select-multi-value-wrapper {\n    display: inline-block;\n  }\n  .Select .Select-aria-only {\n    display: inline-block;\n    height: 1px;\n    width: 1px;\n    margin: -1px;\n    clip: rect(0, 0, 0, 0);\n    overflow: hidden;\n  }\n  @-webkit-keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  @keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  .Select-menu-outer {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n    background-color: #fff;\n    border: 1px solid #ccc;\n    border-top-color: #e6e6e6;\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n    box-sizing: border-box;\n    margin-top: -1px;\n    max-height: 200px;\n    position: absolute;\n    top: 100%;\n    width: 100%;\n    z-index: 1;\n    -webkit-overflow-scrolling: touch;\n  }\n  .Select-menu {\n    max-height: 198px;\n    overflow-y: auto;\n  }\n  .Select-option {\n    box-sizing: border-box;\n    background-color: #fff;\n    color: #666666;\n    cursor: pointer;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select-option:last-child {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n  .Select-option.is-selected {\n    background-color: #f5faff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.04);\n    color: #333;\n  }\n  .Select-option.is-focused {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    color: #333;\n  }\n  .Select-option.is-disabled {\n    color: #cccccc;\n    cursor: default;\n  }\n  .Select-noresults {\n    box-sizing: border-box;\n    color: #999999;\n    cursor: default;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select--multi .Select-input {\n    vertical-align: middle;\n    margin-left: 10px;\n    padding: 0;\n  }\n  .Select--multi.has-value .Select-input {\n    margin-left: 5px;\n  }\n  .Select--multi .Select-value {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    border-radius: 2px;\n    border: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border: 1px solid rgba(0, 126, 255, 0.24);\n    color: #007eff;\n    display: inline-block;\n    font-size: 0.9em;\n    line-height: 1.4;\n    margin-left: 5px;\n    margin-top: 5px;\n    vertical-align: top;\n  }\n  .Select--multi .Select-value-icon,\n  .Select--multi .Select-value-label {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  .Select--multi .Select-value-label {\n    border-bottom-right-radius: 2px;\n    border-top-right-radius: 2px;\n    cursor: default;\n    padding: 2px 5px;\n  }\n  .Select--multi a.Select-value-label {\n    color: #007eff;\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .Select--multi a.Select-value-label:hover {\n    text-decoration: underline;\n  }\n  .Select--multi .Select-value-icon {\n    cursor: pointer;\n    border-bottom-left-radius: 2px;\n    border-top-left-radius: 2px;\n    border-right: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border-right: 1px solid rgba(0, 126, 255, 0.24);\n    padding: 1px 5px 3px;\n  }\n  .Select--multi .Select-value-icon:hover,\n  .Select--multi .Select-value-icon:focus {\n    background-color: #d8eafd;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 113, 230, 0.08);\n    color: #0071e6;\n  }\n  .Select--multi .Select-value-icon:active {\n    background-color: #c2e0ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.24);\n  }\n  .Select--multi.is-disabled .Select-value {\n    background-color: #fcfcfc;\n    border: 1px solid #e3e3e3;\n    color: #333;\n  }\n  .Select--multi.is-disabled .Select-value-icon {\n    cursor: not-allowed;\n    border-right: 1px solid #e3e3e3;\n  }\n  .Select--multi.is-disabled .Select-value-icon:hover,\n  .Select--multi.is-disabled .Select-value-icon:focus,\n  .Select--multi.is-disabled .Select-value-icon:active {\n    background-color: #fcfcfc;\n  }\n  @keyframes Select-animation-spin {\n    to {\n      transform: rotate(1turn);\n    }\n  }\n  @-webkit-keyframes Select-animation-spin {\n    to {\n      -webkit-transform: rotate(1turn);\n    }\n  }\n\n  .VirtualSelectGrid {\n    z-index: 1;\n  }\n\n  .VirtualizedSelectOption {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    padding: 0 .5rem;\n  }\n  .VirtualizedSelectFocusedOption {\n    background-color: rgba(0, 126, 255, 0.1);\n  }\n  .VirtualizedSelectDisabledOption {\n    opacity: 0.5;\n  }\n" ], [ "\n  .Select {\n    position: relative;\n  }\n  .Select,\n  .Select div,\n  .Select input,\n  .Select span {\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n  }\n  .Select.is-disabled > .Select-control {\n    background-color: #f9f9f9;\n  }\n  .Select.is-disabled > .Select-control:hover {\n    box-shadow: none;\n  }\n  .Select.is-disabled .Select-arrow-zone {\n    cursor: default;\n    pointer-events: none;\n    opacity: 0.35;\n  }\n  .Select-control {\n    background-color: #fff;\n    border-color: #d9d9d9 #ccc #b3b3b3;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n    color: #333;\n    cursor: default;\n    display: table;\n    border-spacing: 0;\n    border-collapse: separate;\n    height: 36px;\n    outline: none;\n    overflow: hidden;\n    position: relative;\n    width: 100%;\n  }\n  .Select-control:hover {\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n  }\n  .Select-control .Select-input:focus {\n    outline: none;\n  }\n  .is-searchable.is-open > .Select-control {\n    cursor: text;\n  }\n  .is-open > .Select-control {\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n    background: #fff;\n    border-color: #b3b3b3 #ccc #d9d9d9;\n  }\n  .is-open > .Select-control > .Select-arrow {\n    border-color: transparent transparent #999;\n    border-width: 0 5px 5px;\n  }\n  .is-searchable.is-focused:not(.is-open) > .Select-control {\n    cursor: text;\n  }\n  .is-focused:not(.is-open) > .Select-control {\n    border-color: #007eff;\n    box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075), 0 0 0 3px rgba(0, 126, 255, 0.1);\n  }\n  .Select-placeholder,\n  .Select--single > .Select-control .Select-value {\n    bottom: 0;\n    color: #aaa;\n    left: 0;\n    line-height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    position: absolute;\n    right: 0;\n    top: 0;\n    max-width: 100%;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n  }\n  .has-value.Select--single > .Select-control .Select-value .Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value .Select-value-label {\n    color: #333;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label {\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:hover,\n  .has-value.Select--single > .Select-control .Select-value a.Select-value-label:focus,\n  .has-value.is-pseudo-focused.Select--single > .Select-control .Select-value a.Select-value-label:focus {\n    color: #007eff;\n    outline: none;\n    text-decoration: underline;\n  }\n  .Select-input {\n    height: 34px;\n    padding-left: 10px;\n    padding-right: 10px;\n    vertical-align: middle;\n  }\n  .Select-input > input {\n    width: 100%;\n    background: none transparent;\n    border: 0 none;\n    box-shadow: none;\n    cursor: default;\n    display: inline-block;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    outline: none;\n    line-height: 14px;\n    /* For IE 8 compatibility */\n    padding: 8px 0 12px;\n    /* For IE 8 compatibility */\n    -webkit-appearance: none;\n  }\n  .is-focused .Select-input > input {\n    cursor: text;\n  }\n  .has-value.is-pseudo-focused .Select-input {\n    opacity: 0;\n  }\n  .Select-control:not(.is-searchable) > .Select-input {\n    outline: none;\n  }\n  .Select-loading-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 16px;\n  }\n  .Select-loading {\n    -webkit-animation: Select-animation-spin 400ms infinite linear;\n    -o-animation: Select-animation-spin 400ms infinite linear;\n    animation: Select-animation-spin 400ms infinite linear;\n    width: 16px;\n    height: 16px;\n    box-sizing: border-box;\n    border-radius: 50%;\n    border: 2px solid #ccc;\n    border-right-color: #333;\n    display: inline-block;\n    position: relative;\n    vertical-align: middle;\n  }\n  .Select-clear-zone {\n    -webkit-animation: Select-animation-fadeIn 200ms;\n    -o-animation: Select-animation-fadeIn 200ms;\n    animation: Select-animation-fadeIn 200ms;\n    color: #999;\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 17px;\n  }\n  .Select-clear-zone:hover {\n    color: #D0021B;\n  }\n  .Select-clear {\n    display: inline-block;\n    font-size: 18px;\n    line-height: 1;\n  }\n  .Select--multi .Select-clear-zone {\n    width: 17px;\n  }\n  .Select-arrow-zone {\n    cursor: pointer;\n    display: table-cell;\n    position: relative;\n    text-align: center;\n    vertical-align: middle;\n    width: 25px;\n    padding-right: 5px;\n  }\n  .Select-arrow {\n    border-color: #999 transparent transparent;\n    border-style: solid;\n    border-width: 5px 5px 2.5px;\n    display: inline-block;\n    height: 0;\n    width: 0;\n  }\n  .is-open .Select-arrow,\n  .Select-arrow-zone:hover > .Select-arrow {\n    border-top-color: #666;\n  }\n  .Select--multi .Select-multi-value-wrapper {\n    display: inline-block;\n  }\n  .Select .Select-aria-only {\n    display: inline-block;\n    height: 1px;\n    width: 1px;\n    margin: -1px;\n    clip: rect(0, 0, 0, 0);\n    overflow: hidden;\n  }\n  @-webkit-keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  @keyframes Select-animation-fadeIn {\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  }\n  .Select-menu-outer {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n    background-color: #fff;\n    border: 1px solid #ccc;\n    border-top-color: #e6e6e6;\n    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n    box-sizing: border-box;\n    margin-top: -1px;\n    max-height: 200px;\n    position: absolute;\n    top: 100%;\n    width: 100%;\n    z-index: 1;\n    -webkit-overflow-scrolling: touch;\n  }\n  .Select-menu {\n    max-height: 198px;\n    overflow-y: auto;\n  }\n  .Select-option {\n    box-sizing: border-box;\n    background-color: #fff;\n    color: #666666;\n    cursor: pointer;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select-option:last-child {\n    border-bottom-right-radius: 4px;\n    border-bottom-left-radius: 4px;\n  }\n  .Select-option.is-selected {\n    background-color: #f5faff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.04);\n    color: #333;\n  }\n  .Select-option.is-focused {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    color: #333;\n  }\n  .Select-option.is-disabled {\n    color: #cccccc;\n    cursor: default;\n  }\n  .Select-noresults {\n    box-sizing: border-box;\n    color: #999999;\n    cursor: default;\n    display: block;\n    padding: 8px 10px;\n  }\n  .Select--multi .Select-input {\n    vertical-align: middle;\n    margin-left: 10px;\n    padding: 0;\n  }\n  .Select--multi.has-value .Select-input {\n    margin-left: 5px;\n  }\n  .Select--multi .Select-value {\n    background-color: #ebf5ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.08);\n    border-radius: 2px;\n    border: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border: 1px solid rgba(0, 126, 255, 0.24);\n    color: #007eff;\n    display: inline-block;\n    font-size: 0.9em;\n    line-height: 1.4;\n    margin-left: 5px;\n    margin-top: 5px;\n    vertical-align: top;\n  }\n  .Select--multi .Select-value-icon,\n  .Select--multi .Select-value-label {\n    display: inline-block;\n    vertical-align: middle;\n  }\n  .Select--multi .Select-value-label {\n    border-bottom-right-radius: 2px;\n    border-top-right-radius: 2px;\n    cursor: default;\n    padding: 2px 5px;\n  }\n  .Select--multi a.Select-value-label {\n    color: #007eff;\n    cursor: pointer;\n    text-decoration: none;\n  }\n  .Select--multi a.Select-value-label:hover {\n    text-decoration: underline;\n  }\n  .Select--multi .Select-value-icon {\n    cursor: pointer;\n    border-bottom-left-radius: 2px;\n    border-top-left-radius: 2px;\n    border-right: 1px solid #c2e0ff;\n    /* Fallback color for IE 8 */\n    border-right: 1px solid rgba(0, 126, 255, 0.24);\n    padding: 1px 5px 3px;\n  }\n  .Select--multi .Select-value-icon:hover,\n  .Select--multi .Select-value-icon:focus {\n    background-color: #d8eafd;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 113, 230, 0.08);\n    color: #0071e6;\n  }\n  .Select--multi .Select-value-icon:active {\n    background-color: #c2e0ff;\n    /* Fallback color for IE 8 */\n    background-color: rgba(0, 126, 255, 0.24);\n  }\n  .Select--multi.is-disabled .Select-value {\n    background-color: #fcfcfc;\n    border: 1px solid #e3e3e3;\n    color: #333;\n  }\n  .Select--multi.is-disabled .Select-value-icon {\n    cursor: not-allowed;\n    border-right: 1px solid #e3e3e3;\n  }\n  .Select--multi.is-disabled .Select-value-icon:hover,\n  .Select--multi.is-disabled .Select-value-icon:focus,\n  .Select--multi.is-disabled .Select-value-icon:active {\n    background-color: #fcfcfc;\n  }\n  @keyframes Select-animation-spin {\n    to {\n      transform: rotate(1turn);\n    }\n  }\n  @-webkit-keyframes Select-animation-spin {\n    to {\n      -webkit-transform: rotate(1turn);\n    }\n  }\n\n  .VirtualSelectGrid {\n    z-index: 1;\n  }\n\n  .VirtualizedSelectOption {\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n    -webkit-box-align: center;\n        -ms-flex-align: center;\n            align-items: center;\n    padding: 0 .5rem;\n  }\n  .VirtualizedSelectFocusedOption {\n    background-color: rgba(0, 126, 255, 0.1);\n  }\n  .VirtualizedSelectDisabledOption {\n    opacity: 0.5;\n  }\n" ]), _styledComponents = __webpack_require__(114);
        (0, _styledComponents.injectGlobal)(_templateObject);
    }, /* 234 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends2 = __webpack_require__(68), _extends3 = _interopRequireDefault(_extends2), _keys = __webpack_require__(235), _keys2 = _interopRequireDefault(_keys), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(101), _inherits3 = _interopRequireDefault(_inherits2), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _reactRouter = __webpack_require__(238), _reactRouterDom = __webpack_require__(258), _DefaultTheme = __webpack_require__(276), _DefaultTheme2 = _interopRequireDefault(_DefaultTheme), _PropTypes = __webpack_require__(232), _TouchNav = __webpack_require__(277), _TouchNav2 = _interopRequireDefault(_TouchNav), Presentation = function(_Component) {
            function Presentation() {
                return (0, _classCallCheck3.default)(this, Presentation), (0, _possibleConstructorReturn3.default)(this, (Presentation.__proto__ || (0, 
                _getPrototypeOf2.default)(Presentation)).apply(this, arguments));
            }
            return (0, _inherits3.default)(Presentation, _Component), (0, _createClass3.default)(Presentation, [ {
                key: "render",
                value: function() {
                    var Router = this.props.router;
                    return _react2.default.createElement(Router, null, _react2.default.createElement(PresentationInner, this.props));
                }
            } ]), Presentation;
        }(_react.Component);
        Presentation.defaultProps = {
            disableTheme: !1,
            router: _reactRouterDom.HashRouter
        }, exports.default = Presentation;
        var PresentationInner = function(_Component2) {
            function PresentationInner(props, context) {
                (0, _classCallCheck3.default)(this, PresentationInner);
                var _this2 = (0, _possibleConstructorReturn3.default)(this, (PresentationInner.__proto__ || (0, 
                _getPrototypeOf2.default)(PresentationInner)).call(this, props, context));
                return _this2.state = {
                    pluginProps: {}
                }, _this2._index = 0, _this2._slideIndex = 0, _this2._slideIndexMap = {}, _this2._stepIndex = 0, 
                _this2.getSlideIndex = _this2.getSlideIndex.bind(_this2), _this2.getSlideMetadata = _this2.getSlideMetadata.bind(_this2), 
                _this2.getStepIndex = _this2.getStepIndex.bind(_this2), _this2.goBack = _this2.goBack.bind(_this2), 
                _this2.goForward = _this2.goForward.bind(_this2), _this2.goToSlide = _this2.goToSlide.bind(_this2), 
                _this2.setPluginProps = _this2.setPluginProps.bind(_this2), _this2._onKeyDown = _this2._onKeyDown.bind(_this2), 
                _this2;
            }
            return (0, _inherits3.default)(PresentationInner, _Component2), (0, _createClass3.default)(PresentationInner, [ {
                key: "componentDidMount",
                value: function() {
                    document.body.addEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillMount",
                value: function() {
                    this._parseLocation(window.location);
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    document.body.removeEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState) {
                    this._parseLocation(window.location);
                }
            }, {
                key: "getChildContext",
                value: function() {
                    var pluginProps = this.state.pluginProps;
                    return {
                        pluginProps: pluginProps,
                        presentation: this
                    };
                }
            }, {
                key: "getSlideIndex",
                value: function() {
                    return this._slideIndex;
                }
            }, {
                key: "getSlideMetadata",
                value: function(slide) {
                    var slideIndex = this._index;
                    this._slideIndexMap[slideIndex] = slide, this._index++;
                    var path = this._createPath({
                        slideIndex: slideIndex
                    });
                    return {
                        path: path,
                        slideIndex: slideIndex
                    };
                }
            }, {
                key: "getStepIndex",
                value: function() {
                    return this._stepIndex;
                }
            }, {
                key: "goBack",
                value: function() {
                    var slideIndex = this._slideIndex, stepIndex = this._stepIndex;
                    stepIndex > 0 ? this.goToSlide({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex - 1
                    }) : slideIndex > 0 && (slideIndex--, this.goToSlide({
                        slideIndex: slideIndex
                    }), stepIndex = this._getNumStepsForSlide(slideIndex) - 1, this.goToSlide({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }));
                }
            }, {
                key: "goForward",
                value: function() {
                    var slideIndex = this._slideIndex, stepIndex = this._stepIndex, numCurrentSlideSteps = this._getNumStepsForSlide(slideIndex), numSlides = (0, 
                    _keys2.default)(this._slideIndexMap).length;
                    stepIndex + 1 < numCurrentSlideSteps ? stepIndex++ : slideIndex + 1 < numSlides && (slideIndex++, 
                    stepIndex = 0), this.goToSlide({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    });
                }
            }, {
                key: "goToSlide",
                value: function(_ref) {
                    var slideIndex = _ref.slideIndex, _ref$stepIndex = _ref.stepIndex, stepIndex = void 0 === _ref$stepIndex ? 0 : _ref$stepIndex;
                    if (slideIndex !== this._slideIndex || stepIndex !== this._stepIndex) {
                        var router = this.context.router, path = this._createPath({
                            slideIndex: slideIndex,
                            stepIndex: stepIndex
                        });
                        router.replace(path), this.forceUpdate();
                    }
                }
            }, {
                key: "isAtBeginning",
                value: function() {
                    return 0 === this._slideIndex && 0 === this._stepIndex;
                }
            }, {
                key: "isAtEnd",
                value: function() {
                    var numSlides = (0, _keys2.default)(this._slideIndexMap).length, numLastSlideSteps = this._getNumStepsForSlide(numSlides - 1);
                    return this._slideIndex === numSlides - 1 && this._stepIndex === numLastSlideSteps - 1;
                }
            }, {
                key: "setPluginProps",
                value: function(props) {
                    var pluginProps = this.state.pluginProps;
                    this.setState({
                        pluginProps: (0, _extends3.default)({}, pluginProps, props)
                    });
                }
            }, {
                key: "render",
                value: function() {
                    var _props = this.props, children = _props.children, disableTheme = _props.disableTheme;
                    return _react2.default.createElement("div", {
                        style: {
                            height: "100%",
                            width: "100%"
                        }
                    }, !disableTheme && _react2.default.createElement(_DefaultTheme2.default, null), _react2.default.createElement(_reactRouterDom.Route, {
                        exact: !0,
                        path: "/",
                        render: function() {
                            return _react2.default.createElement(_reactRouter.Redirect, {
                                to: "/0/0"
                            });
                        }
                    }), "function" == typeof children ? children({
                        presentation: this
                    }) : children, _react2.default.createElement(_TouchNav2.default, null));
                }
            }, {
                key: "_createPath",
                value: function(_ref2) {
                    var slideIndex = _ref2.slideIndex, _ref2$stepIndex = _ref2.stepIndex, stepIndex = void 0 === _ref2$stepIndex ? ":step" : _ref2$stepIndex;
                    return "/" + slideIndex + "/" + stepIndex;
                }
            }, {
                key: "_getNumStepsForSlide",
                value: function(slideIndex) {
                    return this._slideIndexMap[slideIndex].getNumSteps() || 1;
                }
            }, {
                key: "_parseLocation",
                value: function(location) {
                    var parsed = (location.pathname + location.hash).match(/(\d+)\/(\d+)/);
                    parsed ? (this._slideIndex = parseInt(parsed[1], 10), this._stepIndex = parseInt(parsed[2], 10)) : (this._slideIndex = 0, 
                    this._stepIndex = 0);
                }
            }, {
                key: "_onKeyDown",
                value: function(event) {
                    if ("INPUT" !== event.target.tagName) switch (event.key) {
                      case "ArrowLeft":
                      case "PageUp":
                        this.goBack();
                        break;

                      case "ArrowRight":
                      case "PageDown":
                      case "Enter":
                      case " ":
                        this.goForward();
                    }
                }
            } ]), PresentationInner;
        }(_react.Component);
        PresentationInner.childContextTypes = {
            pluginProps: _react.PropTypes.object.isRequired,
            presentation: _PropTypes.presentationContext.isRequired
        }, PresentationInner.contextTypes = {
            router: _react.PropTypes.object.isRequired
        };
    }, /* 235 */
    /***/
    function(module, exports, __webpack_require__) {
        module.exports = {
            default: __webpack_require__(236),
            __esModule: !0
        };
    }, /* 236 */
    /***/
    function(module, exports, __webpack_require__) {
        __webpack_require__(237), module.exports = __webpack_require__(8).Object.keys;
    }, /* 237 */
    /***/
    function(module, exports, __webpack_require__) {
        // 19.1.2.14 Object.keys(O)
        var toObject = __webpack_require__(59), $keys = __webpack_require__(22);
        __webpack_require__(41)("keys", function() {
            return function(it) {
                return $keys(toObject(it));
            };
        });
    }, /* 238 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0, exports.withRouter = exports.matchPath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.MemoryRouter = void 0;
        var _MemoryRouter2 = __webpack_require__(239), _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2), _Prompt2 = __webpack_require__(249), _Prompt3 = _interopRequireDefault(_Prompt2), _Redirect2 = __webpack_require__(250), _Redirect3 = _interopRequireDefault(_Redirect2), _Route2 = __webpack_require__(251), _Route3 = _interopRequireDefault(_Route2), _Router2 = __webpack_require__(247), _Router3 = _interopRequireDefault(_Router2), _StaticRouter2 = __webpack_require__(255), _StaticRouter3 = _interopRequireDefault(_StaticRouter2), _Switch2 = __webpack_require__(256), _Switch3 = _interopRequireDefault(_Switch2), _matchPath2 = __webpack_require__(252), _matchPath3 = _interopRequireDefault(_matchPath2), _withRouter2 = __webpack_require__(257), _withRouter3 = _interopRequireDefault(_withRouter2);
        exports.MemoryRouter = _MemoryRouter3.default, exports.Prompt = _Prompt3.default, 
        exports.Redirect = _Redirect3.default, exports.Route = _Route3.default, exports.Router = _Router3.default, 
        exports.StaticRouter = _StaticRouter3.default, exports.Switch = _Switch3.default, 
        exports.matchPath = _matchPath3.default, exports.withRouter = _withRouter3.default;
    }, /* 239 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _createMemoryHistory = __webpack_require__(240), _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory), _Router = __webpack_require__(247), _Router2 = _interopRequireDefault(_Router), MemoryRouter = function(_React$Component) {
            function MemoryRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, MemoryRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.history = (0, _createMemoryHistory2.default)(_this.props), _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(MemoryRouter, _React$Component), MemoryRouter.prototype.render = function() {
                return _react2.default.createElement(_Router2.default, {
                    history: this.history,
                    children: this.props.children
                });
            }, MemoryRouter;
        }(_react2.default.Component);
        MemoryRouter.propTypes = {
            initialEntries: _react.PropTypes.array,
            initialIndex: _react.PropTypes.number,
            getUserConfirmation: _react.PropTypes.func,
            keyLength: _react.PropTypes.number,
            children: _react.PropTypes.node
        }, exports.default = MemoryRouter;
    }, /* 240 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _warning = __webpack_require__(241), _warning2 = _interopRequireDefault(_warning), _PathUtils = __webpack_require__(242), _LocationUtils = __webpack_require__(243), _createTransitionManager = __webpack_require__(246), _createTransitionManager2 = _interopRequireDefault(_createTransitionManager), clamp = function(n, lowerBound, upperBound) {
                return Math.min(Math.max(n, lowerBound), upperBound);
            }, createMemoryHistory = function() {
                var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, getUserConfirmation = props.getUserConfirmation, _props$initialEntries = props.initialEntries, initialEntries = void 0 === _props$initialEntries ? [ "/" ] : _props$initialEntries, _props$initialIndex = props.initialIndex, initialIndex = void 0 === _props$initialIndex ? 0 : _props$initialIndex, _props$keyLength = props.keyLength, keyLength = void 0 === _props$keyLength ? 6 : _props$keyLength, transitionManager = (0, 
                _createTransitionManager2.default)(), setState = function(nextState) {
                    _extends(history, nextState), history.length = history.entries.length, transitionManager.notifyListeners(history.location, history.action);
                }, createKey = function() {
                    return Math.random().toString(36).substr(2, keyLength);
                }, index = clamp(initialIndex, 0, initialEntries.length - 1), entries = initialEntries.map(function(entry, index) {
                    return "string" == typeof entry ? (0, _LocationUtils.createLocation)(entry, void 0, index ? createKey() : void 0) : (0, 
                    _LocationUtils.createLocation)(entry, void 0, index ? entry.key || createKey() : void 0);
                }), createHref = _PathUtils.createPath, push = function(path, state) {
                    "production" !== process.env.NODE_ENV ? (0, _warning2.default)(!("object" === ("undefined" == typeof path ? "undefined" : _typeof(path)) && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
                    var action = "PUSH", location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        if (ok) {
                            var prevIndex = history.index, nextIndex = prevIndex + 1, nextEntries = history.entries.slice(0);
                            nextEntries.length > nextIndex ? nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location) : nextEntries.push(location), 
                            setState({
                                action: action,
                                location: location,
                                index: nextIndex,
                                entries: nextEntries
                            });
                        }
                    });
                }, replace = function(path, state) {
                    "production" !== process.env.NODE_ENV ? (0, _warning2.default)(!("object" === ("undefined" == typeof path ? "undefined" : _typeof(path)) && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
                    var action = "REPLACE", location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        ok && (history.entries[history.index] = location, setState({
                            action: action,
                            location: location
                        }));
                    });
                }, go = function(n) {
                    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1), action = "POP", location = history.entries[nextIndex];
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        ok ? setState({
                            action: action,
                            location: location,
                            index: nextIndex
                        }) : // Mimic the behavior of DOM histories by
                        // causing a render after a cancelled POP.
                        setState();
                    });
                }, goBack = function() {
                    return go(-1);
                }, goForward = function() {
                    return go(1);
                }, canGo = function(n) {
                    var nextIndex = history.index + n;
                    return nextIndex >= 0 && nextIndex < history.entries.length;
                }, block = function() {
                    var prompt = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    return transitionManager.setPrompt(prompt);
                }, listen = function(listener) {
                    return transitionManager.appendListener(listener);
                }, history = {
                    length: entries.length,
                    action: "POP",
                    location: entries[index],
                    index: index,
                    entries: entries,
                    createHref: createHref,
                    push: push,
                    replace: replace,
                    go: go,
                    goBack: goBack,
                    goForward: goForward,
                    canGo: canGo,
                    block: block,
                    listen: listen
                };
                return history;
            };
            exports.default = createMemoryHistory;
        }).call(exports, __webpack_require__(153));
    }, /* 241 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
            "use strict";
            /**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
            var warning = function() {};
            "production" !== process.env.NODE_ENV && (warning = function(condition, format, args) {
                var len = arguments.length;
                args = new Array(len > 2 ? len - 2 : 0);
                for (var key = 2; key < len; key++) args[key - 2] = arguments[key];
                if (void 0 === format) throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
                if (format.length < 10 || /^[s\W]*$/.test(format)) throw new Error("The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: " + format);
                if (!condition) {
                    var argIndex = 0, message = "Warning: " + format.replace(/%s/g, function() {
                        return args[argIndex++];
                    });
                    "undefined" != typeof console && console.error(message);
                    try {
                        // This error was thrown as a convenience so that you can use this stack
                        // to find the callsite that caused this warning to fire.
                        throw new Error(message);
                    } catch (x) {}
                }
            }), module.exports = warning;
        }).call(exports, __webpack_require__(153));
    }, /* 242 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0;
        exports.addLeadingSlash = function(path) {
            return "/" === path.charAt(0) ? path : "/" + path;
        }, exports.stripLeadingSlash = function(path) {
            return "/" === path.charAt(0) ? path.substr(1) : path;
        }, exports.stripPrefix = function(path, prefix) {
            return 0 === path.indexOf(prefix) ? path.substr(prefix.length) : path;
        }, exports.parsePath = function(path) {
            var pathname = path || "/", search = "", hash = "", hashIndex = pathname.indexOf("#");
            hashIndex !== -1 && (hash = pathname.substr(hashIndex), pathname = pathname.substr(0, hashIndex));
            var searchIndex = pathname.indexOf("?");
            return searchIndex !== -1 && (search = pathname.substr(searchIndex), pathname = pathname.substr(0, searchIndex)), 
            {
                pathname: pathname,
                search: "?" === search ? "" : search,
                hash: "#" === hash ? "" : hash
            };
        }, exports.createPath = function(location) {
            var pathname = location.pathname, search = location.search, hash = location.hash, path = pathname || "/";
            return search && "?" !== search && (path += "?" === search.charAt(0) ? search : "?" + search), 
            hash && "#" !== hash && (path += "#" === hash.charAt(0) ? hash : "#" + hash), path;
        };
    }, /* 243 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0, exports.locationsAreEqual = exports.createLocation = void 0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _resolvePathname = __webpack_require__(244), _resolvePathname2 = _interopRequireDefault(_resolvePathname), _valueEqual = __webpack_require__(245), _valueEqual2 = _interopRequireDefault(_valueEqual), _PathUtils = __webpack_require__(242);
        exports.createLocation = function(path, state, key, currentLocation) {
            var location = void 0;
            // Two-arg form: push(path, state)
            // One-arg form: push(location)
            // Resolve incomplete/relative pathname relative to current location.
            return "string" == typeof path ? (location = (0, _PathUtils.parsePath)(path), location.state = state) : (location = _extends({}, path), 
            void 0 === location.pathname && (location.pathname = ""), location.search ? "?" !== location.search.charAt(0) && (location.search = "?" + location.search) : location.search = "", 
            location.hash ? "#" !== location.hash.charAt(0) && (location.hash = "#" + location.hash) : location.hash = "", 
            void 0 !== state && void 0 === location.state && (location.state = state)), location.key = key, 
            currentLocation && (location.pathname ? "/" !== location.pathname.charAt(0) && (location.pathname = (0, 
            _resolvePathname2.default)(location.pathname, currentLocation.pathname)) : location.pathname = currentLocation.pathname), 
            location;
        }, exports.locationsAreEqual = function(a, b) {
            return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, 
            _valueEqual2.default)(a.state, b.state);
        };
    }, /* 244 */
    /***/
    function(module, exports) {
        "use strict";
        var isAbsolute = function(pathname) {
            return "/" === pathname.charAt(0);
        }, spliceOne = function(list, index) {
            for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
            list.pop();
        }, resolvePathname = function(to) {
            var from = arguments.length <= 1 || void 0 === arguments[1] ? "" : arguments[1], toParts = to && to.split("/") || [], fromParts = from && from.split("/") || [], isToAbs = to && isAbsolute(to), isFromAbs = from && isAbsolute(from), mustEndAbs = isToAbs || isFromAbs;
            if (to && isAbsolute(to) ? // to is absolute
            fromParts = toParts : toParts.length && (// to is relative, drop the filename
            fromParts.pop(), fromParts = fromParts.concat(toParts)), !fromParts.length) return "/";
            var hasTrailingSlash = void 0;
            if (fromParts.length) {
                var last = fromParts[fromParts.length - 1];
                hasTrailingSlash = "." === last || ".." === last || "" === last;
            } else hasTrailingSlash = !1;
            for (var up = 0, i = fromParts.length; i >= 0; i--) {
                var part = fromParts[i];
                "." === part ? spliceOne(fromParts, i) : ".." === part ? (spliceOne(fromParts, i), 
                up++) : up && (spliceOne(fromParts, i), up--);
            }
            if (!mustEndAbs) for (;up--; up) fromParts.unshift("..");
            !mustEndAbs || "" === fromParts[0] || fromParts[0] && isAbsolute(fromParts[0]) || fromParts.unshift("");
            var result = fromParts.join("/");
            return hasTrailingSlash && "/" !== result.substr(-1) && (result += "/"), result;
        };
        module.exports = resolvePathname;
    }, /* 245 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0;
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, valueEqual = function valueEqual(a, b) {
            if (a === b) return !0;
            if (null == a || null == b) return !1;
            if (Array.isArray(a)) return !(!Array.isArray(b) || a.length !== b.length) && a.every(function(item, index) {
                return valueEqual(item, b[index]);
            });
            var aType = "undefined" == typeof a ? "undefined" : _typeof(a), bType = "undefined" == typeof b ? "undefined" : _typeof(b);
            if (aType !== bType) return !1;
            if ("object" === aType) {
                var aValue = a.valueOf(), bValue = b.valueOf();
                if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);
                var aKeys = Object.keys(a), bKeys = Object.keys(b);
                return aKeys.length === bKeys.length && aKeys.every(function(key) {
                    return valueEqual(a[key], b[key]);
                });
            }
            return !1;
        };
        exports.default = valueEqual;
    }, /* 246 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }
            exports.__esModule = !0;
            var _warning = __webpack_require__(241), _warning2 = _interopRequireDefault(_warning), createTransitionManager = function() {
                var prompt = null, setPrompt = function(nextPrompt) {
                    return "production" !== process.env.NODE_ENV ? (0, _warning2.default)(null == prompt, "A history supports only one prompt at a time") : void 0, 
                    prompt = nextPrompt, function() {
                        prompt === nextPrompt && (prompt = null);
                    };
                }, confirmTransitionTo = function(location, action, getUserConfirmation, callback) {
                    // TODO: If another transition starts while we're still confirming
                    // the previous one, we may end up in a weird state. Figure out the
                    // best way to handle this.
                    if (null != prompt) {
                        var result = "function" == typeof prompt ? prompt(location, action) : prompt;
                        "string" == typeof result ? "function" == typeof getUserConfirmation ? getUserConfirmation(result, callback) : ("production" !== process.env.NODE_ENV ? (0, 
                        _warning2.default)(!1, "A history needs a getUserConfirmation function in order to use a prompt message") : void 0, 
                        callback(!0)) : // Return false from a transition hook to cancel the transition.
                        callback(result !== !1);
                    } else callback(!0);
                }, listeners = [], appendListener = function(fn) {
                    var isActive = !0, listener = function() {
                        isActive && fn.apply(void 0, arguments);
                    };
                    return listeners.push(listener), function() {
                        isActive = !1, listeners = listeners.filter(function(item) {
                            return item !== listener;
                        });
                    };
                }, notifyListeners = function() {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    listeners.forEach(function(listener) {
                        return listener.apply(void 0, args);
                    });
                };
                return {
                    setPrompt: setPrompt,
                    confirmTransitionTo: confirmTransitionTo,
                    appendListener: appendListener,
                    notifyListeners: notifyListeners
                };
            };
            exports.default = createTransitionManager;
        }).call(exports, __webpack_require__(153));
    }, /* 247 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _invariant = __webpack_require__(248), _invariant2 = _interopRequireDefault(_invariant), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), Router = function(_React$Component) {
            function Router() {
                return _classCallCheck(this, Router), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Router, _React$Component), Router.prototype.getChildContext = function() {
                return {
                    router: this.props.history
                };
            }, Router.prototype.componentWillMount = function() {
                var children = this.props.children;
                (0, _invariant2.default)(null == children || 1 === _react2.default.Children.count(children), "A <Router> may have only one child element");
            }, Router.prototype.render = function() {
                var children = this.props.children;
                return children ? _react2.default.Children.only(children) : null;
            }, Router;
        }(_react2.default.Component);
        Router.propTypes = {
            history: _react.PropTypes.object.isRequired,
            children: _react.PropTypes.node
        }, Router.childContextTypes = {
            router: _react.PropTypes.object.isRequired
        }, exports.default = Router;
    }, /* 248 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            /**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
            "use strict";
            /**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
            var invariant = function(condition, format, a, b, c, d, e, f) {
                if ("production" !== process.env.NODE_ENV && void 0 === format) throw new Error("invariant requires an error message argument");
                if (!condition) {
                    var error;
                    if (void 0 === format) error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else {
                        var args = [ a, b, c, d, e, f ], argIndex = 0;
                        error = new Error(format.replace(/%s/g, function() {
                            return args[argIndex++];
                        })), error.name = "Invariant Violation";
                    }
                    // we don't care about invariant's own frame
                    throw error.framesToPop = 1, error;
                }
            };
            module.exports = invariant;
        }).call(exports, __webpack_require__(153));
    }, /* 249 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), Prompt = function(_React$Component) {
            function Prompt() {
                return _classCallCheck(this, Prompt), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Prompt, _React$Component), Prompt.prototype.enable = function(message) {
                this.unblock && this.unblock(), this.unblock = this.context.router.block(message);
            }, Prompt.prototype.disable = function() {
                this.unblock && (this.unblock(), this.unblock = null);
            }, Prompt.prototype.componentWillMount = function() {
                this.props.when && this.enable(this.props.message);
            }, Prompt.prototype.componentWillReceiveProps = function(nextProps) {
                nextProps.when ? this.props.when && this.props.message === nextProps.message || this.enable(nextProps.message) : this.disable();
            }, Prompt.prototype.componentWillUnmount = function() {
                this.disable();
            }, Prompt.prototype.render = function() {
                return null;
            }, Prompt;
        }(_react2.default.Component);
        Prompt.contextTypes = {
            router: _react.PropTypes.shape({
                block: _react.PropTypes.func.isRequired
            }).isRequired
        }, Prompt.propTypes = {
            when: _react.PropTypes.bool,
            message: _react.PropTypes.oneOfType([ _react.PropTypes.func, _react.PropTypes.string ]).isRequired
        }, Prompt.defaultProps = {
            when: !0
        }, exports.default = Prompt;
    }, /* 250 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), Redirect = function(_React$Component) {
            function Redirect() {
                return _classCallCheck(this, Redirect), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Redirect, _React$Component), Redirect.prototype.componentWillMount = function() {
                this.context.router.staticContext && this.perform();
            }, Redirect.prototype.componentDidMount = function() {
                this.context.router.staticContext || this.perform();
            }, Redirect.prototype.perform = function() {
                var router = this.context.router, _props = this.props, push = _props.push, to = _props.to;
                push ? router.push(to) : router.replace(to);
            }, Redirect.prototype.render = function() {
                return null;
            }, Redirect;
        }(_react2.default.Component);
        Redirect.contextTypes = {
            router: _react.PropTypes.shape({
                push: _react.PropTypes.func.isRequired,
                replace: _react.PropTypes.func.isRequired,
                staticContext: _react.PropTypes.object
            }).isRequired
        }, Redirect.propTypes = {
            push: _react.PropTypes.bool,
            to: _react.PropTypes.oneOfType([ _react.PropTypes.string, _react.PropTypes.object ])
        }, Redirect.defaultProps = {
            push: !1
        }, exports.default = Redirect;
    }, /* 251 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _matchPath = __webpack_require__(252), _matchPath2 = _interopRequireDefault(_matchPath), computeMatch = function(router, _ref) {
            var computedMatch = _ref.computedMatch, path = _ref.path, exact = _ref.exact, strict = _ref.strict;
            return computedMatch || (0, _matchPath2.default)(router.location.pathname, path, {
                exact: exact,
                strict: strict
            });
        }, Route = function(_React$Component) {
            function Route() {
                return _classCallCheck(this, Route), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
            }
            return _inherits(Route, _React$Component), Route.prototype.getChildContext = function() {
                return {
                    router: this.router
                };
            }, Route.prototype.componentWillMount = function() {
                var _this2 = this, parentRouter = this.context.router;
                this.router = _extends({}, parentRouter, {
                    match: computeMatch(parentRouter, this.props)
                }), // Start listening here so we can <Redirect> on the initial render.
                this.unlisten = parentRouter.listen(function() {
                    _extends(_this2.router, parentRouter, {
                        match: computeMatch(parentRouter, _this2.props)
                    }), _this2.forceUpdate();
                });
            }, Route.prototype.componentWillReceiveProps = function(nextProps) {
                _extends(this.router, {
                    match: computeMatch(this.router, nextProps)
                });
            }, Route.prototype.componentWillUnmount = function() {
                this.unlisten();
            }, Route.prototype.render = function render() {
                var _props = this.props, children = _props.children, component = _props.component, render = _props.render, props = _extends({}, this.router);
                // component prop gets first priority, only called if there's a match
                // render prop is next, only called if there's a match
                // children come last, always called
                // Preact defaults to empty children array
                return component ? props.match ? _react2.default.createElement(component, props) : null : render ? props.match ? render(props) : null : children ? "function" == typeof children ? children(props) : !Array.isArray(children) || children.length ? _react2.default.Children.only(children) : null : null;
            }, Route;
        }(_react2.default.Component);
        Route.contextTypes = {
            router: _react.PropTypes.shape({
                listen: _react.PropTypes.func.isRequired
            }).isRequired
        }, Route.propTypes = {
            computedMatch: _react.PropTypes.object,
            // private, from <Switch>
            path: _react.PropTypes.string,
            exact: _react.PropTypes.bool,
            strict: _react.PropTypes.bool,
            component: _react.PropTypes.func,
            render: _react.PropTypes.func,
            children: _react.PropTypes.oneOfType([ _react.PropTypes.func, _react.PropTypes.node ])
        }, Route.childContextTypes = {
            router: _react.PropTypes.object.isRequired
        }, exports.default = Route;
    }, /* 252 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0;
        var _pathToRegexp = __webpack_require__(253), _pathToRegexp2 = _interopRequireDefault(_pathToRegexp), patternCache = {}, cacheLimit = 1e4, cacheCount = 0, compilePath = function(pattern, options) {
            var cacheKey = "" + options.end + options.strict, cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});
            if (cache[pattern]) return cache[pattern];
            var keys = [], re = (0, _pathToRegexp2.default)(pattern, keys, options), compiledPattern = {
                re: re,
                keys: keys
            };
            return cacheCount < cacheLimit && (cache[pattern] = compiledPattern, cacheCount++), 
            compiledPattern;
        }, matchPath = function(pathname, path) {
            var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, _options$exact = options.exact, exact = void 0 !== _options$exact && _options$exact, _options$strict = options.strict, strict = void 0 !== _options$strict && _options$strict;
            if (!path) return {
                url: pathname,
                isExact: !0,
                params: {}
            };
            var _compilePath = compilePath(path, {
                end: exact,
                strict: strict
            }), re = _compilePath.re, keys = _compilePath.keys, match = re.exec(pathname);
            if (!match) return null;
            var url = match[0], values = match.slice(1), isExact = pathname === url;
            return exact && !isExact ? null : {
                path: path,
                // the path pattern used to match
                url: "/" === path && "" === url ? "/" : url,
                // the matched portion of the URL
                isExact: isExact,
                // whether or not we matched exactly
                params: keys.reduce(function(memo, key, index) {
                    return memo[key.name] = values[index], memo;
                }, {})
            };
        };
        exports.default = matchPath;
    }, /* 253 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {string}  str
	 * @param  {Object=} options
	 * @return {!Array}
	 */
        function parse(str, options) {
            for (var res, tokens = [], key = 0, index = 0, path = "", defaultDelimiter = options && options.delimiter || "/"; null != (res = PATH_REGEXP.exec(str)); ) {
                var m = res[0], escaped = res[1], offset = res.index;
                // Ignore already escaped sequences.
                if (path += str.slice(index, offset), index = offset + m.length, escaped) path += escaped[1]; else {
                    var next = str[index], prefix = res[2], name = res[3], capture = res[4], group = res[5], modifier = res[6], asterisk = res[7];
                    // Push the current path onto the tokens.
                    path && (tokens.push(path), path = "");
                    var partial = null != prefix && null != next && next !== prefix, repeat = "+" === modifier || "*" === modifier, optional = "?" === modifier || "*" === modifier, delimiter = res[2] || defaultDelimiter, pattern = capture || group;
                    tokens.push({
                        name: name || key++,
                        prefix: prefix || "",
                        delimiter: delimiter,
                        optional: optional,
                        repeat: repeat,
                        partial: partial,
                        asterisk: !!asterisk,
                        pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
                    });
                }
            }
            // Match any characters still remaining.
            // If the path exists, push it onto the end.
            return index < str.length && (path += str.substr(index)), path && tokens.push(path), 
            tokens;
        }
        /**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {string}             str
	 * @param  {Object=}            options
	 * @return {!function(Object=, Object=)}
	 */
        function compile(str, options) {
            return tokensToFunction(parse(str, options));
        }
        /**
	 * Prettier encoding of URI path segments.
	 *
	 * @param  {string}
	 * @return {string}
	 */
        function encodeURIComponentPretty(str) {
            return encodeURI(str).replace(/[\/?#]/g, function(c) {
                return "%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        /**
	 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
	 *
	 * @param  {string}
	 * @return {string}
	 */
        function encodeAsterisk(str) {
            return encodeURI(str).replace(/[?#]/g, function(c) {
                return "%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        /**
	 * Expose a method for transforming tokens into the path function.
	 */
        function tokensToFunction(tokens) {
            // Compile all the patterns before compilation.
            for (var matches = new Array(tokens.length), i = 0; i < tokens.length; i++) "object" == typeof tokens[i] && (matches[i] = new RegExp("^(?:" + tokens[i].pattern + ")$"));
            return function(obj, opts) {
                for (var path = "", data = obj || {}, options = opts || {}, encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent, i = 0; i < tokens.length; i++) {
                    var token = tokens[i];
                    if ("string" != typeof token) {
                        var segment, value = data[token.name];
                        if (null == value) {
                            if (token.optional) {
                                // Prepend partial segment prefixes.
                                token.partial && (path += token.prefix);
                                continue;
                            }
                            throw new TypeError('Expected "' + token.name + '" to be defined');
                        }
                        if (isarray(value)) {
                            if (!token.repeat) throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
                            if (0 === value.length) {
                                if (token.optional) continue;
                                throw new TypeError('Expected "' + token.name + '" to not be empty');
                            }
                            for (var j = 0; j < value.length; j++) {
                                if (segment = encode(value[j]), !matches[i].test(segment)) throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
                                path += (0 === j ? token.prefix : token.delimiter) + segment;
                            }
                        } else {
                            if (segment = token.asterisk ? encodeAsterisk(value) : encode(value), !matches[i].test(segment)) throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
                            path += token.prefix + segment;
                        }
                    } else path += token;
                }
                return path;
            };
        }
        /**
	 * Escape a regular expression string.
	 *
	 * @param  {string} str
	 * @return {string}
	 */
        function escapeString(str) {
            return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
        }
        /**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {string} group
	 * @return {string}
	 */
        function escapeGroup(group) {
            return group.replace(/([=!:$\/()])/g, "\\$1");
        }
        /**
	 * Attach the keys as a property of the regexp.
	 *
	 * @param  {!RegExp} re
	 * @param  {Array}   keys
	 * @return {!RegExp}
	 */
        function attachKeys(re, keys) {
            return re.keys = keys, re;
        }
        /**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {string}
	 */
        function flags(options) {
            return options.sensitive ? "" : "i";
        }
        /**
	 * Pull out keys from a regexp.
	 *
	 * @param  {!RegExp} path
	 * @param  {!Array}  keys
	 * @return {!RegExp}
	 */
        function regexpToRegexp(path, keys) {
            // Use a negative lookahead to match only capturing groups.
            var groups = path.source.match(/\((?!\?)/g);
            if (groups) for (var i = 0; i < groups.length; i++) keys.push({
                name: i,
                prefix: null,
                delimiter: null,
                optional: !1,
                repeat: !1,
                partial: !1,
                asterisk: !1,
                pattern: null
            });
            return attachKeys(path, keys);
        }
        /**
	 * Transform an array into a regexp.
	 *
	 * @param  {!Array}  path
	 * @param  {Array}   keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
        function arrayToRegexp(path, keys, options) {
            for (var parts = [], i = 0; i < path.length; i++) parts.push(pathToRegexp(path[i], keys, options).source);
            var regexp = new RegExp("(?:" + parts.join("|") + ")", flags(options));
            return attachKeys(regexp, keys);
        }
        /**
	 * Create a path regexp from string input.
	 *
	 * @param  {string}  path
	 * @param  {!Array}  keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
        function stringToRegexp(path, keys, options) {
            return tokensToRegExp(parse(path, options), keys, options);
        }
        /**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {!Array}          tokens
	 * @param  {(Array|Object)=} keys
	 * @param  {Object=}         options
	 * @return {!RegExp}
	 */
        function tokensToRegExp(tokens, keys, options) {
            isarray(keys) || (options = /** @type {!Object} */ keys || options, keys = []), 
            options = options || {};
            // Iterate over the tokens and create our regexp string.
            for (var strict = options.strict, end = options.end !== !1, route = "", i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if ("string" == typeof token) route += escapeString(token); else {
                    var prefix = escapeString(token.prefix), capture = "(?:" + token.pattern + ")";
                    keys.push(token), token.repeat && (capture += "(?:" + prefix + capture + ")*"), 
                    capture = token.optional ? token.partial ? prefix + "(" + capture + ")?" : "(?:" + prefix + "(" + capture + "))?" : prefix + "(" + capture + ")", 
                    route += capture;
                }
            }
            var delimiter = escapeString(options.delimiter || "/"), endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
            // In non-strict mode we allow a slash at the end of match. If the path to
            // match already ends with a slash, we remove it for consistency. The slash
            // is valid at the end of a path match, not in the middle. This is important
            // in non-ending mode, where "/test/" shouldn't match "/test//route".
            return strict || (route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?"), 
            route += end ? "$" : strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)", 
            attachKeys(new RegExp("^" + route, flags(options)), keys);
        }
        /**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(string|RegExp|Array)} path
	 * @param  {(Array|Object)=}       keys
	 * @param  {Object=}               options
	 * @return {!RegExp}
	 */
        function pathToRegexp(path, keys, options) {
            /** @type {!Object} */
            /** @type {!Array} */
            /** @type {!Array} */
            /** @type {!Array} */
            /** @type {string} */
            /** @type {!Array} */
            return isarray(keys) || (options = keys || options, keys = []), options = options || {}, 
            path instanceof RegExp ? regexpToRegexp(path, keys) : isarray(path) ? arrayToRegexp(path, keys, options) : stringToRegexp(path, keys, options);
        }
        var isarray = __webpack_require__(254);
        /**
	 * Expose `pathToRegexp`.
	 */
        module.exports = pathToRegexp, module.exports.parse = parse, module.exports.compile = compile, 
        module.exports.tokensToFunction = tokensToFunction, module.exports.tokensToRegExp = tokensToRegExp;
        /**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
        var PATH_REGEXP = new RegExp([ // Match escaped characters that would otherwise appear in future matches.
        // This allows the user to escape special characters that won't transform.
        "(\\\\.)", // Match Express-style parameters and un-named parameters with a prefix
        // and optional suffixes. Matches appear as:
        //
        // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
        // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
        // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
        "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))" ].join("|"), "g");
    }, /* 254 */
    /***/
    function(module, exports) {
        module.exports = Array.isArray || function(arr) {
            return "[object Array]" == Object.prototype.toString.call(arr);
        };
    }, /* 255 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _invariant = __webpack_require__(248), _invariant2 = _interopRequireDefault(_invariant), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _PathUtils = __webpack_require__(242), _Router = __webpack_require__(247), _Router2 = _interopRequireDefault(_Router), normalizeLocation = function(object) {
            var _object$pathname = object.pathname, pathname = void 0 === _object$pathname ? "/" : _object$pathname, _object$search = object.search, search = void 0 === _object$search ? "" : _object$search, _object$hash = object.hash, hash = void 0 === _object$hash ? "" : _object$hash;
            return {
                pathname: pathname,
                search: "?" === search ? "" : search,
                hash: "#" === hash ? "" : hash
            };
        }, addBasename = function(basename, location) {
            return basename ? _extends({}, location, {
                pathname: (0, _PathUtils.addLeadingSlash)(basename) + location.pathname
            }) : location;
        }, stripBasename = function(basename, location) {
            if (!basename) return location;
            var base = (0, _PathUtils.addLeadingSlash)(basename);
            location.pathname;
            return 0 !== location.pathname.indexOf(base) ? location : _extends({}, location, {
                pathname: location.pathname.substr(base.length)
            });
        }, createLocation = function(location) {
            return "string" == typeof location ? (0, _PathUtils.parsePath)(location) : normalizeLocation(location);
        }, createURL = function(location) {
            return "string" == typeof location ? location : (0, _PathUtils.createPath)(location);
        }, staticHandler = function(methodName) {
            return function() {
                (0, _invariant2.default)(!1, "You cannot %s with <StaticRouter>", methodName);
            };
        }, noop = function() {}, StaticRouter = function(_React$Component) {
            function StaticRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, StaticRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.createHref = function(path) {
                    return (0, _PathUtils.addLeadingSlash)(_this.props.basename + createURL(path));
                }, _this.handlePush = function(location) {
                    var _this$props = _this.props, basename = _this$props.basename, context = _this$props.context;
                    context.action = "PUSH", context.location = addBasename(basename, createLocation(location)), 
                    context.url = createURL(context.location);
                }, _this.handleReplace = function(location) {
                    var _this$props2 = _this.props, basename = _this$props2.basename, context = _this$props2.context;
                    context.action = "REPLACE", context.location = addBasename(basename, createLocation(location)), 
                    context.url = createURL(context.location);
                }, _this.handleListen = function() {
                    return noop;
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(StaticRouter, _React$Component), StaticRouter.prototype.render = function() {
                var _props = this.props, basename = _props.basename, context = _props.context, location = _props.location, props = _objectWithoutProperties(_props, [ "basename", "context", "location" ]), history = {
                    staticContext: context,
                    createHref: this.createHref,
                    action: "POP",
                    location: stripBasename(basename, createLocation(location)),
                    push: this.handlePush,
                    replace: this.handleReplace,
                    go: staticHandler("go"),
                    goBack: staticHandler("goBack"),
                    goForward: staticHandler("goForward"),
                    listen: this.handleListen
                };
                return _react2.default.createElement(_Router2.default, _extends({}, props, {
                    history: history
                }));
            }, StaticRouter;
        }(_react2.default.Component);
        StaticRouter.propTypes = {
            basename: _react.PropTypes.string,
            context: _react.PropTypes.object.isRequired,
            location: _react.PropTypes.oneOfType([ _react.PropTypes.string, _react.PropTypes.object ])
        }, StaticRouter.defaultProps = {
            basename: "",
            location: "/"
        }, exports.default = StaticRouter;
    }, /* 256 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _matchPath = __webpack_require__(252), _matchPath2 = _interopRequireDefault(_matchPath), Switch = function(_React$Component) {
            function Switch() {
                var _temp, _this, _ret;
                _classCallCheck(this, Switch);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.state = {
                    location: null
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(Switch, _React$Component), Switch.prototype.componentWillMount = function() {
                var _this2 = this, router = this.context.router;
                this.setState({
                    location: router.location
                }), // Start listening here so we can <Redirect> on the initial render.
                this.unlisten = router.listen(function() {
                    _this2.setState({
                        location: router.location
                    });
                });
            }, Switch.prototype.componentWillUnmount = function() {
                this.unlisten();
            }, Switch.prototype.render = function() {
                for (var children = this.props.children, location = this.state.location, routes = _react2.default.Children.toArray(children), route = void 0, match = void 0, i = 0, length = routes.length; null == match && i < length; ++i) route = routes[i], 
                match = (0, _matchPath2.default)(location.pathname, route.props.path, route.props);
                return match ? _react2.default.cloneElement(route, {
                    computedMatch: match
                }) : null;
            }, Switch;
        }(_react2.default.Component);
        Switch.contextTypes = {
            router: _react.PropTypes.shape({
                listen: _react.PropTypes.func.isRequired
            }).isRequired
        }, Switch.propTypes = {
            children: _react.PropTypes.node
        }, exports.default = Switch;
    }, /* 257 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), withRouter = function(component) {
            var _class, _temp;
            return _temp = _class = function(_React$Component) {
                function _class() {
                    return _classCallCheck(this, _class), _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
                }
                return _inherits(_class, _React$Component), _class.prototype.componentWillMount = function() {
                    var _this2 = this;
                    // Start listening here so we can <Redirect> on the initial render.
                    this.unlisten = this.context.router.listen(function() {
                        return _this2.forceUpdate();
                    });
                }, _class.prototype.componentWillUnmount = function() {
                    this.unlisten();
                }, _class.prototype.render = function() {
                    return _react2.default.createElement(component, _extends({}, this.props, this.context.router));
                }, _class;
            }(_react2.default.Component), _class.displayName = "withRouter(" + (component.displayName || component.name) + ")", 
            _class.contextTypes = {
                router: _react.PropTypes.shape({
                    listen: _react.PropTypes.func.isRequired
                }).isRequired
            }, _temp;
        };
        exports.default = withRouter;
    }, /* 258 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        exports.__esModule = !0, exports.withRouter = exports.matchPath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.NavLink = exports.MemoryRouter = exports.Link = exports.HashRouter = exports.BrowserRouter = void 0;
        var _BrowserRouter2 = __webpack_require__(259), _BrowserRouter3 = _interopRequireDefault(_BrowserRouter2), _HashRouter2 = __webpack_require__(263), _HashRouter3 = _interopRequireDefault(_HashRouter2), _Link2 = __webpack_require__(265), _Link3 = _interopRequireDefault(_Link2), _MemoryRouter2 = __webpack_require__(266), _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2), _NavLink2 = __webpack_require__(267), _NavLink3 = _interopRequireDefault(_NavLink2), _Prompt2 = __webpack_require__(268), _Prompt3 = _interopRequireDefault(_Prompt2), _Redirect2 = __webpack_require__(269), _Redirect3 = _interopRequireDefault(_Redirect2), _Route2 = __webpack_require__(270), _Route3 = _interopRequireDefault(_Route2), _Router2 = __webpack_require__(271), _Router3 = _interopRequireDefault(_Router2), _StaticRouter2 = __webpack_require__(272), _StaticRouter3 = _interopRequireDefault(_StaticRouter2), _Switch2 = __webpack_require__(273), _Switch3 = _interopRequireDefault(_Switch2), _matchPath2 = __webpack_require__(274), _matchPath3 = _interopRequireDefault(_matchPath2), _withRouter2 = __webpack_require__(275), _withRouter3 = _interopRequireDefault(_withRouter2);
        exports.BrowserRouter = _BrowserRouter3.default, exports.HashRouter = _HashRouter3.default, 
        exports.Link = _Link3.default, exports.MemoryRouter = _MemoryRouter3.default, exports.NavLink = _NavLink3.default, 
        exports.Prompt = _Prompt3.default, exports.Redirect = _Redirect3.default, exports.Route = _Route3.default, 
        exports.Router = _Router3.default, exports.StaticRouter = _StaticRouter3.default, 
        exports.Switch = _Switch3.default, exports.matchPath = _matchPath3.default, exports.withRouter = _withRouter3.default;
    }, /* 259 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _createBrowserHistory = __webpack_require__(260), _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory), _reactRouter = __webpack_require__(238), BrowserRouter = function(_React$Component) {
            function BrowserRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, BrowserRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.history = (0, _createBrowserHistory2.default)(_this.props), _ret = _temp, 
                _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(BrowserRouter, _React$Component), BrowserRouter.prototype.render = function() {
                return _react2.default.createElement(_reactRouter.Router, {
                    history: this.history,
                    children: this.props.children
                });
            }, BrowserRouter;
        }(_react2.default.Component);
        BrowserRouter.propTypes = {
            basename: _react.PropTypes.string,
            forceRefresh: _react.PropTypes.bool,
            getUserConfirmation: _react.PropTypes.func,
            keyLength: _react.PropTypes.number,
            children: _react.PropTypes.node
        }, exports.default = BrowserRouter;
    }, /* 260 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }
            exports.__esModule = !0;
            var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                return typeof obj;
            } : function(obj) {
                return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            }, _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _warning = __webpack_require__(241), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(248), _invariant2 = _interopRequireDefault(_invariant), _LocationUtils = __webpack_require__(243), _PathUtils = __webpack_require__(242), _createTransitionManager = __webpack_require__(246), _createTransitionManager2 = _interopRequireDefault(_createTransitionManager), _ExecutionEnvironment = __webpack_require__(261), _DOMUtils = __webpack_require__(262), PopStateEvent = "popstate", HashChangeEvent = "hashchange", getHistoryState = function() {
                try {
                    return window.history.state || {};
                } catch (e) {
                    // IE 11 sometimes throws when accessing window.history.state
                    // See https://github.com/mjackson/history/pull/289
                    return {};
                }
            }, createBrowserHistory = function() {
                var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                _ExecutionEnvironment.canUseDOM ? void 0 : "production" !== process.env.NODE_ENV ? (0, 
                _invariant2.default)(!1, "Browser history needs a DOM") : (0, _invariant2.default)(!1);
                var globalHistory = window.history, canUseHistory = (0, _DOMUtils.supportsHistory)(), needsHashChangeListener = !(0, 
                _DOMUtils.supportsPopStateOnHashChange)(), _props$basename = props.basename, basename = void 0 === _props$basename ? "" : _props$basename, _props$forceRefresh = props.forceRefresh, forceRefresh = void 0 !== _props$forceRefresh && _props$forceRefresh, _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = void 0 === _props$getUserConfirm ? _DOMUtils.getConfirmation : _props$getUserConfirm, _props$keyLength = props.keyLength, keyLength = void 0 === _props$keyLength ? 6 : _props$keyLength, getDOMLocation = function(historyState) {
                    var _ref = historyState || {}, key = _ref.key, state = _ref.state, _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash, path = pathname + search + hash;
                    return basename && (path = (0, _PathUtils.stripPrefix)(path, basename)), _extends({}, (0, 
                    _PathUtils.parsePath)(path), {
                        state: state,
                        key: key
                    });
                }, createKey = function() {
                    return Math.random().toString(36).substr(2, keyLength);
                }, transitionManager = (0, _createTransitionManager2.default)(), setState = function(nextState) {
                    _extends(history, nextState), history.length = globalHistory.length, transitionManager.notifyListeners(history.location, history.action);
                }, handlePopState = function(event) {
                    // Ignore extraneous popstate events in WebKit.
                    (0, _DOMUtils.isExtraneousPopstateEvent)(event) || handlePop(getDOMLocation(event.state));
                }, handleHashChange = function() {
                    handlePop(getDOMLocation(getHistoryState()));
                }, forceNextPop = !1, handlePop = function(location) {
                    forceNextPop ? (forceNextPop = !1, setState()) : !function() {
                        var action = "POP";
                        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                            ok ? setState({
                                action: action,
                                location: location
                            }) : revertPop(location);
                        });
                    }();
                }, revertPop = function(fromLocation) {
                    var toLocation = history.location, toIndex = allKeys.indexOf(toLocation.key);
                    toIndex === -1 && (toIndex = 0);
                    var fromIndex = allKeys.indexOf(fromLocation.key);
                    fromIndex === -1 && (fromIndex = 0);
                    var delta = toIndex - fromIndex;
                    delta && (forceNextPop = !0, go(delta));
                }, initialLocation = getDOMLocation(getHistoryState()), allKeys = [ initialLocation.key ], createHref = function(location) {
                    return basename + (0, _PathUtils.createPath)(location);
                }, push = function(path, state) {
                    "production" !== process.env.NODE_ENV ? (0, _warning2.default)(!("object" === ("undefined" == typeof path ? "undefined" : _typeof(path)) && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
                    var action = "PUSH", location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        if (ok) {
                            var href = createHref(location), key = location.key, state = location.state;
                            if (canUseHistory) if (globalHistory.pushState({
                                key: key,
                                state: state
                            }, null, href), forceRefresh) window.location.href = href; else {
                                var prevIndex = allKeys.indexOf(history.location.key), nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                                nextKeys.push(location.key), allKeys = nextKeys, setState({
                                    action: action,
                                    location: location
                                });
                            } else "production" !== process.env.NODE_ENV ? (0, _warning2.default)(void 0 === state, "Browser history cannot push state in browsers that do not support HTML5 history") : void 0, 
                            window.location.href = href;
                        }
                    });
                }, replace = function(path, state) {
                    "production" !== process.env.NODE_ENV ? (0, _warning2.default)(!("object" === ("undefined" == typeof path ? "undefined" : _typeof(path)) && void 0 !== path.state && void 0 !== state), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored") : void 0;
                    var action = "REPLACE", location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        if (ok) {
                            var href = createHref(location), key = location.key, state = location.state;
                            if (canUseHistory) if (globalHistory.replaceState({
                                key: key,
                                state: state
                            }, null, href), forceRefresh) window.location.replace(href); else {
                                var prevIndex = allKeys.indexOf(history.location.key);
                                prevIndex !== -1 && (allKeys[prevIndex] = location.key), setState({
                                    action: action,
                                    location: location
                                });
                            } else "production" !== process.env.NODE_ENV ? (0, _warning2.default)(void 0 === state, "Browser history cannot replace state in browsers that do not support HTML5 history") : void 0, 
                            window.location.replace(href);
                        }
                    });
                }, go = function(n) {
                    globalHistory.go(n);
                }, goBack = function() {
                    return go(-1);
                }, goForward = function() {
                    return go(1);
                }, listenerCount = 0, checkDOMListeners = function(delta) {
                    listenerCount += delta, 1 === listenerCount ? ((0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState), 
                    needsHashChangeListener && (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange)) : 0 === listenerCount && ((0, 
                    _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState), needsHashChangeListener && (0, 
                    _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange));
                }, isBlocked = !1, block = function() {
                    var prompt = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], unblock = transitionManager.setPrompt(prompt);
                    return isBlocked || (checkDOMListeners(1), isBlocked = !0), function() {
                        return isBlocked && (isBlocked = !1, checkDOMListeners(-1)), unblock();
                    };
                }, listen = function(listener) {
                    var unlisten = transitionManager.appendListener(listener);
                    return checkDOMListeners(1), function() {
                        return checkDOMListeners(-1), unlisten();
                    };
                }, history = {
                    length: globalHistory.length,
                    action: "POP",
                    location: initialLocation,
                    createHref: createHref,
                    push: push,
                    replace: replace,
                    go: go,
                    goBack: goBack,
                    goForward: goForward,
                    block: block,
                    listen: listen
                };
                return history;
            };
            exports.default = createBrowserHistory;
        }).call(exports, __webpack_require__(153));
    }, /* 261 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0;
        exports.canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement);
    }, /* 262 */
    /***/
    function(module, exports) {
        "use strict";
        exports.__esModule = !0;
        exports.addEventListener = function(node, event, listener) {
            return node.addEventListener ? node.addEventListener(event, listener, !1) : node.attachEvent("on" + event, listener);
        }, exports.removeEventListener = function(node, event, listener) {
            return node.removeEventListener ? node.removeEventListener(event, listener, !1) : node.detachEvent("on" + event, listener);
        }, exports.getConfirmation = function(message, callback) {
            return callback(window.confirm(message));
        }, exports.supportsHistory = function() {
            var ua = window.navigator.userAgent;
            return (ua.indexOf("Android 2.") === -1 && ua.indexOf("Android 4.0") === -1 || ua.indexOf("Mobile Safari") === -1 || ua.indexOf("Chrome") !== -1 || ua.indexOf("Windows Phone") !== -1) && (window.history && "pushState" in window.history);
        }, exports.supportsPopStateOnHashChange = function() {
            return window.navigator.userAgent.indexOf("Trident") === -1;
        }, exports.supportsGoWithoutReloadUsingHash = function() {
            return window.navigator.userAgent.indexOf("Firefox") === -1;
        }, exports.isExtraneousPopstateEvent = function(event) {
            return void 0 === event.state && navigator.userAgent.indexOf("CriOS") === -1;
        };
    }, /* 263 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _createHashHistory = __webpack_require__(264), _createHashHistory2 = _interopRequireDefault(_createHashHistory), _reactRouter = __webpack_require__(238), HashRouter = function(_React$Component) {
            function HashRouter() {
                var _temp, _this, _ret;
                _classCallCheck(this, HashRouter);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.history = (0, _createHashHistory2.default)(_this.props), _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(HashRouter, _React$Component), HashRouter.prototype.render = function() {
                return _react2.default.createElement(_reactRouter.Router, {
                    history: this.history,
                    children: this.props.children
                });
            }, HashRouter;
        }(_react2.default.Component);
        HashRouter.propTypes = {
            basename: _react.PropTypes.string,
            getUserConfirmation: _react.PropTypes.func,
            hashType: _react.PropTypes.oneOf([ "hashbang", "noslash", "slash" ]),
            children: _react.PropTypes.node
        }, exports.default = HashRouter;
    }, /* 264 */
    /***/
    function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */
        (function(process) {
            "use strict";
            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }
            exports.__esModule = !0;
            var _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            }, _warning = __webpack_require__(241), _warning2 = _interopRequireDefault(_warning), _invariant = __webpack_require__(248), _invariant2 = _interopRequireDefault(_invariant), _LocationUtils = __webpack_require__(243), _PathUtils = __webpack_require__(242), _createTransitionManager = __webpack_require__(246), _createTransitionManager2 = _interopRequireDefault(_createTransitionManager), _ExecutionEnvironment = __webpack_require__(261), _DOMUtils = __webpack_require__(262), HashChangeEvent = "hashchange", HashPathCoders = {
                hashbang: {
                    encodePath: function(path) {
                        return "!" === path.charAt(0) ? path : "!/" + (0, _PathUtils.stripLeadingSlash)(path);
                    },
                    decodePath: function(path) {
                        return "!" === path.charAt(0) ? path.substr(1) : path;
                    }
                },
                noslash: {
                    encodePath: _PathUtils.stripLeadingSlash,
                    decodePath: _PathUtils.addLeadingSlash
                },
                slash: {
                    encodePath: _PathUtils.addLeadingSlash,
                    decodePath: _PathUtils.addLeadingSlash
                }
            }, getHashPath = function() {
                // We can't use window.location.hash here because it's not
                // consistent across browsers - Firefox will pre-decode it!
                var href = window.location.href, hashIndex = href.indexOf("#");
                return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
            }, pushHashPath = function(path) {
                return window.location.hash = path;
            }, replaceHashPath = function(path) {
                var hashIndex = window.location.href.indexOf("#");
                window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + "#" + path);
            }, createHashHistory = function() {
                var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                _ExecutionEnvironment.canUseDOM ? void 0 : "production" !== process.env.NODE_ENV ? (0, 
                _invariant2.default)(!1, "Hash history needs a DOM") : (0, _invariant2.default)(!1);
                var globalHistory = window.history, canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)(), _props$basename = props.basename, basename = void 0 === _props$basename ? "" : _props$basename, _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = void 0 === _props$getUserConfirm ? _DOMUtils.getConfirmation : _props$getUserConfirm, _props$hashType = props.hashType, hashType = void 0 === _props$hashType ? "slash" : _props$hashType, _HashPathCoders$hashT = HashPathCoders[hashType], encodePath = _HashPathCoders$hashT.encodePath, decodePath = _HashPathCoders$hashT.decodePath, getDOMLocation = function() {
                    var path = decodePath(getHashPath());
                    return basename && (path = (0, _PathUtils.stripPrefix)(path, basename)), (0, _PathUtils.parsePath)(path);
                }, transitionManager = (0, _createTransitionManager2.default)(), setState = function(nextState) {
                    _extends(history, nextState), history.length = globalHistory.length, transitionManager.notifyListeners(history.location, history.action);
                }, forceNextPop = !1, ignorePath = null, handleHashChange = function() {
                    var path = getHashPath(), encodedPath = encodePath(path);
                    if (path !== encodedPath) // Ensure we always have a properly-encoded hash.
                    replaceHashPath(encodedPath); else {
                        var location = getDOMLocation(), prevLocation = history.location;
                        if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return;
                        // A hashchange doesn't always == location change.
                        if (ignorePath === (0, _PathUtils.createPath)(location)) return;
                        // Ignore this change; we already setState in push/replace.
                        ignorePath = null, handlePop(location);
                    }
                }, handlePop = function(location) {
                    forceNextPop ? (forceNextPop = !1, setState()) : !function() {
                        var action = "POP";
                        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                            ok ? setState({
                                action: action,
                                location: location
                            }) : revertPop(location);
                        });
                    }();
                }, revertPop = function(fromLocation) {
                    var toLocation = history.location, toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));
                    toIndex === -1 && (toIndex = 0);
                    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));
                    fromIndex === -1 && (fromIndex = 0);
                    var delta = toIndex - fromIndex;
                    delta && (forceNextPop = !0, go(delta));
                }, path = getHashPath(), encodedPath = encodePath(path);
                path !== encodedPath && replaceHashPath(encodedPath);
                var initialLocation = getDOMLocation(), allPaths = [ (0, _PathUtils.createPath)(initialLocation) ], createHref = function(location) {
                    return "#" + encodePath(basename + (0, _PathUtils.createPath)(location));
                }, push = function(path, state) {
                    "production" !== process.env.NODE_ENV ? (0, _warning2.default)(void 0 === state, "Hash history cannot push state; it is ignored") : void 0;
                    var action = "PUSH", location = (0, _LocationUtils.createLocation)(path, void 0, void 0, history.location);
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        if (ok) {
                            var path = (0, _PathUtils.createPath)(location), encodedPath = encodePath(basename + path), hashChanged = getHashPath() !== encodedPath;
                            if (hashChanged) {
                                // We cannot tell if a hashchange was caused by a PUSH, so we'd
                                // rather setState here and ignore the hashchange. The caveat here
                                // is that other hash histories in the page will consider it a POP.
                                ignorePath = path, pushHashPath(encodedPath);
                                var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location)), nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);
                                nextPaths.push(path), allPaths = nextPaths, setState({
                                    action: action,
                                    location: location
                                });
                            } else "production" !== process.env.NODE_ENV ? (0, _warning2.default)(!1, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack") : void 0, 
                            setState();
                        }
                    });
                }, replace = function(path, state) {
                    "production" !== process.env.NODE_ENV ? (0, _warning2.default)(void 0 === state, "Hash history cannot replace state; it is ignored") : void 0;
                    var action = "REPLACE", location = (0, _LocationUtils.createLocation)(path, void 0, void 0, history.location);
                    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
                        if (ok) {
                            var path = (0, _PathUtils.createPath)(location), encodedPath = encodePath(basename + path), hashChanged = getHashPath() !== encodedPath;
                            hashChanged && (// We cannot tell if a hashchange was caused by a REPLACE, so we'd
                            // rather setState here and ignore the hashchange. The caveat here
                            // is that other hash histories in the page will consider it a POP.
                            ignorePath = path, replaceHashPath(encodedPath));
                            var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));
                            prevIndex !== -1 && (allPaths[prevIndex] = path), setState({
                                action: action,
                                location: location
                            });
                        }
                    });
                }, go = function(n) {
                    "production" !== process.env.NODE_ENV ? (0, _warning2.default)(canGoWithoutReload, "Hash history go(n) causes a full page reload in this browser") : void 0, 
                    globalHistory.go(n);
                }, goBack = function() {
                    return go(-1);
                }, goForward = function() {
                    return go(1);
                }, listenerCount = 0, checkDOMListeners = function(delta) {
                    listenerCount += delta, 1 === listenerCount ? (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange) : 0 === listenerCount && (0, 
                    _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
                }, isBlocked = !1, block = function() {
                    var prompt = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], unblock = transitionManager.setPrompt(prompt);
                    return isBlocked || (checkDOMListeners(1), isBlocked = !0), function() {
                        return isBlocked && (isBlocked = !1, checkDOMListeners(-1)), unblock();
                    };
                }, listen = function(listener) {
                    var unlisten = transitionManager.appendListener(listener);
                    return checkDOMListeners(1), function() {
                        return checkDOMListeners(-1), unlisten();
                    };
                }, history = {
                    length: globalHistory.length,
                    action: "POP",
                    location: initialLocation,
                    createHref: createHref,
                    push: push,
                    replace: replace,
                    go: go,
                    goBack: goBack,
                    goForward: goForward,
                    block: block,
                    listen: listen
                };
                return history;
            };
            exports.default = createHashHistory;
        }).call(exports, __webpack_require__(153));
    }, /* 265 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), isModifiedEvent = function(event) {
            return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
        }, Link = function(_React$Component) {
            function Link() {
                var _temp, _this, _ret;
                _classCallCheck(this, Link);
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                return _temp = _this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [ this ].concat(args))), 
                _this.handleClick = function(event) {
                    if (_this.props.onClick && _this.props.onClick(event), !event.defaultPrevented && // onClick prevented default
                    0 === event.button && // ignore right clicks
                    !_this.props.target && // let browser handle "target=_blank" etc.
                    !isModifiedEvent(event)) {
                        event.preventDefault();
                        var router = _this.context.router, _this$props = _this.props, replace = _this$props.replace, to = _this$props.to;
                        replace ? router.replace(to) : router.push(to);
                    }
                }, _ret = _temp, _possibleConstructorReturn(_this, _ret);
            }
            return _inherits(Link, _React$Component), Link.prototype.render = function() {
                var _props = this.props, to = (_props.replace, _props.to), props = _objectWithoutProperties(_props, [ "replace", "to" ]), href = this.context.router.createHref("string" == typeof to ? {
                    pathname: to
                } : to);
                return _react2.default.createElement("a", _extends({}, props, {
                    onClick: this.handleClick,
                    href: href
                }));
            }, Link;
        }(_react2.default.Component);
        Link.contextTypes = {
            router: _react.PropTypes.shape({
                push: _react.PropTypes.func.isRequired,
                replace: _react.PropTypes.func.isRequired,
                createHref: _react.PropTypes.func.isRequired
            }).isRequired
        }, Link.propTypes = {
            onClick: _react.PropTypes.func,
            target: _react.PropTypes.string,
            replace: _react.PropTypes.bool,
            to: _react.PropTypes.oneOfType([ _react.PropTypes.string, _react.PropTypes.object ]).isRequired
        }, Link.defaultProps = {
            replace: !1
        }, exports.default = Link;
    }, /* 266 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _reactRouter = __webpack_require__(238);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _reactRouter.MemoryRouter;
            }
        });
    }, /* 267 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _objectWithoutProperties(obj, keys) {
            var target = {};
            for (var i in obj) keys.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(obj, i) && (target[i] = obj[i]);
            return target;
        }
        exports.__esModule = !0;
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _reactRouter = __webpack_require__(238), _Link = __webpack_require__(265), _Link2 = _interopRequireDefault(_Link), NavLink = function(_ref) {
            var to = _ref.to, exact = _ref.exact, strict = _ref.strict, activeClassName = _ref.activeClassName, className = _ref.className, activeStyle = _ref.activeStyle, style = _ref.style, getIsActive = _ref.isActive, rest = _objectWithoutProperties(_ref, [ "to", "exact", "strict", "activeClassName", "className", "activeStyle", "style", "isActive" ]);
            return _react2.default.createElement(_reactRouter.Route, {
                path: "object" === ("undefined" == typeof to ? "undefined" : _typeof(to)) ? to.pathname : to,
                exact: exact,
                strict: strict,
                children: function(_ref2) {
                    var location = _ref2.location, match = _ref2.match, isActive = !!(getIsActive ? getIsActive(match, location) : match);
                    return _react2.default.createElement(_Link2.default, _extends({
                        to: to,
                        className: isActive ? [ activeClassName, className ].join(" ") : className,
                        style: isActive ? _extends({}, style, activeStyle) : style
                    }, rest));
                }
            });
        };
        NavLink.propTypes = {
            to: _Link2.default.propTypes.to,
            exact: _react.PropTypes.bool,
            strict: _react.PropTypes.bool,
            activeClassName: _react.PropTypes.string,
            className: _react.PropTypes.string,
            activeStyle: _react.PropTypes.object,
            style: _react.PropTypes.object,
            isActive: _react.PropTypes.func
        }, exports.default = NavLink;
    }, /* 268 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _reactRouter = __webpack_require__(238);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _reactRouter.Prompt;
            }
        });
    }, /* 269 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _reactRouter = __webpack_require__(238);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _reactRouter.Redirect;
            }
        });
    }, /* 270 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _reactRouter = __webpack_require__(238);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _reactRouter.Route;
            }
        });
    }, /* 271 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _reactRouter = __webpack_require__(238);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _reactRouter.Router;
            }
        });
    }, /* 272 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _reactRouter = __webpack_require__(238);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _reactRouter.StaticRouter;
            }
        });
    }, /* 273 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _reactRouter = __webpack_require__(238);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _reactRouter.Switch;
            }
        });
    }, /* 274 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _reactRouter = __webpack_require__(238);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _reactRouter.matchPath;
            }
        });
    }, /* 275 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        exports.__esModule = !0;
        var _reactRouter = __webpack_require__(238);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _reactRouter.withRouter;
            }
        });
    }, /* 276 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(101), _inherits3 = _interopRequireDefault(_inherits2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "", "" ], [ "", "" ]), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _styledComponents = __webpack_require__(114), DefaultTheme = function(_Component) {
            function DefaultTheme() {
                return (0, _classCallCheck3.default)(this, DefaultTheme), (0, _possibleConstructorReturn3.default)(this, (DefaultTheme.__proto__ || (0, 
                _getPrototypeOf2.default)(DefaultTheme)).apply(this, arguments));
            }
            return (0, _inherits3.default)(DefaultTheme, _Component), (0, _createClass3.default)(DefaultTheme, [ {
                key: "componentWillMount",
                value: function() {
                    (0, _styledComponents.injectGlobal)(_templateObject, globalStyles);
                }
            }, {
                key: "render",
                value: function() {
                    return _react2.default.createElement("link", {
                        href: "https://fonts.googleapis.com/css?family=Droid+Sans|Yanone+Kaffeesatz",
                        rel: "stylesheet",
                        type: "text/css"
                    });
                }
            } ]), DefaultTheme;
        }(_react.Component);
        exports.default = DefaultTheme;
        var globalStyles = "\n  html, body {\n    height: 100%;\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n  }\n  * {\n    box-sizing: inherit;\n  }\n\n  body {\n    font-family: 'Droid Sans', sans-serif;\n    font-size: 20px;\n  }\n  h1, h2, h3, h4 {\n    font-family: 'Yanone Kaffeesatz', sans-serif;\n    font-weight: 400;\n    margin: 0 0 1rem;\n  }\n  h1 {\n    font-size: 2.5rem;\n  }\n  h2 {\n    font-size: 1.75rem;\n  }\n  h3 {\n    font-size: 1.5rem;\n  }\n  h4 {\n    font-size: 1rem;\n  }\n\n  li {\n    margin: 0 0 0.5rem;\n  }\n\n  html, body, #root {\n    height: 100%;\n  }\n\n  a {\n    color: #F92672;\n    text-decoration: none;\n  }\n\n  p {\n    margin: 0 0 1rem;\n  }\n\n  code {\n    background: #e7e8e2;\n    border-radius: 5px;\n    font-family: monospace;\n  }\n\n  button {\n    font-family: 'Yanone Kaffeesatz';\n    padding: 0.5rem 1rem;\n    border-radius: 0.5rem;\n    border: none;\n    background-color: #F92672;\n    color: #fff;\n    font-weight: 400;\n    font-size: 20px;\n    cursor: pointer;\n  }\n\n  button:disabled {\n    opacity: 0.5;\n    cursor: default;\n  }\n";
    }, /* 277 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(101), _inherits3 = _interopRequireDefault(_inherits2), _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 0.5rem;\n  }\n" ], [ "\n  position: absolute;\n  top: 1rem;\n  right: 1rem;\n\n  @media (max-width: 600px) {\n    top: 0.5rem;\n    right: 0.5rem;\n  }\n" ]), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _styledComponents = __webpack_require__(114), _styledComponents2 = _interopRequireDefault(_styledComponents), _IconButton = __webpack_require__(229), _IconButton2 = _interopRequireDefault(_IconButton), _Icons = __webpack_require__(230), _PropTypes = __webpack_require__(232), ButtonGroup = _styledComponents2.default.div(_templateObject), TouchNav = function(_Component) {
            function TouchNav() {
                return (0, _classCallCheck3.default)(this, TouchNav), (0, _possibleConstructorReturn3.default)(this, (TouchNav.__proto__ || (0, 
                _getPrototypeOf2.default)(TouchNav)).apply(this, arguments));
            }
            return (0, _inherits3.default)(TouchNav, _Component), (0, _createClass3.default)(TouchNav, [ {
                key: "render",
                value: function() {
                    var presentation = this.context.presentation;
                    return _react2.default.createElement(ButtonGroup, null, _react2.default.createElement(_IconButton2.default, {
                        disabled: presentation.isAtBeginning(),
                        onClick: presentation.goBack
                    }, _react2.default.createElement(_Icons.IconLeft, null)), _react2.default.createElement(_IconButton2.default, {
                        disabled: presentation.isAtEnd(),
                        onClick: presentation.goForward
                    }, _react2.default.createElement(_Icons.IconRight, null)));
                }
            } ]), TouchNav;
        }(_react.Component);
        TouchNav.contextTypes = {
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = TouchNav;
    }, /* 278 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _assign = __webpack_require__(69), _assign2 = _interopRequireDefault(_assign), _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(101), _inherits3 = _interopRequireDefault(_inherits2), _cuid = __webpack_require__(279), _cuid2 = _interopRequireDefault(_cuid), _qs = __webpack_require__(280), _qs2 = _interopRequireDefault(_qs), _react = __webpack_require__(109), _PropTypes = __webpack_require__(232), parentWindowID = (0, 
        _cuid2.default)(), PresenterModePlugin = function(_Component) {
            function PresenterModePlugin(props, context) {
                (0, _classCallCheck3.default)(this, PresenterModePlugin);
                var _this = (0, _possibleConstructorReturn3.default)(this, (PresenterModePlugin.__proto__ || (0, 
                _getPrototypeOf2.default)(PresenterModePlugin)).call(this, props, context));
                return _this._parentWindowID = null, _this._presenterWindow = null, _this._onKeyDown = _this._onKeyDown.bind(_this), 
                _this._signalParent = _this._signalParent.bind(_this), _this._togglePresenterMode = _this._togglePresenterMode.bind(_this), 
                _this;
            }
            return (0, _inherits3.default)(PresenterModePlugin, _Component), (0, _createClass3.default)(PresenterModePlugin, [ {
                key: "componentDidMount",
                value: function() {
                    document.body.addEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillMount",
                value: function() {
                    var presentation = this.context.presentation;
                    this._parentWindowID = _qs2.default.parse(window.location.search.slice(1)).parentWindowID, 
                    presentation.setPluginProps({
                        isPresenterMode: !!this._parentWindowID
                    });
                    var callback = function(_ref) {
                        var slideIndex = _ref.slideIndex, stepIndex = _ref.stepIndex;
                        presentation.goToSlide({
                            slideIndex: slideIndex,
                            stepIndex: stepIndex
                        });
                    };
                    this._parentWindowID || window[parentWindowID] ? this._parentWindowID && !window[this._parentWindowID] && (window[this._parentWindowID] = callback) : window[parentWindowID] = callback;
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    document.body.removeEventListener("keydown", this._onKeyDown);
                }
            }, {
                key: "componentWillUpdate",
                value: function(nextProps, nextState, nextContext) {
                    var presentation = this.context.presentation, slideIndex = presentation.getSlideIndex(), stepIndex = presentation.getStepIndex();
                    slideIndex === this._slideIndex && stepIndex === this._stepIndex || (this._slideIndex = slideIndex, 
                    this._stepIndex = stepIndex, this._parentWindowID ? this._signalParent({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }) : this._presenterWindow && this._syncPath({
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }));
                }
            }, {
                key: "render",
                value: function() {
                    return null;
                }
            }, {
                key: "_onKeyDown",
                value: function(event) {
                    if ("INPUT" !== event.target.tagName) switch (event.key) {
                      case "p":
                      case "P":
                        this._parentWindowID || this._togglePresenterMode();
                    }
                }
            }, {
                key: "_signalParent",
                value: function(path) {
                    window.opener && ("function" != typeof window.opener[this._parentWindowID] ? window.close() : window.opener && window.opener[this._parentWindowID](path));
                }
            }, {
                key: "_togglePresenterMode",
                value: function(path) {
                    if (this._presenterWindow) this._presenterWindow.close(), this._presenterWindow = null; else {
                        var url = new window.URL(window.location.href);
                        url.search = "?" + _qs2.default.stringify((0, _assign2.default)(_qs2.default.parse(window.location.search.slice(1)), {
                            parentWindowID: parentWindowID
                        })), this._presenterWindow = window.open(url.toString(), "react-presents-notes");
                    }
                }
            }, {
                key: "_syncPath",
                value: function(path) {
                    this._presenterWindow && !this._presenterWindow.closed && this._presenterWindow[parentWindowID](path);
                }
            } ]), PresenterModePlugin;
        }(_react.Component);
        PresenterModePlugin.contextTypes = {
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = PresenterModePlugin;
    }, /* 279 */
    /***/
    function(module, exports, __webpack_require__) {
        /**
	 * cuid.js
	 * Collision-resistant UID generator for browsers and node.
	 * Sequential for fast db lookups and recency sorting.
	 * Safe for element IDs and server-side lookups.
	 *
	 * Extracted from CLCTR
	 *
	 * Copyright (c) Eric Elliott 2012
	 * MIT License
	 */
        /*global window, navigator, document, require, process, module */
        !function(app) {
            "use strict";
            var namespace = "cuid", c = 0, blockSize = 4, base = 36, discreteValues = Math.pow(base, blockSize), pad = function(num, size) {
                var s = "000000000" + num;
                return s.substr(s.length - size);
            }, randomBlock = function() {
                return pad((Math.random() * discreteValues << 0).toString(base), blockSize);
            }, safeCounter = function() {
                // this is not subliminal
                return c = c < discreteValues ? c : 0, c++, c - 1;
            }, api = function() {
                // Starting with a lowercase letter makes
                // it HTML element ID friendly.
                var // Prevent same-machine collisions.
                counter, letter = "c", // hard-coded allows for sequential access
                // timestamp
                // warning: this exposes the exact date and time
                // that the uid was created.
                timestamp = new Date().getTime().toString(base), // A few chars to generate distinct ids for different
                // clients (so different computers are far less
                // likely to generate the same id)
                fingerprint = api.fingerprint(), // Grab some more chars from Math.random()
                random = randomBlock() + randomBlock();
                return counter = pad(safeCounter().toString(base), blockSize), letter + timestamp + counter + fingerprint + random;
            };
            api.slug = function() {
                var counter, date = new Date().getTime().toString(36), print = api.fingerprint().slice(0, 1) + api.fingerprint().slice(-1), random = randomBlock().slice(-2);
                return counter = safeCounter().toString(36).slice(-4), date.slice(-2) + counter + print + random;
            }, api.globalCount = function() {
                // We want to cache the results of this
                var cache = function() {
                    var i, count = 0;
                    for (i in window) count++;
                    return count;
                }();
                return api.globalCount = function() {
                    return cache;
                }, cache;
            }, api.fingerprint = function() {
                return pad((navigator.mimeTypes.length + navigator.userAgent.length).toString(36) + api.globalCount().toString(36), 4);
            }, // don't change anything from here down.
            app.register ? app.register(namespace, api) : module.exports = api;
        }(this.applitude || this);
    }, /* 280 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var stringify = __webpack_require__(281), parse = __webpack_require__(284), formats = __webpack_require__(283);
        module.exports = {
            formats: formats,
            parse: parse,
            stringify: stringify
        };
    }, /* 281 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(282), formats = __webpack_require__(283), arrayPrefixGenerators = {
            brackets: function(prefix) {
                // eslint-disable-line func-name-matching
                return prefix + "[]";
            },
            indices: function(prefix, key) {
                // eslint-disable-line func-name-matching
                return prefix + "[" + key + "]";
            },
            repeat: function(prefix) {
                // eslint-disable-line func-name-matching
                return prefix;
            }
        }, toISO = Date.prototype.toISOString, defaults = {
            delimiter: "&",
            encode: !0,
            encoder: utils.encode,
            serializeDate: function(date) {
                // eslint-disable-line func-name-matching
                return toISO.call(date);
            },
            skipNulls: !1,
            strictNullHandling: !1
        }, stringify = function stringify(// eslint-disable-line func-name-matching
        object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter) {
            var obj = object;
            if ("function" == typeof filter) obj = filter(prefix, obj); else if (obj instanceof Date) obj = serializeDate(obj); else if (null === obj) {
                if (strictNullHandling) return encoder ? encoder(prefix) : prefix;
                obj = "";
            }
            if ("string" == typeof obj || "number" == typeof obj || "boolean" == typeof obj || utils.isBuffer(obj)) return encoder ? [ formatter(encoder(prefix)) + "=" + formatter(encoder(obj)) ] : [ formatter(prefix) + "=" + formatter(String(obj)) ];
            var values = [];
            if ("undefined" == typeof obj) return values;
            var objKeys;
            if (Array.isArray(filter)) objKeys = filter; else {
                var keys = Object.keys(obj);
                objKeys = sort ? keys.sort(sort) : keys;
            }
            for (var i = 0; i < objKeys.length; ++i) {
                var key = objKeys[i];
                skipNulls && null === obj[key] || (values = Array.isArray(obj) ? values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter)) : values.concat(stringify(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter)));
            }
            return values;
        };
        module.exports = function(object, opts) {
            var obj = object, options = opts || {};
            if (null !== options.encoder && void 0 !== options.encoder && "function" != typeof options.encoder) throw new TypeError("Encoder has to be a function.");
            var delimiter = "undefined" == typeof options.delimiter ? defaults.delimiter : options.delimiter, strictNullHandling = "boolean" == typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling, skipNulls = "boolean" == typeof options.skipNulls ? options.skipNulls : defaults.skipNulls, encode = "boolean" == typeof options.encode ? options.encode : defaults.encode, encoder = encode ? "function" == typeof options.encoder ? options.encoder : defaults.encoder : null, sort = "function" == typeof options.sort ? options.sort : null, allowDots = "undefined" != typeof options.allowDots && options.allowDots, serializeDate = "function" == typeof options.serializeDate ? options.serializeDate : defaults.serializeDate;
            if ("undefined" == typeof options.format) options.format = formats.default; else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) throw new TypeError("Unknown format option provided.");
            var objKeys, filter, formatter = formats.formatters[options.format];
            "function" == typeof options.filter ? (filter = options.filter, obj = filter("", obj)) : Array.isArray(options.filter) && (filter = options.filter, 
            objKeys = filter);
            var keys = [];
            if ("object" != typeof obj || null === obj) return "";
            var arrayFormat;
            arrayFormat = options.arrayFormat in arrayPrefixGenerators ? options.arrayFormat : "indices" in options ? options.indices ? "indices" : "repeat" : "indices";
            var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
            objKeys || (objKeys = Object.keys(obj)), sort && objKeys.sort(sort);
            for (var i = 0; i < objKeys.length; ++i) {
                var key = objKeys[i];
                skipNulls && null === obj[key] || (keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter)));
            }
            return keys.join(delimiter);
        };
    }, /* 282 */
    /***/
    function(module, exports) {
        "use strict";
        var has = Object.prototype.hasOwnProperty, hexTable = function() {
            for (var array = [], i = 0; i < 256; ++i) array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
            return array;
        }();
        exports.arrayToObject = function(source, options) {
            for (var obj = options && options.plainObjects ? Object.create(null) : {}, i = 0; i < source.length; ++i) "undefined" != typeof source[i] && (obj[i] = source[i]);
            return obj;
        }, exports.merge = function(target, source, options) {
            if (!source) return target;
            if ("object" != typeof source) {
                if (Array.isArray(target)) target.push(source); else {
                    if ("object" != typeof target) return [ target, source ];
                    target[source] = !0;
                }
                return target;
            }
            if ("object" != typeof target) return [ target ].concat(source);
            var mergeTarget = target;
            return Array.isArray(target) && !Array.isArray(source) && (mergeTarget = exports.arrayToObject(target, options)), 
            Array.isArray(target) && Array.isArray(source) ? (source.forEach(function(item, i) {
                has.call(target, i) ? target[i] && "object" == typeof target[i] ? target[i] = exports.merge(target[i], item, options) : target.push(item) : target[i] = item;
            }), target) : Object.keys(source).reduce(function(acc, key) {
                var value = source[key];
                return Object.prototype.hasOwnProperty.call(acc, key) ? acc[key] = exports.merge(acc[key], value, options) : acc[key] = value, 
                acc;
            }, mergeTarget);
        }, exports.decode = function(str) {
            try {
                return decodeURIComponent(str.replace(/\+/g, " "));
            } catch (e) {
                return str;
            }
        }, exports.encode = function(str) {
            // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
            // It has been adapted here for stricter adherence to RFC 3986
            if (0 === str.length) return str;
            for (var string = "string" == typeof str ? str : String(str), out = "", i = 0; i < string.length; ++i) {
                var c = string.charCodeAt(i);
                45 === c || // -
                46 === c || // .
                95 === c || // _
                126 === c || // ~
                c >= 48 && c <= 57 || // 0-9
                c >= 65 && c <= 90 || // a-z
                c >= 97 && c <= 122 ? out += string.charAt(i) : c < 128 ? out += hexTable[c] : c < 2048 ? out += hexTable[192 | c >> 6] + hexTable[128 | 63 & c] : c < 55296 || c >= 57344 ? out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c] : (i += 1, 
                c = 65536 + ((1023 & c) << 10 | 1023 & string.charCodeAt(i)), out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c]);
            }
            return out;
        }, exports.compact = function(obj, references) {
            if ("object" != typeof obj || null === obj) return obj;
            var refs = references || [], lookup = refs.indexOf(obj);
            if (lookup !== -1) return refs[lookup];
            if (refs.push(obj), Array.isArray(obj)) {
                for (var compacted = [], i = 0; i < obj.length; ++i) obj[i] && "object" == typeof obj[i] ? compacted.push(exports.compact(obj[i], refs)) : "undefined" != typeof obj[i] && compacted.push(obj[i]);
                return compacted;
            }
            var keys = Object.keys(obj);
            return keys.forEach(function(key) {
                obj[key] = exports.compact(obj[key], refs);
            }), obj;
        }, exports.isRegExp = function(obj) {
            return "[object RegExp]" === Object.prototype.toString.call(obj);
        }, exports.isBuffer = function(obj) {
            return null !== obj && "undefined" != typeof obj && !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
        };
    }, /* 283 */
    /***/
    function(module, exports) {
        "use strict";
        var replace = String.prototype.replace, percentTwenties = /%20/g;
        module.exports = {
            default: "RFC3986",
            formatters: {
                RFC1738: function(value) {
                    return replace.call(value, percentTwenties, "+");
                },
                RFC3986: function(value) {
                    return value;
                }
            },
            RFC1738: "RFC1738",
            RFC3986: "RFC3986"
        };
    }, /* 284 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        var utils = __webpack_require__(282), has = Object.prototype.hasOwnProperty, defaults = {
            allowDots: !1,
            allowPrototypes: !1,
            arrayLimit: 20,
            decoder: utils.decode,
            delimiter: "&",
            depth: 5,
            parameterLimit: 1e3,
            plainObjects: !1,
            strictNullHandling: !1
        }, parseValues = function(str, options) {
            for (var obj = {}, parts = str.split(options.delimiter, options.parameterLimit === 1 / 0 ? void 0 : options.parameterLimit), i = 0; i < parts.length; ++i) {
                var key, val, part = parts[i], pos = part.indexOf("]=") === -1 ? part.indexOf("=") : part.indexOf("]=") + 1;
                pos === -1 ? (key = options.decoder(part), val = options.strictNullHandling ? null : "") : (key = options.decoder(part.slice(0, pos)), 
                val = options.decoder(part.slice(pos + 1))), has.call(obj, key) ? obj[key] = [].concat(obj[key]).concat(val) : obj[key] = val;
            }
            return obj;
        }, parseObject = function(chain, val, options) {
            if (!chain.length) return val;
            var obj, root = chain.shift();
            if ("[]" === root) obj = [], obj = obj.concat(parseObject(chain, val, options)); else {
                obj = options.plainObjects ? Object.create(null) : {};
                var cleanRoot = "[" === root.charAt(0) && "]" === root.charAt(root.length - 1) ? root.slice(1, -1) : root, index = parseInt(cleanRoot, 10);
                !isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit ? (obj = [], 
                obj[index] = parseObject(chain, val, options)) : obj[cleanRoot] = parseObject(chain, val, options);
            }
            return obj;
        }, parseKeys = function(givenKey, val, options) {
            if (givenKey) {
                // Transform dot notation to bracket notation
                var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey, parent = /^([^[]*)/, child = /(\[[^[\]]*])/g, segment = parent.exec(key), keys = [];
                if (segment[1]) {
                    // If we aren't using plain objects, optionally prefix keys
                    // that would overwrite object prototype properties
                    if (!options.plainObjects && has.call(Object.prototype, segment[1]) && !options.allowPrototypes) return;
                    keys.push(segment[1]);
                }
                for (// Loop through children appending to the array until we hit depth
                var i = 0; null !== (segment = child.exec(key)) && i < options.depth; ) {
                    if (i += 1, !options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1)) && !options.allowPrototypes) return;
                    keys.push(segment[1]);
                }
                // If there's a remainder, just add whatever is left
                return segment && keys.push("[" + key.slice(segment.index) + "]"), parseObject(keys, val, options);
            }
        };
        module.exports = function(str, opts) {
            var options = opts || {};
            if (null !== options.decoder && void 0 !== options.decoder && "function" != typeof options.decoder) throw new TypeError("Decoder has to be a function.");
            if (options.delimiter = "string" == typeof options.delimiter || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter, 
            options.depth = "number" == typeof options.depth ? options.depth : defaults.depth, 
            options.arrayLimit = "number" == typeof options.arrayLimit ? options.arrayLimit : defaults.arrayLimit, 
            options.parseArrays = options.parseArrays !== !1, options.decoder = "function" == typeof options.decoder ? options.decoder : defaults.decoder, 
            options.allowDots = "boolean" == typeof options.allowDots ? options.allowDots : defaults.allowDots, 
            options.plainObjects = "boolean" == typeof options.plainObjects ? options.plainObjects : defaults.plainObjects, 
            options.allowPrototypes = "boolean" == typeof options.allowPrototypes ? options.allowPrototypes : defaults.allowPrototypes, 
            options.parameterLimit = "number" == typeof options.parameterLimit ? options.parameterLimit : defaults.parameterLimit, 
            options.strictNullHandling = "boolean" == typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling, 
            "" === str || null === str || "undefined" == typeof str) return options.plainObjects ? Object.create(null) : {};
            for (var tempObj = "string" == typeof str ? parseValues(str, options) : str, obj = options.plainObjects ? Object.create(null) : {}, keys = Object.keys(tempObj), i = 0; i < keys.length; ++i) {
                var key = keys[i], newObj = parseKeys(key, tempObj[key], options);
                obj = utils.merge(obj, newObj, options);
            }
            return utils.compact(obj);
        };
    }, /* 285 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(101), _inherits3 = _interopRequireDefault(_inherits2), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _reactRouterDom = __webpack_require__(258), _styledComponents = __webpack_require__(114), _PropTypes = __webpack_require__(232), Slide = function(_Component) {
            function Slide(props, context) {
                (0, _classCallCheck3.default)(this, Slide);
                var _this = (0, _possibleConstructorReturn3.default)(this, (Slide.__proto__ || (0, 
                _getPrototypeOf2.default)(Slide)).call(this, props, context));
                return _this._stepIndex = 0, _this._renderComponent = _this._renderComponent.bind(_this), 
                _this;
            }
            return (0, _inherits3.default)(Slide, _Component), (0, _createClass3.default)(Slide, [ {
                key: "componentWillMount",
                value: function() {
                    var presentation = this.context.presentation, _presentation$getSlid = presentation.getSlideMetadata(this), path = _presentation$getSlid.path, slideIndex = _presentation$getSlid.slideIndex;
                    this._path = path, this._slideIndex = slideIndex;
                }
            }, {
                key: "componentWillUnmount",
                value: function() {
                    this._stepIndex = 0;
                }
            }, {
                key: "getChildContext",
                value: function() {
                    return {
                        slide: this
                    };
                }
            }, {
                key: "getNumSteps",
                value: function() {
                    return this._numSteps || this._stepIndex + 1;
                }
            }, {
                key: "registerStep",
                value: function(index) {
                    this._stepIndex = Math.max(this._stepIndex, index);
                }
            }, {
                key: "render",
                value: function() {
                    return _react2.default.createElement(_reactRouterDom.Route, {
                        exact: !0,
                        path: this._path,
                        render: this._renderComponent
                    });
                }
            }, {
                key: "setNumSteps",
                value: function(numSteps) {
                    this._numSteps = numSteps;
                }
            }, {
                key: "_renderComponent",
                value: function() {
                    var _context = this.context, pluginProps = _context.pluginProps, presentation = _context.presentation, _props = this.props, Component = _props.component, render = _props.render, isPresenterMode = pluginProps.isPresenterMode, slideIndex = this._slideIndex, stepIndex = presentation.getStepIndex(), rendered = void 0;
                    return rendered = "function" == typeof render ? render({
                        isPresenterMode: isPresenterMode,
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }) : _react2.default.createElement(Component, {
                        isPresenterMode: isPresenterMode,
                        slideIndex: slideIndex,
                        stepIndex: stepIndex
                    }), _react2.default.createElement(_styledComponents.ThemeProvider, {
                        theme: {
                            isPresenterMode: isPresenterMode
                        }
                    }, rendered);
                }
            } ]), Slide;
        }(_react.Component);
        Slide.childContextTypes = {
            slide: _PropTypes.slideContext.isRequired
        }, Slide.contextTypes = {
            pluginProps: _react.PropTypes.object.isRequired,
            presentation: _PropTypes.presentationContext.isRequired
        }, exports.default = Slide;
    }, /* 286 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _getPrototypeOf = __webpack_require__(75), _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf), _classCallCheck2 = __webpack_require__(78), _classCallCheck3 = _interopRequireDefault(_classCallCheck2), _createClass2 = __webpack_require__(79), _createClass3 = _interopRequireDefault(_createClass2), _possibleConstructorReturn2 = __webpack_require__(83), _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2), _inherits2 = __webpack_require__(101), _inherits3 = _interopRequireDefault(_inherits2), _react = __webpack_require__(109), _react2 = _interopRequireDefault(_react), _PropTypes = __webpack_require__(232), Step = function(_Component) {
            function Step() {
                return (0, _classCallCheck3.default)(this, Step), (0, _possibleConstructorReturn3.default)(this, (Step.__proto__ || (0, 
                _getPrototypeOf2.default)(Step)).apply(this, arguments));
            }
            return (0, _inherits3.default)(Step, _Component), (0, _createClass3.default)(Step, [ {
                key: "componentWillMount",
                value: function() {
                    var slide = this.context.slide, _props = this.props, index = _props.index, maxIndex = _props.maxIndex;
                    maxIndex < 1 / 0 ? slide.registerStep(maxIndex) : slide.registerStep(index);
                }
            }, {
                key: "render",
                value: function() {
                    var _context = this.context, pluginProps = _context.pluginProps, presentation = _context.presentation, _props2 = this.props, children = _props2.children, exact = _props2.exact, index = _props2.index, maxIndex = _props2.maxIndex, isPresenterMode = pluginProps.isPresenterMode, stepIndex = presentation.getStepIndex(), match = void 0;
                    return match = exact ? stepIndex === index : stepIndex >= index && stepIndex <= maxIndex, 
                    match ? children : isPresenterMode ? _react2.default.createElement("div", {
                        style: {
                            opacity: .35
                        }
                    }, children) : null;
                }
            } ]), Step;
        }(_react.Component);
        Step.contextTypes = {
            pluginProps: _react.PropTypes.object.isRequired,
            presentation: _PropTypes.presentationContext.isRequired,
            slide: _PropTypes.slideContext.isRequired
        }, Step.defaultProps = {
            maxIndex: 1 / 0
        }, exports.default = Step;
    }, /* 287 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _taggedTemplateLiteral2 = __webpack_require__(2), _taggedTemplateLiteral3 = _interopRequireDefault(_taggedTemplateLiteral2), _templateObject = (0, 
        _taggedTemplateLiteral3.default)([ "\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  height: 100%;\n  background-color: #222;\n  color: #fff;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n" ], [ "\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n  height: 100%;\n  background-color: #222;\n  color: #fff;\n  padding: 1rem;\n\n  ", "\n\n  @media (max-width: 600px) {\n    padding: 0.5rem;\n  }\n" ]), _styledComponents = __webpack_require__(114), _styledComponents2 = _interopRequireDefault(_styledComponents), _presenterSlideStyle = __webpack_require__(192), _presenterSlideStyle2 = _interopRequireDefault(_presenterSlideStyle);
        exports.default = _styledComponents2.default.div(_templateObject, _presenterSlideStyle2.default);
    } ]);
});
//# sourceMappingURL=react-presents.js.map